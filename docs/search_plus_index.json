{"./":{"url":"./","title":"前言","keywords":"","body":" Introduction iOS 必备知识 内存管理 Block 多线程 Runtime Runloop 第三方库的源码 生命周期 UI 数据存储 架构 OC 语言特性 其他 必备书单 通用必备基础知识 计算机网络 算法 数据结构 编译原理 操作系统 数据库 设计模式 概率论 Linux 版本控制 通用语言基础 Introduction iOS 必备知识 内存管理 ARC 和 MRC 的区别 属性的关键字，他们具体的底层实现以及区别，被问烂的知识点包括 copy， 浅拷贝和深拷贝的区别， weak 的底层实现。稍微新颖一点的 assgin 和 weak，unsafe_unretained 具体有什么区别，assgin是否可以用来修饰对象。这一部分是面试必问，一定要弄懂。 Autorelease pool的底层实现原理，与 Runloop 的关系， autoreleasing 关键字。 Block 本质，基础概念 使用时要注意的地方 block的实现，如何截获自动变量的，如何修改自动变量的值的，block的几种形式 __block的本质 forwarding 指针 block怎么避免循环引用。是不是所有的block都会产生循环引用，block里面怎么避免被提前释放 多线程 iOS 中多线程的几种方式，区别，使用场景，基本概念，同步异步，串行并行的区别。 GCD，写一个死锁，并行和串行队列，同步和异步的区别，GCD怎么控制最大并发数 怎么让子线程定时执行一个方法，具体的实现方法 如何控制线程的最大并发数为10，然后加载十个图片最后展示出来，具体方法 子线程的runloop是怎么执行的，它里面的 autoreleasepool 是怎么执行的。 NSMutableArray 怎么保证线程安全的。 GCD怎么避免block中的变量被提前释放 Runtime 消息的动态转发 给 Category 添加属性，关联对象都有几种形式 method swizzling 说一说类的结构，运行时中的class都有什么属性，property都有什么属性 说一说isa指到NSObject的那个过程 Category的本质，load方法什么时候加载，Category重写了父类的方*怎样，底层源码 ，如果两个Category和一个基类，都有同名方法，先执行哪个 property会自动生成什么，如果此时已经有下划线_name的实例变量了那会生成什么 load 和 initialize Runloop runloop实现原理 source 类型 线程保活的方式 runloop和多线程的关系，以及timer的关系 第三方库的源码 生命周期 app 的声生命周期 控制器的生命周期 视图的生命周期 UI UICellectionView 瀑布流 UITableView 相关的优化，底层原理等 页面布局 layoutSubviews 和 drawRect 等的区别 自己实现一个 UIScrollView 事件的传递链和响应链 界面非常卡顿怎么定位到具体的类和方法 UIView 和 CALayer 区别 数据存储 数据持久化都有什么，用过什么，归档，偏好设置都可以存储什么类型 架构 MVC、MVVM 从 0 到 1 实现一个 app 的思路 对于项目从 main 函数执行之前到之后启动优化，卡顿优化和界面优化 OC 语言特性 OC 和 C 的区别， OC 和 Java、C++ 的区别 iOS 中的协议 OC 动态性 C 语言如何动态的交换两个方法的实现 其他 KVO 的底层原理，自己实现 KVC 的底层原理，自己实现 NSNotification 的底层原理，是同步还是一部，如何实现一个，如果在子线程接收一个通知能不能接收到 几种页面传值方式的区别 界面非常卡顿怎么定位到具体的类和方法 一个 int 类型的值，被 @ 包装成 NSNumber 类型，传递到一个接受 id 类型的方法参数中，这个值能不能保持正确 在 iPad 上面，分屏功能，拖拽 wps 的文件到 qq 的过程是怎么实现的 (进程间通信的方法) 如何实现 dispatch_once Instrument 的使用 热修复用过吗，平时版本怎么迭代，线上 bug 怎么修复？ 必备书单 ​ 图解 TCP/IP, 图解 HTTP ​ 剑指offer ​ Effective Objective-C ​ iOS 与 OSX 高级编程 ​ 以上都是必须要重复看很多遍的书单，其他不太重要的暂不列出 通用必备基础知识 ​ 抛开iOS 开发这一项技能，我们最基础的本质还是一名软件开发工程师，所以基础的部分必不可少，本篇面经中，不会具体总结出每个公司每一面具体考的内容，而是会根据不同的知识点将面试真题分为不同的专题部分来具体分析。 计算机网络 ​ 对于大前端类，计算机网络主要考量的还是传输层和应用层部分的知识。 ​ 浏览器输入url到网页显示经历了什么过程? ​ TCP三次握手：具体是怎么握手？为什么要三次握手？两次行不行？为什么不行？三次握手，第二次和第三次分别因为什么? ​ TCP是如何保持可靠传输的（拥塞控制，慢启动等等概念的理解） ​ TCP为什么要四次挥手，TIME_WAIT为什么至少设置两倍的MSL时间？ ​ TCP三次握手的详细数据传递，四次挥手详细数据内容，数据包组成、TIME_WAIT状态，2MSL，RTT，重传、滑动窗口、拥塞原理等等 ​ TCP、UDP面向连接、无连接具体理解，他们的区别，如何将 UDP 改造成和 TCP 功能相似 ​ TCP/IP四层协议，OSI七层协议，每层都有啥对应的协议，原理是啥 ​ http报文结构，http中超文本超是啥意思，http请求的组成 ​ http 报文头部含有什么，multipart了解吗 ​ http的状态码，200，304，301，http请求报文，响应报文 ​ get和post请求的区别？什么情况下用到？POST传输的数据都有哪些格式呢（这里需要搞定http各种请求传输的数据格式） ​ 描述一次完整的http请求 ​ 什么是cookie，什么是session，区别联系，cookie的本质是什么 ​ http1.0，1.1，2.0的区别 ​ https有几次握手和挥手？https的原理。http有几次挥手和握手？TLS在哪一网络层，基本原理是什么？ ​ https与中间人攻击 ​ HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数 ​ HTTPS是什么？握手过程，SSL原理，非对称加密了解多少 ​ 证书是干什么用的 算法 ​ 剑指 offer 上面的题目都是面试过程中的算法高频题，特别是二叉树和字符串，栈队列，链表，跳台阶问题一定要弄懂并且熟练。 ​ 八大排序算法的复杂度，概念，最好最坏情况，手写都是必须要掌握的，其中的重点是快排和堆排序，对于快排的优化，快排的基础原理，系统 API 快排的实现原理等都是必须要掌握的基础知识。 ​ 二分查找在面试过程中也比较常见，因为比较简单，包括二分查找的变种。 ​ 二叉树的前中后序的递归与非递归遍历方式，以及层序遍历和蛇形遍历都是重点。 ​ 海量数据如何找到重复次数最多的那个 优化 ​ 海量数据，但是都是1~100之间的，如何找到重复次数最多的那个 ​ 面试算法题一般不难，掌握技巧很重要。二叉树相关的算法题基本都要往二叉树的遍历上靠，链表相关的算法题基本都要往额外的“帮助指针”上面靠。 数据结构 ​ 在面试过程中这一类主要是和算法来一起考，数据结构一般主要会问栈与堆的区别，栈与队列的区别等等，在前端的面试中，红黑树这类的很少被问到。 编译原理 ​ 主要需要了解程序的编译过程的基础概念就OK。 操作系统 ​ 操作系统老生常谈的就是进程，线程的概念和区别，几个状态，以及他们的调度方式，通信方式，保持安全等等知识点，基本面试都会被考到一点，这一部分需要牢牢掌握，实在理解不了就背下来。 ​ 说说递归和普通的循环方式有什么区别 ​ 计算机存储系统是指？哪些存储系统能提高程序执行的效率？ ​ 段错误和栈溢出分别在什么时候会出现，为什么 ​ 其他方面的包括页置换等等基础知识，知道概念就OK，在前端面试过程中这部分不是特别重点考量的点。 数据库 ​ 数据库这部分也比较简单，主要就是 ACID 等基础概念，几大范式，简单的 sql 语句。 设计模式 ​ 工厂方法，抽象工厂，简单工厂的区别和联系 ​ 装饰者 ​ 观察者 ​ *模式等等 概率论 ​ 三门问题 ​ 红黑球等等常见问题百度即可 Linux ​ 主要包括基本的 shell 编程，基本的脚本命令，重点是 grep，ps，top，free等 版本控制 ​ 版本控制主要包括 Git 和 SVN ​ git 的基础概念，基本命令，包括 merge 和 rebase 的区别等。 ​ Git 和 SVN 的区别，异同点 ​ 平时开发中，版本控制的流程是怎么样的 通用语言基础 ​ 面向对象的多态。多态的几种方式 ​ 各个语言中的单例模式 ​ 内存管理方式 ​ static 和 const 的作用和区别 ​ C 语言的内存分段 "},"知识库/笔记/编程语言学习/编程语言学习.html":{"url":"知识库/笔记/编程语言学习/编程语言学习.html","title":"编程语言学习","keywords":"","body":" 编程语言学习 基础语法 数据处理 内存中如何存储数据 基本数据类型 字符串 集合类型 变量和常量 可选项 表达式 流程控制 循环控制 高级? 函数 / 方法 指针 函数指针 / Block / Closure 结构体 枚举 面向对象 内存管理 数据类型与变量 可用来声明变量的数据类型: 数据类型与变量的使用 文件权限控制 编程语言学习 基础语法 数据处理 内存中如何存储数据 基本数据类型 字符串 集合类型 数组 字典 集合 变量和常量 声明 初始化 / 赋值 值输出 作用域 可选项 表达式 算术运算符和算术表达式 复合赋值运算符、自增自减运算、逗号表达式、比较表达式、三元表达式 流程控制 逻辑运算符及其优先级 if 结构 循环控制 switch-case 语法 while 循环 do-while 循环 break, continue, goto 关键字 for 循环 高级? 函数 / 方法 意义 函数声明 函数实现 函数调用 参数 参数的本质 形参 实参 返回值 执行步骤 不同数据类型作为函数参数和返回值时的传值方式 基本数据类型(int, char, float, double) 数组 结构体【个人创建的数据类型】 指针【存储变量所在的内存空间的地址】 函数指针 结构体指针 指针 变量的值和地址 指针类型变量的声明、初始化和使用 野指针、NULL 指针类型与函数 函数指针 / Block / Closure 声明变量 与函数 做函数的参数 做函数的返回值 初始化 / 赋值 调用 结构体 结构体概述 用结构体创建新数据类型 结构体存在的意义 新数据类型(使用结构体创建)的变量的初始化、默认值 新数据类型(使用结构体创建)之间的相互赋值 新数据类型(使用结构体创建)与数组 新数据类型(使用结构体创建)与指针 新数据类型(使用结构体创建)嵌套 新数据类型(使用结构体创建)与函数 typedef 定义新数据类型 枚举 面向对象 类 成员属性 方法 对象 对象的创建 对象的使用 对象的存储 对象的消息机制 构造和析构函数 构造函数 (创建对象的方法) 重载构造函数 (initWith) 重写构造函数 (override) KVC 构造函数 (用dict创建对象) 便利构造函数 (条件判断是否创建对象) 析构函数 封装 将相同功能的代码抽取并封装为方法、对象等 继承 子类继承父类的属性和方法 多态 同一方法名，不同具体实现 内存管理 数据类型与变量 任何数据类型都会用来与变量打交道 可用来声明变量的数据类型: 基本数据类型和基本数据类型组合的新数据类型 int, char, float, double pointer newDataType(使用结构体 struct 和 typedef 创建的、使用 enum 和 typedef 创建的) array, dictionary 数据类型与变量的使用 变量的声明 比如声明int类型的变量、指针类型的变量、struct Person 类型的变量 变量的默认值、初始化 / 赋值 变量与容器(数组、字典) 变量与指针 变量与函数 文件权限控制 "},"知识库/笔记/编程语言学习/C 语言/C 语言知识点.html":{"url":"知识库/笔记/编程语言学习/C 语言/C 语言知识点.html","title":"C 语言","keywords":"","body":" C 语言知识点 Day01 开发前奏 Day02 IDE和基本数据类型 Day03 表达式 Day04 流程控制结构 Day05 循环控制结构 Day06 循环控制结构 Day07 函数 Day08 进制 Day09 数组 Day10 字符串 Day11 指针 Day12 指针 Day13 结构体与枚举 Day14 预处理指令 C 语言知识点 Day01 开发前奏 操作系统 应用软件和操作系统 移动开发 OS X、Dock栏、任务栏、OS X系统的目录结构、移动磁盘的读写和操作 C语言介绍 终端使用 开发C程序的步骤 Day02 IDE和基本数据类型 数据处理 内存中如何存储数据 变量的声明、赋值、输出printf 基本数据类型: int, char, float, double Day03 表达式 输入scanf、 算术运算符和算术表达式、 复合赋值运算符、 自增自减运算、 逗号表达式、 比较表达式 Day04 流程控制结构 逻辑运算符和其优先级、 if结构、 变量作用域、 三元表达式 Day05 循环控制结构 switch-case语法、 程序调试、 while循环、 break、 continue Day06 循环控制结构 do-while循环、 for循环 Day07 函数 函数意义使用函数来实现代码的重用、 函数声明、 实现、 调用、 参数的本质、形参、实参、【基本数据类型、数组、结构体、函数作为函数参数时不同传递】 执行步骤、 返回值、 goto、break、continue补充。 Day08 进制 预处理指令概述、 文件包含指令、 相对路径和绝对路径、 多文件开发、 二、八、十、十六进制、 内存构造和变量占用的字节数、 原码、反码、补码、按位与、或、取反、异或、左移、右移、 深入变量、 int修饰符、有符号和无符号、 char变量深入 Day09 数组 格式控制符总结、 垃圾值、 数组概述、 声明、 存储、 元素本质、取值、遍历、长度、元素默认值和初始化、在内存中的存储形式、地址、 长度计算、 【必须掌握的算法：找最大值、找最小值、求累加和、求平均值、判断数组包含某元素、找某元素第一次出现的下标、产生不重复的随机数、选择排序、冒泡排序！、二分查找法】、 数组作为函数参数是地址传递 Day10 字符串 数组函数模块、 二维数组声明、 存值、取值、遍历、行列数、初始化、 在内存中的存储、 与函数(作为参数、返回值)、 字符数组、 从控制台接受字符串数据、 字符串长度计算、 字符串相关函数 Day11 指针 变量的值和地址、 指针变量声明、初始化、使用、 野指针、NULL、 多个指针指向同一变量、 指针与函数、指针类型、多级指针、指针与整数的加减法、 指针与数组、使用指针遍历数组、数组作为函数参数的本质、数组使用中括号下标的本质、指针变量的加减法、存储指针的数组、 指针之间的减法和比较运算 Day12 指针 字符串数据的两种存储方式、 内存中的五大区域、 字符串的恒定性、字符串数组、 字符串数组排序、 fputs输出字符串、fgets输入字符串、 const修饰基本数据类型、数组、指针、 malloc、calloc与realloc函数 Day13 结构体与枚举 指针与函数、 指向函数的指针、 结构体概述、 用结构体创建新数据类型、 结构体存在的意义、 结构体变量初始化、默认值、 结构体类型的作用域、 结构体变量之间的相互赋值、结构体数组、指针、结构体嵌套、结构体与函数、枚举的简单使用、typedef类型定义 Day14 预处理指令 文件包含指令、 宏定义、 带参数和无参数的宏、 条件编译指令、 static和extern "},"知识库/笔记/编程语言学习/Objective-C 语言/OC 知识点.html":{"url":"知识库/笔记/编程语言学习/Objective-C 语言/OC 知识点.html","title":"Objective-C 语言","keywords":"","body":" Ojective-C 语言 OC 概述 OC 中的面向对象 OC 中面向对象特性 OC 中分类、协议、类扩展、委托模型 Block 复制 (深浅拷贝) 单例 内存管理 Foundation 框架介绍 文件操作 对象归档 KVC / KVO Ojective-C 语言 OC 概述 OC 介绍及发展背景 OC 对比 C 语言的差异化 OC - HelloWorld OC 中的面向对象 类的基本概念 方法、成员属性 对象的基本概念 对象的声明、使用、存储细节 对象的消息机制 OC 中面向对象特性 封装 继承 多态 OC 中分类、协议、类扩展、委托模型 分类 / 类目 Category 协议 Protocol 类扩展 / 延展 Extension 委托模型 Delegate (代理模式) Block blocks 基本概念 blocks 声明 blocks 使用 blocks 作为方法的参数 blocks 作回调 block 作用域 复制 (深浅拷贝) 单例 copy 和 mutableCopy 单例模式 内存管理 ARC 和 非 ARC 的区别 手动内存管理 手动释放池介绍 点语法内存管理 Foundation 框架介绍 NSString / NSMutableString NSArray / NSMutableArray NSDictionary / NSMutableDictionary NSData NSSet / NSMutableSet NSPoint / NSRange / NSRect NSNumber / NSValue / NSNull 文件操作 NSFileManager NSFileHandle 应用程序沙盒及使用 对象归档 NSKeyedArchiver / NSKeyedUnarchiver NSCoder KVC / KVO NSKeyValueCoding Key-Value Observing "},"知识库/笔记/编程语言学习/Swift 语言/":{"url":"知识库/笔记/编程语言学习/Swift 语言/","title":"Swift 语言","keywords":"","body":" Swift 和 OC 语言 Swift 简介 Swift 快速体验 Swift 基础语法 Swift 函数和闭包 函数 闭包 Swift 面向对象 构造和析构函数 懒加载 计算型属性 重写 setter 方法 命名空间和反射机制 获取成员变量、属性和方法列表 Swift 和 OC 语言 Swift 简介 Swift 快速体验 Playground 第一个应用程序 Swift 基础语法 变量和常量 可选项 控制流 循环 字符串 集合 错误处理 Swift 函数和闭包 函数 函数的定义 闭包 闭包的定义 声明变量【闭包类型】 做函数的参数【闭包类型】 做函数的返回值【闭包类型】 尾随闭包 闭包的循环引用和解除 Swift 面向对象 构造和析构函数 构造函数基础 重载和重写构造函数 KVC 构造函数[运行时] 便利构造函数 析构函数 懒加载 计算型属性 重写 setter 方法 命名空间和反射机制 获取成员变量、属性和方法列表 "},"知识库/笔记/编程语言学习/PHP/PHP.html":{"url":"知识库/笔记/编程语言学习/PHP/PHP.html","title":"PHP","keywords":"","body":"服务器端php搭建 登录 login.php 1, 'userName' => $userName, 'userImage' => $accessType ); // 将数据字典使用JSON编码 echo json_encode($result); } else { // 将查询结果绑定到数据字典 $result = array( 'userId' => -1, 'userName' => $userName, 'userImage' => $accessType ); // 将数据字典使用JSON编码 echo json_encode($result); } return true; } } header('Content-Type:application/json;charset=utf-8'); $itcast = new itcastUsers; $itcast->userLogin(); ?> login.html post请求 GET请求 POST请求 上传文件 upload.php ```php // 打印出上传的文件的信息 print_r($_FILES); // 创建一个空数组(字典?)来存储最终要返回的响应 $response = array(); // 获取服务器的根目录，拼接存储上传的文件的路径 $target_path = $_SERVER['DOCUMENT_ROOT'].\"/upload/files/\";//接收文件目录 // 在上传的路径上拼接文件名 $target_path = $target_path . basename( $_FILES['userfile']['name']); // 将文件从暂存目录移动到接收文件目录 // $_FILES是个字典 // $_FILES['userfile']是上传的文件的信息数组 // $_FILES['userfile']['tmp_name']是文件信息数组中文件的暂存路径(包括文件临时名称) if(move_uploaded_file($_FILES['userfile']['tmp_name'], $target_path)) { // 如果上传成功，往响应字典中存储成功信息 $response ['success'] = \"The file \". basename( $_FILES['userfile']['name']). \" has been uploaded\"; } else{ // 如果上传失败，存储失败信息 $response ['error'] = \"There was an error uploading the file, please try again!\". $_FILES['userfile']['error']; } // 返回响应json格式 echo json_encode($response); ?> ``` upload.html 文件上传测试 文件上传 请选择要上传的文件: "},"知识库/笔记/编程语言学习/JavaScript/JavaScript.html":{"url":"知识库/笔记/编程语言学习/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript 介绍 JavaScript是一门广泛用于浏览器客户端的脚本语言 由Netspace公司设计，当时跟Sun公司合作，所以名字起的像Java 一般简称JS 常见用途 HTML DOM操作(节点操作，比如添加、修改、删除节点) 给HTML网页增加动态功能，比如动画 事件处理：比如监听鼠标点击、鼠标滑动、键盘输入 语法 声明变量 var num = 5; 循环 for (var i = 0; i 打印到控制台 console.log() 声明方法 function() { } 获取HTML文档中的控件 document.getElementById(\"textField1\"); document.getElementsByTagName(\"input\"); 返回数组 判断 viewDidLoad window.onload = function() {当html的所有view全都加载完毕后执行的代码} 跳转到文档中的某个位置 document.location.href = '#id号'; "},"知识库/笔记/编程语言学习/HTML & CSS/HTML.html":{"url":"知识库/笔记/编程语言学习/HTML & CSS/HTML.html","title":"HTML","keywords":"","body":"HTML 详见Practice中的【HTML练习】 可在菜鸟教程学习https://www.runoob.com/ WebStorm IDE破解 http://www.mamicode.com/info-detail-2912162.html WebStorm无法打开解决 https://www.javatang.com/archives/2017/10/09/32061820.html HTML简介 什么是HTML Hyper Text Markup Language, 超文本标记语言 其实就是文本，由浏览器负责将它解析成具体的网页内容 比如，浏览器会将左边的HTML代码转换为右边的网页内容 HTML和XML的区别 html的标签是预定义好的 xml的标签是自己定义的 html目的是用来展示数据 xml目的是用来存储或通过网络传输数据 HTML演示 主要理解表单的作用：让用户提交数据 HTML 组成 跟XML类似，HTML由N个标签(节点、元素、标记)组成 HTML语法非常松散，目前的最新版是5.0，也就是HTML5 常见标签 标题: h1, h2, h3, h4, h5... 段落: p 换行: br 容器: div, span (用来容纳其他标签) 表格: \\ table row table head table data相当于cell列表: ul 无序列表 ol 有序列表 li 每项 图片: img 【images/01.jpg这种路径是相对于当前html所在路径的相对路径】 表单: input【textField、UIButton等获取用户输入的控件】 链接: a 百度 【超链接】 空格:   注释 一条横线 "},"知识库/笔记/编程语言学习/HTML & CSS/CSS.html":{"url":"知识库/笔记/编程语言学习/HTML & CSS/CSS.html","title":"CSS","keywords":"","body":"CSS 【详见Practice中的HTML练习】 简介 CSS的全称是Cascading Style Sheets，层叠样式表 用来控制HTML标签的样式，在美化网页中起到非常重要的作用 CSS的编写格式是键值对形式的 color: red; background-color: blue; font-size: 20px; CSS有3种形式 行内样式：直接在tag的属性处用style设置 页内样式: 创建一个style class，在tag属性处应用 外部样式: 在外部的css文件中声明style class，链接这个文件到此html，在tag属性处应用那些class 选择器 作用 选择对应的标签，为其添加样式 分类 标签选择器 div { color:red; } 类选择器 .cls { color:blue; } id选择器 #hi { color:orange; } 并列选择器 div, .cls { color: red; }【所有div和所有cls类都用这个样式】“或” 复合选择器 div .cls { color:red; }【是div且cls类的才用这个样式】\"且\" 后代选择器 div p {color: red;} 直接后代选择器 div > p {color: red;} 布局介绍 【见practices中的布局介绍】 "},"知识库/笔记/iOS 知识点.html":{"url":"知识库/笔记/iOS 知识点.html","title":"iOS 知识点","keywords":"","body":" iOS知识点 架构 UI 数据读取解析存储 内存管理 Block / Closure / 函数指针 多线程、Runloop、自动释放池 网络 Runtime 原理及应用 生命周期 OC 语言特性 常用功能集成 支付 地图 音频、视频 IM 分享 崩溃收集 第三方库的源码 其他 iOS知识点 架构 MVC MVVM 从 0 到 1 实现一个 app 的思路 对于项目从 main 函数执行之前到之后启动优化，卡顿优化和界面优化 UI UICollectionView 瀑布流 UITableView 相关的优化，底层原理等 页面布局 layoutSubviews 和 drawRect 等的区别 自己实现一个 UIScrollView 事件的传递链和响应链 界面非常卡顿怎么定位到具体的类和方法 UIView 和 CALayer 区别 页面跳转的方法和区别 页面传值的方法和区别 数据读取解析存储 JSON 生成和解析 PropertyList 生成和解析 XML 生成和解析 NSFileManager 沙盒 UserDefaults 用户偏好 NSCache 钥匙串 本地数据库 FMDB CoreData Realm Firebase iCloud 内存管理 ARC 和 MRC 的区别 @property 属性的关键字 / 修饰符 他们具体的底层实现以及区别，被问烂的知识点包括 copy 浅拷贝和深拷贝的区别 weak 的底层实现 assgin 和 weak，assgin是否可以用来修饰对象 unsafe_unretained 具体有什么区别 Autorelease pool的底层实现原理，与 Runloop 的关系， autoreleasing 关键字 Block / Closure / 函数指针 本质，基础概念 使用时要注意的地方 block的实现，如何截获自动变量的，如何修改自动变量的值的，block的几种形式 __block的本质 forwarding 指针 block怎么避免循环引用。是不是所有的block都会产生循环引用，block里面怎么避免被提前释放 多线程、Runloop、自动释放池 iOS 中多线程的几种方式，区别，使用场景，基本概念，同步异步，串行并行的区别。 GCD，写一个死锁，并行和串行队列，同步和异步的区别，GCD怎么控制最大并发数 怎么让子线程定时执行一个方法，具体的实现方法 如何控制线程的最大并发数为10，然后加载十个图片最后展示出来，具体方法 子线程的runloop是怎么执行的，它里面的 autoreleasepool 是怎么执行的。 NSMutableArray 怎么保证线程安全的。 GCD怎么避免block中的变量被提前释放 runloop实现原理 source 类型 线程保活的方式 runloop和多线程的关系，以及timer的关系 网络 浏览器输入url到网页显示经历了什么过程? TCP三次握手：具体是怎么握手？为什么要三次握手？两次行不行？为什么不行？三次握手，第二次和第三次分别因为什么? TCP是如何保持可靠传输的（拥塞控制，慢启动等等概念的理解） TCP为什么要四次挥手，TIME_WAIT为什么至少设置两倍的MSL时间？ TCP三次握手的详细数据传递，四次挥手详细数据内容，数据包组成、TIME_WAIT状态，2MSL，RTT，重传、滑动窗口、拥塞原理等等 TCP、UDP面向连接、无连接具体理解，他们的区别，如何将 UDP 改造成和 TCP 功能相似 TCP/IP四层协议，OSI七层协议，每层都有啥对应的协议，原理是啥 http报文结构，http中超文本超是啥意思，http请求的组成 http 报文头部含有什么，multipart了解吗 http的状态码，200，304，301，http请求报文，响应报文 get和post请求的区别？什么情况下用到？POST传输的数据都有哪些格式呢（这里需要搞定http各种请求传输的数据格式） 描述一次完整的http请求 什么是cookie，什么是session，区别联系，cookie的本质是什么 http1.0，1.1，2.0的区别 https有几次握手和挥手？https的原理。http有几次挥手和握手？TLS在哪一网络层，基本原理是什么？ https与中间人攻击 HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数 HTTPS是什么？握手过程，SSL原理，非对称加密了解多少 证书是干什么用的 弱网优化 Runtime 原理及应用 KVO 的底层原理，自己实现 KVC 的底层原理，自己实现 NSNotification 的底层原理，是同步还是一部，如何实现一个，如果在子线程接收一个通知能不能接收到 消息的动态转发 给 Category 添加属性，关联对象都有几种形式 method swizzling 怎么获取已上架app崩溃日志？ 怎么为系统类添加存储属性？ 说一说类的结构，运行时中的class都有什么属性，property都有什么属性 说一说isa指到NSObject的那个过程 Category的本质，load方法什么时候加载，Category重写了父类的方*怎样，底层源码 ，如果两个Category和一个基类，都有同名方法，先执行哪个 property会自动生成什么，如果此时已经有下划线_name的实例变量了那会生成什么 load 和 initialize 生命周期 app 的声生命周期 控制器的生命周期 视图的生命周期 OC 语言特性 OC 和 C 的区别， OC 和 Java、C++ 的区别 iOS 中的协议 OC 动态性 C 语言如何动态的交换两个方法的实现 常用功能集成 支付 支付宝 微信 银联 Apple Pay 地图 百度地图 高德地图 苹果地图 音频、视频 AVPlayer AVMediaPlayer 直播 点播 IM XMPP 融云 分享 友盟 崩溃收集 bugly 第三方库的源码 其他 一个 int 类型的值，被 @ 包装成 NSNumber 类型，传递到一个接受 id 类型的方法参数中，这个值能不能保持正确 在 iPad 上面，分屏功能，拖拽 wps 的文件到 qq 的过程是怎么实现的 (进程间通信的方法) 如何实现 dispatch_once Instrument 的使用 热修复用过吗，平时版本怎么迭代，线上 bug 怎么修复？ "},"知识库/笔记/iOS 知识点/项目/项目简介.html":{"url":"知识库/笔记/iOS 知识点/项目/项目简介.html","title":"项目","keywords":"","body":" 项目简介 项目组 项目文档 项目架构 分配任务 项目简介 项目组 移动开发组 (Android 和 iOS) 服务器(web)开发组 产品需求组 测试组 美工组 ... 项目文档 需求文档 接口文档 开发文档 产品文档 ... 项目架构 UI 界面层 业务类层 网络处理层 工具类层 ... 分配任务 按照功能和模块分 按照项目架构的层次分 ... "},"知识库/笔记/iOS 知识点/项目/项目部署.html":{"url":"知识库/笔记/iOS 知识点/项目/项目部署.html","title":"项目部署","keywords":"","body":" 项目部署 开源中国社区 官方网站 与 GitHUB 对比 使用 私钥秘钥的应用场景 网络间传递加密信息时 认证、确认身份时 项目部署 开源中国社区 官方网站 https://git.oschina.net 开源中国社区成立于2008年8月，其目的是为中国的IT技术人员提供一个全面的、快捷更新的用来检索开源软件以及交流使用开源经验的平台 目前国内很多公司将项目部署在OSChina 与 GitHUB 对比 服务器在国内，速度更快 免费账户同样可以建立 私有 项目，而 GitHUB 上建立私有项目要付费【已免费】 使用 注册账号 建议使用网易的邮箱，使用其他免费邮箱可能收不到验证码 添加 SSH 公钥 Public Key 私钥是系统随机生成的，公钥是由私钥计算得出的，钱包地址是由公钥计算得出的，也就是：私钥——公钥——钱包地址，这样一个过程； 数字签名，是由交易信息＋私钥信息计算得出的，因为数字签名隐含私钥信息，所以可以证明自己的身份 公钥负责加密，私钥负责解密 公钥全网公开，我用依依的公钥给信息加密，依依用自己的私钥可以解密 私钥负责签名，公钥负责验证 我给依依发信息，我加上我自己的私钥信息形成数字签名，依依用我的公钥来验证，验证成功就证明的确是我发送的信息。 SSHKey 示意图如下 开源中国帮助文档地址: https://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys 进入终端，并输入以下命令 # 生成 RSA 密钥对 # 1> \"\" 中输入个人邮箱 # 2> 提示输入存储密钥对的文件夹名称，直接回车 # 3> 提示输入密码，可以随便输入，只要本次能够记住即可 $ ssh-keygen -t rsa -C \"xxx@126.com\" # 查看公钥内容 $ cat ~/.ssh/id_rsa.pub 将公钥内容复制并粘贴到 https://git.oschina.net/profile/sshkeys 测试公钥 # 测试 SSH 连接 $ ssh -T git@git.oschina.net # 终端提示 `Welcome to Git@OSC，刀哥` 书名连接成功 新建项目 克隆项目 # 切换至项目目录 $ cd 项目目录[从finder拖拽] # 克隆项目，地址可以在项目首页复制 $ git clone git@git.oschina.net:xxx/ProjectName.git 添加 gitignore 1> 将 Swift.gitignore 复制到项目目录 2> 进入终端 # cd 项目目录目录[从finder拖拽] $ mv Swift.gitignore .gitignore 提示: 从 http://github.com/github/gitignore 获取最新版本的 gitignore 文件 添加 .gitignore 文件之后，每次提交时不会将个人的项目设置信息 (例如：上次代开的文件，调试断点等) 提交到服务器，在团队开发中非常重要 提示: 是否知道 .gitignore 是是否有团队开发经验的重要特征 私钥秘钥的应用场景 始终记得: 公钥可以随便给人，而私钥要保密 网络间传递加密信息时 【这个场景下公钥用来加密信息，私钥用来解密信息】 客户端生成密钥对AB，把公钥B给服务器 服务器生成密钥对CD，把公钥D给客户端 客户端给服务器发消息时用服务器给的公钥D加密，服务器收到后用自己的私钥C解密 服务器给客户端发消息时用客户端给的公钥B加密，客户端收到后用自己的私钥A解密 认证、确认身份时 【在这个场景下，私钥用来加密，公钥用来解密了】 数字签名、证书 客户端输入了一个网址给服务器发送了一个请求以后，确实拿到了服务器返回的公钥，但是这个服务器是不是冒充的它本意想访问的那个服务器是不确定的。 客户端要求服务器去一家双方都认可的权威的证书机构[如公安局]，公安局用自己的私钥将服务器的公钥加密生成一个数字证书，客户端给公安局打电话拿到了用来从数字证书中解密服务器公钥的公钥，这样当用户可以使用公安局给的公钥正常获得服务器的公钥时，就可以确定这个服务器是真正的服务器。 "},"知识库/笔记/iOS 知识点/项目/项目架构.html":{"url":"知识库/笔记/iOS 知识点/项目/项目架构.html","title":"项目架构","keywords":"","body":" 架构 项目架构的重要性 项目架构 项目架构中的技术点 代码加载根控制器 通过反射机制使用字典加载各分控制器 架构 项目架构的重要性 走向工作岗位之后，一般会遇到两种工作情况： 新项目开发 通常在项目开始之前，公司的产品经理会提供完整的产品原型图，或功能设计文档 通过对这些文档的解读，能够梳理出目标项目的整体架构，从而协助项目框架的搭建 旧项目维护 很多老项目是缺乏文档的，这种情况在一些小公司中表现尤为突出 要想快速上手一个老项目，首先运行项目，并且整理项目整体框架结构 然后用整理出的框架结构与代码结构相互印证，无疑可以对了解项目的整体架构起到重要的辅助 综上所述，无论是新项目，还是老项目，在开发之前确定项目的主题架构都是非常重要，也是十分必要的！ 项目架构 UI 界面层 业务类层 网络处理层 工具类层 ... 项目架构中的技术点 代码加载根控制器 实例应用 JL微博_SceneDelegate 通过反射机制使用字典加载各分控制器 实例应用 JL微博_JLMainViewController "},"知识库/笔记/iOS 知识点/项目/MVC 和 MVVM.html":{"url":"知识库/笔记/iOS 知识点/项目/MVC 和 MVVM.html","title":"MVC 和 MVVM","keywords":"","body":" MVVM MVC 回顾 MVVM MVVM 的优点 MVVM MVVM 是 Model-View-ViewModel 的简写，MVVM 和 MVC 一样，主要目的是分离视图 (View) 和模型 (Model) 用一个 viewModel 为整个视图中所有控件提供数据，控制器只负责刷新一下就行，大大减少了控制器中的代码 V 视图【View + Controller】 VM 视图模型【viewModel】 字典转模型 加载数据【调用 JLNetworkTool 方法】 下拉刷新 上拉刷新 M 数据模型【Model】 MVC 回顾 MVC 存在的问题 模型的代码很少 控制器的代码一不小心就越来越多 不好测试 MVVM MVVM 结构图 MVVM 概念 在 MVVM 中，view 和 view controller 正式联系在一起，我们把它们视为一个组件 view 和 view controller 都不能直接引用 model，而是引用视图模型 view model 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码 MVVM 使用事项 view 引用 view model ，但反过来不行 view model 引用了 model，但反过来不行 如果破坏了这些规则，便无法正确的使用 MVVM MVVM 的优点 低耦合: View 可以独立于 model 变化和修改，一个 ViewModel 可以绑定到不同的 View上 可重用性: 可以把一些试图逻辑放在一个 ViewModel 里，让很多 view 重用这段视图逻辑 独立开发: 开发人员可以专注于业务逻辑和数据开发 ViewModel，设计人员可以专注于页面设计 可测试: 通常界面是比较难于测试的，而 MVVM 模式可以针对 ViewModel 来进行测试 "},"知识库/笔记/iOS 知识点/UI/UI 界面 搭建.html":{"url":"知识库/笔记/iOS 知识点/UI/UI 界面 搭建.html","title":"UI","keywords":"","body":"UI 界面搭建 搭建方式 XIB Storyboard 纯代码 SwiftUI 如何选择 看界面的自定义程度，如果有许多自定义效果，定制程度比较高，就使用代码搭建。 如果界面是由普通的控件组成，则用storyboard。 XIB 搭建界面 加载视图控制器时，如果 XIB 和 视图控制器类重名，默认构造函数会优先加载 XIB 文件 XIB 中拖的是 View 不是 ViewController XIB 的创建 加载控制器 +(instancetype)viewControllerFromXib { return [[JLRecoverPwdViewController alloc] initWithNibName:@\"JLRecoverPwdViewController\" bundle:[NSBundle mainBundle]]; } 加载 View + (instancetype)rotationView { return [[NSBundle mainBundle] loadNibNamed:@\"JLTopImageRotationView\" owner:nil options:nil][0]; } - 当 XIB 中的 根视图是控制器的根视图时 > - 给此 XIB 设置 视图控制器类 > > 将 File's Owner 中的类设置为 XIB 的类 > > - 将 视图控制器类 的 根视图 view 设置为 XIB 的 view > > 在 File's Owner 上右键将 view 与 Xib 中的 view 连接 > > - 否则会报错 > > -[UIViewController _loadViewFromNibNamed:bundle:] loaded the \"JLComposeViewController\" nib but the view outlet was not set.' - 当 XIB 中的根视图 不是控制器的根视图则不需要设置 File Owner - 如果 Xib 文件对应的是 view， 不是 控制器，那么 fileOwner 不需要设置 - Xib 中的 collectionView 不像 Storyboard 中一样，不能添加 item，创建自定义 UICollectionViewCell - 如果 collectionView 的superView 是从 Xib 中加载的，设置 itemSize 和 superView 相关的话，要在 layoutSubviews 中设置，因为 awakeFromNib 中 superView 的 size 还是 xib 中的size - 创建 Cocoa Touch 类时，只有 Controller 的子类，可以直接自动创建 Xib，view 则不行 纯代码搭建界面 直接在控制器类中自己用代码创建View，创建各种控件添加到View中，并设置frame、自动布局等 "},"知识库/笔记/iOS 知识点/UI/UI 界面间 传值.html":{"url":"知识库/笔记/iOS 知识点/UI/UI 界面间 传值.html","title":"UI 界面间 传值","keywords":"","body":"UI 界面间 传值 如果要传的值有2个以上，封装数据模型传送 传值方式 顺传值 Storyboard 拖线的话，prepareForSegue 手动 push 或 present 的话，在当时传 逆传值 代理模式 一对一，代理只能设置一次，如多次设置，只最后一次设置的起作用 block / closure 实例：私人通讯录_新建修改 通知 一对多 AddTarget "},"知识库/笔记/iOS 知识点/UI/UI 界面间 跳转.html":{"url":"知识库/笔记/iOS 知识点/UI/UI 界面间 跳转.html","title":"UI 界面间 跳转","keywords":"","body":"UI 界面间[控制器间]跳转的方式[转场] 跳转方式 控制器间拖线1：自动型segue 控制器间拖线2：手动型segue 纯代码：使用navigationController的push方法 Modal present 如何选择 如果两个控制器有业务关系用push，否则用modal push需要外包一个navigationController，modal不需要 Modal是谁负责跳转谁负责关闭 在storyboard中，连接两个控制器时依然选show，如果有导航控制器，系统会进行push跳转，即从右往左过来，否则会modal跳转，即从下往上出来。 Storyboard 控制器间拖线1：自动型segue 使用场景： 不需要做任何逻辑条件判断，一点就跳转 步骤： 从A控制器要跳转的控件拖线到B控制器 Storyboard 控制器间拖线2：手动型segue 使用场景： 点击后需要进行一些逻辑判断才能确定要不要跳转 步骤： 从A控制器上面控制器图标拖线到B控制器 给此线(segue)添加identifier 在A控制器的类文件中合适的地方调用performSegueWithIdentifier进行跳转 注意： 只要是在storyboard拖线进行的跳转，无论手动还是自动型，都会调用 prepareForSegue 这个方法，所以可以在这里做传值、设置代理等方法。(纯代码方式不调用) 纯代码: navigationController的push // 显示 let vc = JLDemoViewController() navigationController?.pushViewController(vc, animated: true) // 退出 popViewController(animated: true) 纯代码: Modal present // 显示 let vc = JLOAuthViewController() let nav = UINavigationController(rootViewController: vc) self.present(nav, animated: true, completion: nil) // 退出 dismiss(animated: true, completion: nil) "},"知识库/笔记/iOS 知识点/UI/自动布局.html":{"url":"知识库/笔记/iOS 知识点/UI/自动布局.html","title":"自动布局","keywords":"","body":"自动布局 autoResizing 和 autolayout 不能共存，用纯代码写默认是 autoresizing，用 xib 默认是 autolayout 实例应用 UI基础10 _JL微博_JLVisitorView UI基础_Day09自动布局 autoresizing【纯代码】 translatesAutoresizingMaskIntoConstraints 此属性如果设置为 true ​ 自动将它的 autresizing mask 转换为相应的约束 ​ 可以修改 frame、bounds、center 等属性来静态控制控件的位置 ​ 而 autresizing mask 完全设定了视图的位置和尺寸，所以不能再添加其它额外的约束 ​ 如果需要“自动布局”来动态计算控件的位置和尺寸，则需要将此属性设置为false，并且为此控件添加一个不冲突的约束 ​ 如果用纯代码创建控件，则此属性被系统自动设置为 true ​ 如果在 Interface Builder 中创建控件，则此属性被系统自动设置为 false If this property’s value is true, the system creates a set of constraints that duplicate the behavior specified by the view’s autoresizing mask. This also lets you modify the view’s size and location using the view’s frame, bounds, or center properties, allowing you to create a static, frame-based layout within Auto Layout. Note that the autoresizing mask constraints fully specify the view’s size and position; therefore, you cannot add additional constraints to modify this size or position without introducing conflicts. If you want to use Auto Layout to dynamically calculate the size and position of your view, you must set this property to false, and then provide a non ambiguous, nonconflicting set of constraints for the view. By default, the property is set to true for any view you programmatically create. If you add views in Interface Builder, the system automatically sets this property to false. autolayout【XIB、Storyboard】 SizeClasses 纯代码自动布局 // 自动布局 - 设置 xib 控件的自动布局，需要指定宽高约束 // 禁用 autoResizing (因为会以 autolayout 冲突) refreshView.translatesAutoresizingMaskIntoConstraints = false // 设置 中心点 X 约束 addConstraint(NSLayoutConstraint(item: refreshView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0)) // 设置宽度约束 refreshView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: refreshView.bounds.width)) Snapkit Xib 和 Storyboard 中的控件自动布局 (动态高度) Frame 中 x, y, height, width (autoResizing) 和 autoLayout 中 leading, top, trailing, bottom 是两个系统的 需要动态高度的控件，比如微博正文的 Label，使用内建默认高度，将 leading, top, trailing 设好就行，将父容器的 bottom 设置始终 >= label bottom，也可加 constant 来设定间距 上面的做法，对于 UIView 还需要先设置一个高度，因为没有内建的默认高度，而且，label 只要设置了多行(0)，会随着文字增多而撑开，但是 UIView 貌似不行，所以需要把它的 height Constraint 连线到 code中，用 code 动态改变来达到动态高度的效果 "},"知识库/笔记/iOS 知识点/UI/苹果原生代码自动布局.html":{"url":"知识库/笔记/iOS 知识点/UI/苹果原生代码自动布局.html","title":"苹果原生代码自动布局","keywords":"","body":"苹果原生代码自动布局 自动布局核心公式 view.attr1 = view2.attr2 * multiplier + constant 自动布局构造函数 NSLayoutConstraint(item: iconView, 视图 attribute: .centerY, 约束属性 relatedBy: .equal, 约束关系 toItem: **self**, 参照视图 attribute: .centerY, 参照属性 multiplier: 1.0, 乘积 constant: -60) 约束数值 如果指定 宽 高 约束 参照视图设置为 nil 参照属性选择 .notAnAttribute 自动布局类函数 NSLayoutConstraint.constraints(withVisualFormat: , VFL公式 options: [], metrics: , 约束数值字典 [String:数值] views: ) 视图字典 [String:子视图] VFL 可视化格式语言 H 水平方向 V 垂直方向 | 边界 () 包含控件的名称字符串，对应关系在 views 字典中定义 () 定义控件的宽/高，可以在 metrics 中指定 提示: VFL 通常用于连续参照关系，如果遇到居中对齐，通常直接使用参照 // 6> 遮罩图像 let dict = [\"maskIconView\":maskIconView, \"registerButton\":registerButton] let metrics = [\"spacing\":-60] addConstraints(NSLayoutConstraint.constraints( withVisualFormat: \"H:|-0-[maskIconView]-0-|\", options: [], metrics: nil, views: dict)) addConstraints(NSLayoutConstraint.constraints( withVisualFormat: \"V:|-0-[maskIconView]-spacing-[registerButton]\", options: [], metrics: metrics, views: dict)) "},"知识库/笔记/iOS 知识点/UI/UIScrollView中子控件的布局.html":{"url":"知识库/笔记/iOS 知识点/UI/UIScrollView中子控件的布局.html","title":"UIScrollView中子控件的布局","keywords":"","body":"ScrollView 中 子控件的布局 设置 有导航控制器时, scrollView 不自动调整自己的原点 self.edgesForExtendedLayout = UIRectEdgeNone; self.automaticallyAdjustsScrollViewInsets = YES; 使用 containerView 如果只有一个子视图, 且scrollView高度由子视图确定的话. // MARK: - 布局子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局 scrollView [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 布局 容器视图 [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // 已保证scrollView 的contentSize 随着 containerView 的size 变化, 但是 container的高度未确定 }]; // 布局 imgView [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.leading.top.trailing.mas_equalTo(0); }]; // 最后, 通过设置 container 的底部与最后一个子控件图片框的底部相同, 从而设置了 container 的高度与图片相同, 从而使得 scrollView 的高度与 图片相同 [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.imgView.mas_bottom); }]; } 如果有多个子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局子控件 // 设置scrollView约束 [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 设置参照视图的约束 [self.contentView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // make.height.greaterThanOrEqualTo(@0.0f); }]; // 第一个测试view的约束 [self.oneView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.contentView).offset(30); make.left.equalTo(self.contentView); make.width.mas_equalTo(200); make.height.mas_equalTo(300); }]; // 第二个测试view的约束 [self.twoView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.oneView.mas_bottom).offset(50); make.right.equalTo(self.contentView); make.width.mas_equalTo(400); make.height.mas_equalTo(500); }]; // 第三个测试view的约束 [self.threeView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.twoView.mas_bottom).offset(70); make.left.right.equalTo(self.contentView); make.height.mas_equalTo(300); }]; // 最后设置最后一个view的与参照容器view的约束 [self.contentView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.threeView.mas_bottom).offset(-10); }]; } 不使用 containerView 如果只有一个子视图, 且scrollView高度由子视图确定的话. Edges都为0, 只是说明它的大小会随着父控件变化, 并不意味着它的 contentSize 就确定了, 只有父控件的大小确定了才行 将 scrollView 的edges 都equal to 它的父控件, 或者要显示的大小. 布局 scrollView 的子控件, 如果是动态高度的话, 只先布局它除去高度外的约束 最后, 设置 scrollView 的 bottom 与最后一个子控件的bottom 相等, 相当于确定了 scrollView 的高度 // MARK: - 布局子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局 scrollView [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 布局 imgView [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // 已保证scrollView 的contentSize 随着 imgView 的size 变化, 但是 scrollView contentSize的高度仍未确定 }]; // 最后, 通过设置 scrollView 的底部与最后一个子控件imgView的底部相同,从而使得 scrollView 的高度与 图片相同 [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.imgView.mas_bottom); }]; } "},"知识库/笔记/iOS 知识点/数据读取解析存储/数据读取、解析.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/数据读取、解析.html","title":"数据读取解析存储","keywords":"","body":" 数据读取、解析 基本数据类型的读取和存储 读取 存储 对象的存储和读取 归解档 [旧OC] 归解档[新 Swift] 注意： 数据读取、解析 基本数据类型的读取和存储 读取 文件位置 -> 数组 、字典、字符串 到数组 [NSArray arrayWithContentsOfURL:] [NSArray arrayWithContentsOfFile:] 到字典 [NSDictionary dictionaryWithContentsOfURL:] [NSDictionary dictionaryWithContentsOfFile: ] 到 字符串 [[NSString alloc] initWithData] 文件位置 -> data -> 数组、字典 文件位置 -> data [NSData dataWithContentsOfURL] [NSData dataWithContentsOfFile] data -> 数组 或 字典 json data 解析成 JSONObject, 即 数组 或 字典 NSArray *array = [NSJSONSerialization JSONObjectWithData: data]; NSDictionary *dict = [NSJSONSerialization JSONObjectWithData: data]; pList data 解析成 数组 或 字典 NSArray *array = [NSPropertyListSerialization propertyListWithData: data] NSDictionary *dict = [NSPropertyListSerialization propertyListWithData: data] 存储 直接写入文件 字典 写到 文件 [dict writeToURL]; [dict writeToFile]; 数组 写到 文件 [arr writeToURL]; [arr writeToFile]; 转为 data 后再 写入文件 注: 不管是 基本数据类型 还是 对象 ，都要先存到 字典 或 数组 中，最后再写入文件存到某个位置 转为 json data 字典[基本数据类型] NSData *data = [NSJSONSerialization dataWithJSONObject: dict]; 数组[基本类型数据] NSData *data = [NSJSONSerialization dataWithJSONObject: arr]; 转为 pList data NSData *data = [NSPropertyListSerialization dataWithPropertyList: dict] NSData *data = [NSPropertyListSerialization dataWithPropertyList: arr] 字符串 转为 data NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding] 将 data 写到文件 [data writeToURL]; [data writeToFile]; 对象的存储和读取 注: 不管是 基本数据类型 还是 对象 ，都要先存到 字典 或 数组 中，最后再写入文件存到某个位置 原理: 先将 自定义对象 转为 数据字典，再进行后续操作 归解档 [旧OC] 自定义对象类遵守 NSCoding 协议，实现两个可以将 对象 和 字典 互转的归解档方法，再用 NSKeyedArchiver 来和 data 互转 存储 【对象 -> data】 使对象类遵守NSCoding协议，实现如下将对象转化为数据字典 aCoder 的方法， encodeWithCoder:(NSCoder*)aCoder 直接归档写入文件并存储到位置 [NSKeyedArchiver archiveRootObject: toFile:] 或 自定义对象 -> data -> 写到文件并存储 将 自定义对象 或 自定义对象数组 归档 为 data NSData *data = [NSKeyedArchiver archivedDataWithRootObject:arr] 将 data 写入文件存储到相应位置 [data writeToURL]; [data writeToFile]; 读取 【data -> 对象】 使对象类遵守NSCoding协议，实现如下将数据字典aDecoder 转为 对象 的方法 initWithCoder:(NSCoder *)aDecoder 直接从存储位置解档成 元素为自定义对象的 数组或字典 NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithFile:] 或 存储位置 -> data -> 自定义对象数组或字典 用 存储位置 创建 data NSData data = [NSData dataWithContentsOfURL]; NSData data = [NSData dataWithContentsOfFile]; 用 data 解档生成 元素为自定义对象的 数组或字典 NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:data]; 归解档[新 Swift] 原理和 OC 旧方法一样，只不过协议换成了 Codable，一般情况下只要层层遵守Codable协议就可以成功归档解档了，如果不行，或者需要自定义归解档的属性，就实现下面两个方法。 类对象只要可以归解档了，也就可以用 JSONEncoder 和 JSONDecoder 操作了？ /// 此 对象 对应的 数据字典 的 `键` enum CodingKeys:String, CodingKey { case word case chinesesString = \"chineses\" case meaningsArray = \"meanings\" case dateCreated = \"creation_date\" case dateModified = \"modification_date\" case frequency } /// 解档方法 /// 将 数据字典 解档为 自定义对象 /// - Parameter decoder: 数据字典 required init(from decoder: Decoder) throws { super.init() let values = try decoder.container(keyedBy: CodingKeys.self) word = try values.decode(String.self, forKey: .word) meaningsArray = try values.decode([Meaning].self, forKey: .meaningsArray) dateCreated = try values.decode(Date.self, forKey: .dateCreated) dateModified = try values.decode(Date.self, forKey: .dateModified) frequency = try values.decode(Int.self, forKey: .frequency) } /// 归档方法 /// 将 自定义对象 归档为 数据字典 /// - Parameter encoder: 数据字典 func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(word, forKey: .word) try container.encode(chinesesString, forKey: .chinesesString) try container.encode(meaningsArray, forKey: .meaningsArray) try container.encode(dateCreated, forKey: .dateCreated) try container.encode(dateModified, forKey: .dateModified) try container.encode(frequency, forKey: .frequency) } 注意： [String : Any] 或 [Any]， 在将包含 Any 类型的数组或字典使用JSONEncoder转换为 JSON 二进制 Data 时，会报错，可使用如下方法： let data = try? JSONSerialization.data(withJSONObject: arr, options: [.prettyPrinted]) let url = URL.init(fileURLWithPath: \"/Users/joyawang/Desktop/demo.json\") try? data?.write(to: url) 如果数据是自定义对象(数据模型)，将对象转换为键值对为基本数据类型的字典，再将字典存入数组中 原理： 对象 -> 字典 -> 数组[字典] -> Data obj -> dict = [obj dictionaryWithValuesForKeys] -> [dict] -> Data "},"知识库/笔记/iOS 知识点/数据读取解析存储/数据存储.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/数据存储.html","title":"数据存储","keywords":"","body":" 数据存储: 将二进制数据Data存储到不同的位置 本地存储 网络存储 数据存储: 将二进制数据Data存储到不同的位置 可存储的位置介绍 存到本地磁盘 存储在本机磁盘的一个特定目录下，Sandbox 沙盒 (可在 Files 文件 App 中本机显示) 存到系统提供的用来存储用户偏好的文件，UserDefaults 用户偏好 存到 钥匙串，用 第三方框架 SAMKeyChain 存到自己生成的二进制数据文件，再写入到沙盒的 document 目录 存到本地数据库文件(本质是生成数据库文件，算法进行管理)，再存到沙盒的 document 目录 FMDB (SQLite) CoreData 【SkillKit】 Realm Firebase 存到网络服务器磁盘 iCloud 本地存储 沙盒目录简介及获取方法 Documents 简介 保存应用产生的文件或数据，如游戏进度、涂鸦软件的绘图 目录中的文件会自动保存到iCloud上？ 不哟啊保存从网络上下载的文件 iTunes会备份 路径获取方法 // OC NSHomeDirectory NSString *document = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; // Swift let docURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) Library / Cache 简介 保存临时文件，后续需要使用。如缓存图片、离线地图数据 系统不会自动清理此目录？ 程序员需提供清理此目录的功能？ iTunes不会备份 路径获取 - (instancetype)cachePath { // 获取当前path中文件的名字 NSString *fileName = [self lastPathComponent]; // 获取沙盒中document文件夹的路径 NSString *cache = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 拼接成当前文件在沙盒cache文件夹的路径 return [cache stringByAppendingPathComponent:fileName]; } Library / Preference 简介 用户偏好，存储用户的一些偏好操作 iTunes会备份 路径获取 UserDefaults ??? 存: [[NSUserDefaults standardUserDefaults] setValue: forKey:]; 取: [[NSUserDefaults standardUserDefaults] valueForKey:]; temp 简介 保存临时文件，后续不需要使用 tmp目录中的文件，系统会自动清理 系统磁盘空间不足，会自动清理 系统重启，会清理该文件 iTunes不备份 路径获取 // OC - (instancetype)tempPath { return [NSTemporaryDirectory() stringByAppendingPathComponent:[self lastPathComponent]]; } 沙盒文件在 Files App 中本机显示 如果往本地SandBox的Documents存了文件，但是在Files中不显示，不可见，那么在info.plist中添加如下两个key UIFileSharingEnabled LSSupportsOpeningDocumentsInPlace 网络存储 iCloud 目录获取 须判断，为空则没有登录苹果账户或没打开iCloud // iCloud入口文件夹URL FileManager.default.url(forUbiquityContainerIdentifier: nil) // iCloud中Documents文件夹URL: FileManager.default.url(forUbiquityContainerIdentifier: nil)?.appendingPathComponent(\"Documents\") 在 Files 文件 App 中 iCloud 显示 如果往iCloud的Documents存了文件，但是在Files中不显示，不可见，那么在info.plist中添加如下key NSUbiquitousContainers ​ iCloud.com.Joya-Wang.VocKit ​ ​ NSUbiquitousContainerIsDocumentScopePublic ​ ​ NSUbiquitousContainerName ​ VocKit ​ NSUbiquitousContainerSupportedFolderLevels ​ Any ​ 如果添加了上面的key后在Files中依然无法看见自己的app文件夹，改变下面的CFBundleVersion也就是内建版本号buildVersionNumber。（CFBundleShortVersionString是发布版本号releaseVersionNumber) CFBundleVersion ​ 1 CloudKit Container CloudKit 开启 default container: 以当前项目 bundle id 命名 四级目录 Container【VocKit Container】 Database 【PrivateDatabase】 Private 属于当前手机icloud账户的DB，该账户登录期间，数据提交到该DB里，且只有在该账户登录时，才能取到相关记录。切换icloud账户将无法获取到。 Shared 所有人都可以访问，但只限于同bundleID的 app。（由于container 的bundle ID限制） Public IOS10新推出的，用 CKShare 创建的记录，设定一定的权限 即可被遵守相同规则的 app访问到。 Zones 【Vocabularies】【Meanings】 Records 【Vocabulary】【Meaning】 使用 //获取container，可以用ID来指定 自定义的container，也可以使用默认的。 CKContainer *myContainer = [CKContainer defaultContainer]; //获取container里的 db。这里用的是public DB CKDatabase *publicDatabase = [myContainer publicCloudDatabase]; //recordID， name必须在这个DB里是唯一的。 CKRecordID *artworkRecordID = [[CKRecordID alloc] initWithRecordName:@\"119\"]; //创建一条新的record。recordType 类似于DB的表名。 CKRecord *artworkRecord = [[CKRecord alloc] initWithRecordType:@\"Artwork\" recordID:artworkRecordID]; //record的 这种key-value 存储方式；value支持的数据类型参考 CKRecord.h 的CKRecordValue协议 artworkRecord[@\"name\"] = @\"testName\"; //新建/更改记录 CKModifyRecordsOperation *modifyRecords= [[CKModifyRecordsOperation alloc] initWithRecordsToSave:@[artworkRecord] recordIDsToDelete:nil]; modifyRecords.savePolicy=CKRecordSaveAllKeys; modifyRecords.qualityOfService=NSQualityOfServiceUserInitiated; modifyRecords.modifyRecordsCompletionBlock= ^(NSArray * savedRecords, NSArray * deletedRecordIDs, NSError * operationError){ // the completion block code here NSLog(@\"\"); }; //获取记录 [publicDatabase fetchRecordWithID:artworkRecordID completionHandler:^(CKRecord * _Nullable record, NSError * _Nullable error) { NSLog(@\"\"); }]; "},"知识库/笔记/iOS 知识点/数据读取解析存储/NSFileManager 文件管理器.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/NSFileManager 文件管理器.html","title":"NSFileManager 文件管理器","keywords":"","body":"NSFileManager 文件管理器 【像Finder一样管理文件】 初始化 [NSFileManager defaultManager] 判断 判断指定文件或文件夹是否存在 fileExistsAtPath 判断指定文件夹是否可读取 isReadableFileAtPath 判断指定文件夹或文件是否可写入 isWriteableFileAtPath 判断指定文件夹或文件是否可删除 isDeleteableFileAtPath 获取信息 获取指定文件夹或文件的属性信息 attributesOfItemAtPath 获取指定路径下的所有文件和目录，所有子目录和文件 subpathsAtPath 获取指定路径的所有子目录和文件，不包括孙子辈 contentsOfDirectoryAtPath 文件 / 文件夹操作 在指定目录创建文件 createFileAtPath 在指定目录创建文件夹 createDirectoryAtPath 拷贝文件 copyItemAtPath toPath 移动文件(剪切文件，可用来重命名) moveItemAtPath toPath 删除文件(不倒废纸篓，直接删除，谨慎使用) removeItemAtPath "},"知识库/笔记/iOS 知识点/数据读取解析存储/CoreData_SQLite.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/CoreData_SQLite.html","title":"CoreData_SQLite","keywords":"","body":" CoreData 创建数据库和数据表 数据操作 CoreData SQLite 概念简介 表 一张表 table 用来存储一类对象，表的 column / 字段 / 属性 就是对象的属性 Person 表就存储 Person 类的所有对象 Teacher 表就存储所有 Teacher 类的对象 db 一个数据库 database，可存很多不同的表，即可以存储不同类的对象 Person 表和 Teacher 表 都存在 froshims.db 数据库中 CoreData 简介 存储数据，也就是要把一个个 OC 对象，比如 Student 对象，存储到数据库中 那么需要在数据库中创建一个存储这个对象类型的表，在 FMDB 中，通过语句创建，而在 CoreData 中，通过视图界面创建 Entity，每个 Entity 对应一张表，Entity 的 attributes 对应对象的属性。 创建了一个 Entity，如 Teacher以后，默认创建了这样一个 OC 类，虽然看不见，但你可以直接使用 Teacher 这个类创建对象，也可以在 Entity 的 Codegen 里面更改，将 Entity 的属性以 Extension 的形式添加给你自己后面手动创建的 Teacher 类。 CoreData 不能执行 SQL 语句，取而代之，操作的是对象，FMDB SQLite 可以直接 SQL 语句 Core Data iOS5之后才出现的一个框架 如果创建项目时选择 Use Core Data add some code to AppDelegate Create a .xcdatamodeld file 【Data Model】就像 数据库的 Storyboard Entities (which are like a class) Attributes (which is like a var) Relationships (a var that points to other Entities) 创建数据库和数据表 【创建数据库】 在创建项目的时候选择使用 CoreData，就会在 App Delegate 中创建 Container，也就是数据库，也可以自己参照这个代码创建 【创建数据表】打开 .xcdatamodeld 文件 增加 Entity 创建 Entity，也就是创建要在数据库中存储的 类，比如 Tweet 比如 Tweet、TweetUser 为 Entity，添加 attributes，也就是为 类 添加 属性/字段 比如，为 Tweet Entity 添加如下属性 created Date类型 identifier String 类型 text String类型 创建 relationShip 在此 Entity 的 Codegen 的地方选择要自动生成和此 Entity 对应的 OC 类，比如 Tweet，或者生成那个类的 Extension 如果选择了自动生成对应的 Tweet 类，则无法再手动创建 Tweet 类并方便的添加方法，所以建议自动生成 Tweet 的 Extension，Tweet 类自己手动创建 不管这两个选择哪一个，最后在创建对象的时候 Tweet 对象就自动拥有了 entity 中设置的属性 数据操作 获取 NSPersistentContainer 和 viewContext let persistentContainer = (UIApplication.shared.delegate as! AppDelegate).persistentContainer let context:NSManagedObjectContext = persistentContainer.viewContext 数据库操作 增 // 最基本的存储一条数据到 Coredata 的方式 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 创建 Entity // 必须先创建 Tweet 类，继承自 NSManagedObject，可在 Entity 那里用 Codegen 生成 // 通过实体描述，描述出实体对象【连接Coredata的 Tweet Entity 和 Swift 的 Tweet 类？】 let tweet:Tweet = NSEntityDescription.insertNewObject(forEntityName: \"Tweet\", into: context) tweet.text = \"我的第一条推文\" // 设置对象属性 // 3. 保存Entity到数据库【上面的更改只在内存中，除非保存起来】 try? context.save() ```swift // ** 方便的存储一条数据到 Coredata 的方式 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 创建 Entity，并设置属性 let tweet = Tweet(context: context) tweet.text = \"我的第一条推文\" tweet.date = Date() // 3. 保存 Entity 到数据库 try? context.save() ``` 删 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 删除 context.delete(tweet) 改 查 // 1. 创建 request 【获取哪类对象】 let request:NSFetchRequest = Tweet.fetchRequest() // 2.设置 request 的条件【可省略?】 // 2.1 设置查询条件 let searchString = \"foo\" let predicate = NSPredicate(format: \"text contains[c] %@\", searchString) // 2.2 设置结果排序方式 let sortDescriptor = NSSortDescriptor( key:\"screenName\", ascending: true, // 根据 screenName，升序 selector: #selector(NSString.localizedStandardCompare(_:)) // can skip this ) // 2.3 将条件设置给 request request.predicate = predicate request.sortDescriptors = [sortDescriptor] // 3. 获取结果 let thetweets = try? context.fetch(request) "},"知识库/笔记/iOS 知识点/数据读取解析存储/FMDB_SQLite.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/FMDB_SQLite.html","title":"FMDB_SQLite","keywords":"","body":" FMDB SQLite 使用方法 FMDB SQLite 详见 JL微博、数据存储-FMDB SQLite 概念简介 表 一张表 table 用来存储一类对象，表的 column / 字段 / 属性 就是对象的属性 Person 表就存储 Person 类的所有对象 Teacher 表就存储所有 Teacher 类的对象 db 一个数据库 database，可存很多不同的表，即可以存储不同类的对象 Person 表和 Teacher 表 都存在 froshims.db 数据库中 FMDB 和 CoreData 异同 存储数据，也就是要把一个个 OC 对象，比如 Student 对象，存储到数据库中 那么需要在数据库中创建一个存储这个对象类型的表，在 FMDB 中，通过语句创建，而在 CoreData 中，通过视图界面创建 Entity，每个 Entity 对应一张表，Entity 的 attributes 对应对象的属性。 创建了一个 Entity，如 Teacher以后，默认创建了这样一个 OC 类，虽然看不见，但你可以直接使用 Teacher 这个类创建对象，也可以在 Entity 的 Codegen 里面更改，将 Entity 的属性以 Extension 的形式添加给你自己后面手动创建的 Teacher 类。 CoreData 不能执行 SQL 语句，取而代之，操作的是对象，FMDB SQLite 可以直接 SQL 语句 简介 什么是FMDB？ 一个iOS中SQLite API的封装库 1.是对libsqlite3库的封装，使用起来简洁、高效，没有原来的一大堆晦涩难懂、影响开发效率的C语句，更加面向对象 2.非常的轻量化、灵活 3.对于多线程的并发操作进行了处理，是线程安全的（重要特性之一） 4.因为它是OC语言封装的，只能在ios开发的时候使用，所以在实现跨平台操作的时候存在局限性 iOS FMDB数据库详解教程 FMDB Github地址 大写只是为了区分代码命令和用户信息 iOS 中 ? 代表预编译指令的占位符 安装和导入 安装 cd到项目目录 pod init vim Podfile并添加pod 'FMDB' pod install 导入libsqlite3框架 import 使用方法 创建数据库 创建 froshims.db 数据库 终端 sqlite3 froshims.db 数据库文件默认存储位置为当前用户的家目录 // MARK: 创建数据库 /// 创建数据库 - (void) createDatabase { // 1. 获取数据库文件的路径 _docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@\"%@\", _docPath); // 设置数据库名称 NSString *filename = [_docPath stringByAppendingPathComponent:@\"student.sqlite\"]; // 2. 创建数据库 _db = [FMDatabase databaseWithPath:filename]; if ([_db open]) { NSLog(@\"打开数据库成功\"); } else { NSLog(@\"打开数据库失败\"); } } 创建数据表 创建一个名为 registrants，3 个 column (列)，分别为 id，name，dorm 的数据表 终端 CREATE TABLE 'registrants' ('id' integer, 'name' varchar(255), 'dorm' varchar(255)); // MARK: 创建表 /// 创建表 - (void) createTable { BOOL result = [_db executeUpdate:@\"CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);\"]; if (result) { NSLog(@\"创建表成功\"); } else { NSLog(@\"创建表失败\"); } } 【增】新增数据 向 registrants 表添加一条数据， id, name, dorm column 中的值分别填1, 'Brian', 'Pennypacker' 终端 INSERT INTO registrants (id, name, dorm) VALUES(1, 'Brian', 'Pennypacker'); // MARK: - 增 // 插入数据 - (void) addStudent { // 插入数据 NSString *name = [NSString stringWithFormat:@\"王子涵%@\", @(mark_student)]; int age = mark_student; NSString *sex = @\"男\"; mark_student ++; // 1. executaUpdate: ?为占位符 (后面参数必须是OC对象，; 代表语句结束) BOOL result = [_db executeUpdate:@\"INSERT INTO t_student (name, age, sex) VALUES (?,?,?)\", name, @(age), sex]; //2.executeUpdateWithForamat：不确定的参数用%@，%d等来占位 （参数为原始数据类型，执行语句不区分大小写） // BOOL result = [_db executeUpdateWithFormat:@\"insert into t_student (name,age, sex) values (%@,%i,%@)\",name,age,sex]; //3.参数是数组的使用方式 // BOOL result = [_db executeUpdate:@\"INSERT INTO t_student(name,age,sex) VALUES (?,?,?);\" withArgumentsInArray:@[name,@(age),sex]]; if (result) { NSLog(@\"插入成功\"); } else { NSLog(@\"插入失败\"); } } 【删】删除数据 删除 id 为 1 的那一行数据 终端 DELETE FROM registrants WHERE id = 1; // 删除数据 - (void)deleteStudent { // 1. 占位符用? (后面参数必须是OC对象)，需要将int包装成OC对象) int idNum = 11; // BOOL result = [_db executeUpdate:@\"delete from t_student where id = ?\", @(idNum)]; // 占位符用%@，%d等 BOOL result = [_db executeUpdateWithFormat:@\"delete from t_student where name = %@\", @\"王子涵0\"]; if (result) { NSLog(@\"删除成功\"); } else { NSLog(@\"删除失败\"); } } // 删除表 - (void) deleteTable { // 如果表格存在 则销毁 BOOL result = [_db executeUpdate:@\"drop table if exists t_student\"]; if (result) { NSLog(@\"删除表成功\"); } else { NSLog(@\"删除表失败\"); } } 【改】修改 / 更新 数据 更新 registrants 表，将 id 为 1 的那一行的 dorm 改为 Canaday 终端 UPDATE registrants SET dorm = 'Canaday' WHERE id = 1; // MARK: - 改 // 修改数据 - (void) modifyStudent { // 修改学生名字 NSString *newname = @\"李浩宇\"; NSString *oldname = @\"王子涵2\"; BOOL result = [_db executeUpdateWithFormat:@\"update t_student set name = %@ where name = %@\", newname, oldname]; if (result) { NSLog(@\"修改成功\"); } else { NSLog(@\"修改失败\"); } } 【查】读取数据 读取所有数据 选择显示 registrants 这个表中的所有数据 终端 SELECT * FROM registrants; 按条件读取数据 选择显示 registrants 这个表中 dorm 是 China 的所有数据 SELECT * FROM registrants WHERE dorm = 'China'; 选择显示 registrants 这个表中 dorm 为 Africa 的所有数据的 name SELECT name FROM registrants WHERE dorm = 'Africa'; // MARK: - 查 // 查询 - (void) search { // 查询整个表 // FMResultSet *resultSet = [_db executeQuery:@\"select * from t_student\"]; // 根据条件查询 FMResultSet *resultSet = [_db executeQuery:@\"select * from t_student where id "},"知识库/笔记/iOS 知识点/数据读取解析存储/XML 的 存储 和 解析.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/XML 的 存储 和 解析.html","title":"XML 的 存储 和 解析","keywords":"","body":"XML 的 存储 和 解析 数据数组和字典与 XML Data互转 SAX的方式解析: 简介 SAX: simple API for XML 特点: iOS上解析，速度快，内存占用小，只读 SAX的解析步骤:【具体见网络通信的Day02】 加载xml数据【获取网络中的xml data】 创建NSXMLParser对象parser 设置parser的delegate 在NSXMLParserDelegate协议方法中解析XML data a. 开始解析XML文档【didStartDocument】 b. 找开始节点(包括节点的属性)【didStartElement】 c. 找节点之间的内容【foundCharacters】 d. 找结束节点【didEndElement】 e. 完成XML文档解析【parserDidEndDocument】 注意 使用KVC为对象属性赋值注意: KVC赋值的过程就是将value的地址赋值给key，即对象的属性指针指向value，所以在从网络中获取数据转模型时，模型类的属性最好设置为copy，这样在赋值的时候会复制一份value，把新value的地址赋值给key。在setValue过程中不会做类型转换，直接把value地址赋值给属性指针。这也是为什么NSNumber类型的属性，用string类型的value也可以赋值的原因。 DOM 的方式解析 简介 DOM : Document Object Model 文档对象模型(文档树模型) 把整个xml文件当成文档对象来处理，所有信息都在这个文档对象中。 特点: mac上的解析方式，iOS无法直接使用，解析过程中内存占用大，读写 一次性把xml全部加载到内存，内存消耗大 之前的SAX方式只能读取XML，DOM可以修改，添加、删除、修改节点 iOS默认不支持DOM解析(不支持NSXML这个类) 在iOS解析DOM需要使用第三方框架 GData/KissXML(XMPP中使用此框架) 适合读写比较小的XML文件 GData 解析的步骤【详见网络通信Day03，DOM解析】 将GDataXMLNode.h和m拖进项目 在build setting中搜索'Header Search Paths'，添加/usr/include/libxml2 在build setting中搜索'Other Linker Flags'，添加-lxml2 获取xml data 使用data创建document(GDataXMLDocument)对象 获取根元素(节点)document.rootElement rootElement的所有children就是一个个video对象，遍历并video对象 rootElement每个child是一个video对象，child的children是video的子标签(就是video的属性)，使用KVC赋值 rootElement每个child是一个video对象，child的attributes是video的属性(就是video的属性)，使用KVC赋值 "},"知识库/笔记/iOS 知识点/数据读取解析存储/NSCache 缓存.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/NSCache 缓存.html","title":"NSCache 缓存","keywords":"","body":"NSCache 缓存 - (NSCache *)cache { if(!_cache) { _cache = [[NSCache alloc] init]; _cache.countLimit = 5; _cache.delegate = self; } return _cache; } - (void)cache:(NSCache *)cache willEvictObject:(id)obj { NSLog(@\"从缓存中移除%@\", obj); } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 往缓存中存储数据 for (int i = 1; i "},"知识库/笔记/iOS 知识点/内存/内存中的五大区域.html":{"url":"知识库/笔记/iOS 知识点/内存/内存中的五大区域.html","title":"内存管理","keywords":"","body":"内存管理 内存中的五大区域 Stack 栈 Store all the information about function call executions, to store all the local variables 作用：存储局部变量(结构体变量存储于此) 回收：当局部变量的作用域被执行完毕后，此局部变量就会被系统立即回收； 特点： 声明变量时，字节空间由高地址向低地址分配； 空间相对较小，但访问效率较高 Heap 堆 / Free Store We can request memory from the heap during runtime, and that's what we do when we use malloc or new operator. Fixed in size decided at compile time, which means they don't grow while the application is running. 作用：存储OC类对象，程序员手动申请(calloc, malloc等函数) 回收：MRC下 手动回收, ARC 下自动回收 特点： 每次申请的字节地址都是从0开始，且每次地址不一定挨着，但每次申请的指定字节空间是挨在一起的、连续的 空间相对较大，但访问效率相对栈较低 BSS 段 作用：存储未初始化的全局变量、静态变量 回收：一旦初始化，转存至数据段 Static / Global 数据段 / 常量区 Store the global variables that live for the entire lifetime of the program of the application. 作用：存储已经初始化的全局变量、静态变量和常量数据 回收：直到程序结束才被回收 特点：以字符指针形式存在常量区的字符串数据不能改 Code(Text) 代码段 Store all the instructions needs to be executed; 作用：存储代码(C语言的函数、结构体类型声明代码、OC类代码[以Class对象形式存储]) 回收：程序结束回收 C 程序中使用 堆内存 C functions to use heap memory malloc returns a void pointer that gives us the address of the first byte in this block, the block of memory that is allocates. So, using malloc you kind of say that hey, give me a block of with these many bytes. calloc advance malloc. initial to 0 realloc change the size of the block of the memory. free 程序运行过程中 栈内存 的变化 At any time during the execution of the program, the function at the top of the stack is executing and rest is kind of paused waiting for the function above to return something and then is will resume execution. 堆内存 和 栈内存 的区别和各自的作用？ If the allocation of variables and functions in stack exceeds 1MB(assumption), our program will crash. Further the allocation and deallocation of memory onto the stack happens by a set rule, when a function is called, it is pushed onto the stack on top of the stack, when it is finished, it is popped and removed from the stack. It is not possible to manipulate the scope of a variable if it is on the stack. Another limitation is that, if we want to declare a large data type like an array as local valuable, we need to know the size of the array at compile time only. If we have a scenario like we have to decide how large the array will be based on some parameter during runtime then it is a problem with stack. For all these problems, like allocating large chunks of memory or keeping variable in the memory till the time we want, we have heap. Heap is also called dynamic memory and using the heap is referred to as dynamic memory allocation. So, as you see, in terms of the scope of the variable, anything allocated on the heap is not automatically deallocated when the function completes like on the stack. And, it does not need to live for the whole life time of the application like a global valuable. We can control when to free anything on the heap, when to deallocate anything on the heap. "},"知识库/笔记/iOS 知识点/内存/内存管理.html":{"url":"知识库/笔记/iOS 知识点/内存/内存管理.html","title":"内存管理","keywords":"","body":"内存管理 内存的作用 存储数据 如何将数据存储到内存中 当数据不再被使用时，占用的内存空间如何被释放 内存管理的范围 主要指的是 程序员手动申请的存放 对象 的 Heap 堆区的管理 栈、BSS段、数据段、代码段中的空间回收由系统自动管理，不需要人工干预 在iOS开发中，并没有JAVA或C#中的垃圾回收机制(运行时)，但是所有 OC 对象内部都有一个 retainCount，即引用计数器，其他对象每引用一次此对象，此对象的引用计数器加1，而每次引用完毕后，此对象的引用计数器减1，这样，当引用计数器为0时，就代表此对象不被使用了，系统就会释放 free 这个对象。 引用 refrence 当一个对象 A 的某个属性为另一个 B 对象时，这个属性是个指针类型的变量，它就保存了 B 对象在堆内存中的地址，这样就就叫做 A 引用 B 只要有 1 个对象 引用着 B，那么 B 对象就不能轻易释放，否则会出现 野指针 的问题导致程序崩溃 MRC (手动引用计数) 引用计数器: 每个对象都有1个属性，叫做 retainCount，占据 8 个字节，类型是 unsigned long 记录当前的对象被多少人使用 默认情况下，创建1个对象出来，它的引用计数器是1 当对象的引用计数器为 0 的时候，系统就会立即回收这个对象，并调用对象的 dealloc 方法 MRC 内存管理关键字 retain 在声明对象 A 的属性时，如果此属性的类型为 B OC对象，则需要使用 retain 属性修饰符，即当A的这个属性被赋值 B 对象时，B 的 retainCount，即引用计数器会加1，表示 A 引用 B，或者 A 在使用 B release 创建一个新对象后，引用计数器默认为1，所以在使用此对象后需手动 release 当 A 对象销毁时，即 A 不再使用 B 对象了，那么 A 对象必须在自己的 dealloc 方法中，向 B 发送一条 release 消息，B 的 retainCount，即引用计数器会减 1 内存管理原则 有对象的创建，就要匹配 1 个 release retain 的次数 和 release 的次数要匹配 体现在刚创建了对象，就立马匹配一个向它发送 release 谁用谁 retain，谁不用谁 release 体现在声明OC对象类型的属性时 retain 修饰符，和 dealloc 中向该属性发送 release 只有多一人使用时才 retain，少 1 人使用时才 release /// Seller 类 @interface Seller : Person /* > 货物属性的类型是 productForSale，是个 OC 对象，当此属性被赋值该对象时，会向它发送一条 retain 消息 代表该 Seller 对象 引用 此 Goods 对象 > 根据 MRC 内存管理原则，谁用谁 retain，谁不用谁 release，必须在此 Seller 类 的 dealloc 方法中向 productForSale 发送 release 代表当 Seller 对象销毁时，就结束对 Goods 对象的引用，productForSale 对象引用计数器减 1 */ @property(nonatomic, retain) Goods *productForSale; @end - (void)dealloc { [_productForSale release]; [super dealloc]; } 在 MRC 下，重写 dealloc 方法的规范 必须调用父类的 dealloc 方法，并且放在最后调用 因为子类中有父类的属性，而父类属性的 release 是放在父类的 dealloc 方法中的 为了能够释放所有的对象，必须要调用父类的 dealloc 方法 ARC (自动引用计数) 编译的时候，系统会在合适的地方插入 retain 和 release 没有任何强指针指向一个对象的时候，这个对象就会被立即回收 ARC 很好，但是最怕两个对象互相引用，这样它俩的引用计数器都不为0，所以都无法被系统释放 如果一个对象没有任何强类型的指针指向它，即便有 weak 类型的指针指向它，也会被自动释放， 表象: 只要没有强指针指向这个对象，它就会被释放 本质: 对象的引用计数器为 0 时，自动释放 weak 表示这个属性指向的对象被当前对象弱引用，即底层声明此属性时，不用 retain 关键字，即此属性被赋值时，不会向用来赋值的对象发送 retain 消息，它的引用计数器不会加 1 strong 强引用，底层有 retain 关键字，即此属性被赋值时，向用来赋值的对象发送 retain 消息，它的引用计数器会加 1 unowned ARC 和 MRC 的转换 将整个项目设为MRC Target - Build Settings - All 搜索 \"ARC\", 在 Apple Clang - Language - Objective-C 中 将 Objective-C Automatic Reference Counting 从 Yes 改为 No 将特定类设为MRC(告诉编译器，将来编译这个类时用MRC编译)禁用arc Build Phases - Compile Source - 特定类 - Compiler Flags - \"fno-objc-arc\" 将 MRC 转为 ARC Edit - Convert - To Objective-C ARC "},"知识库/笔记/iOS 知识点/内存/内存泄漏.html":{"url":"知识库/笔记/iOS 知识点/内存/内存泄漏.html","title":"内存泄漏","keywords":"","body":"内存泄漏 什么叫内存泄漏？ 指对象没有被回收，该回收的时候没有被回收，一直驻留在内存中知道程序结束 单个对象发生内存泄漏的原因 有对象的创建，没有匹配的 release retain 与 release 不匹配 在不恰当的时候，指针赋值为 nil 在方法中不当使用 retain 如何做到单个对象被正确释放 有对象的创建就要有对象的 release 有多少个 retain 就要有多少个 release 不要轻易为 1 个指针赋值为 nil，除非指针是 1 个野指针 在方法中不要轻易的为参数 retain 多个对象的内存泄漏 当 1 个对象的属性是另外 1 个对象的时候，如果对这个属性的 set 封装还是像我们基础班那样直接赋值，就会出现野指针的问题 set 方法的内存管理 在 MRC 的模式下，如果属性的类型是 OC 对象类型的，这个属性的 setter 方法应该如何写？ /// _dog 属性的 setter 方法 /// @param dog 用来赋值的 dog 对象 - (void)setDog:(Dog *)dog { // 当赋值的对象和就对象是同一对象时，什么也不做 if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值 { // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性 // 1. 就对象不再使用，向旧对象发送一条 release 消息 [_dog release]; // 2. 使用新对象，向新对象发送一条 retain 消息 _dog = [dog retain]; } } 循环 retain 当两个对象相互关联时 人对象中有 1 个车 车对象中有 1 个人 如果这两个 @property 都使用 retain，就会出现泄漏 解决方案: 1 端 retain，1 端 assign，使用 assign 的那端不再需要在 dealloc 中 release 了 "},"知识库/笔记/iOS 知识点/内存/@property.html":{"url":"知识库/笔记/iOS 知识点/内存/@property.html","title":"@property","keywords":"","body":"@property @property 的作用 @property int age; 生成一个私有的，int 类型的属性 _age；是声明在 @implementation 的大括弧中 生成 getter、setter 的声明 生成 getter、setter 的实现 setter 的实现: 将传进来的值不做任何操作直接赋值给属性 @property 可以带参数，不同的参数有不同的效果 与多线程相关 atomic: 默认的 nonatomic: 选择 nonatomic，因为效率高 【MRC下使用】和生成的 set 方法相关的参数 retain 生成的 set 方法就是 标准的 MRC 内存管理代码，不再是直接赋值了 而是先判断新旧对象是否为同一个对象，如果不是，release 旧的，retain 新的。 retain 只是生成的 set 方法是标准的 MRC 内存管理代码，不会自动的在 dealloc 中 release，所以我们还要在 dealloc 方法中手动的 release 属性指向的对象 /// 标准的 MRC 内存管理代码 /// _dog 属性的 setter 方法 /// @param dog 用来赋值的 dog 对象 - (void)setDog:(Dog *)dog { // 当赋值的对象和就对象是同一对象时，什么也不做 if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值 { // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性 // 1. 就对象不再使用，向旧对象发送一条 release 消息 [_dog release]; // 2. 使用新对象，向新对象发送一条 retain 消息 _dog = [dog retain]; } } // retain 不会生成这里的代码，需要手动 release dog - (void)dealloc { // 在此 Person 对象销毁的时候，向持有的 name 和 dog 对象分别发送 release // 让 引用计数器 减 1 [_name release]; [_dog release]; [super dealloc]; } assign 默认值，生成的 set 方法中不做其他任何操作，直接赋值 如果属性的类型是 OC 对象类型的，使用 retain 如果属性的类型是 非OC 对象类型的，使用 assign 【ARC下使用】strong 、weak 都是应用在 属性的类型 是 OC 对象的时候 大部分时候，都用 strong 只有当出现循环引用的时候，一边用 strong，一边用 weak 和生成的属性 只读、读写 有关的参数 readwrite: 默认值， getter setter 同时生成 readonly: 只生成 getter 修改生成 getter、setter 方法的名字 一般情况下别改，只在 1 个地方 当属性的类型是 BOOL 类型的时候，就更改 getter 的名字以 is 开头 "},"知识库/笔记/iOS 知识点/内存/野指针和僵尸对象.html":{"url":"知识库/笔记/iOS 知识点/内存/野指针和僵尸对象.html","title":"野指针和僵尸对象","keywords":"","body":"野指针和僵尸对象 对象回收的本质 内存回收的本质 申请1个变量，实际上就是向系统申请了指定字节数的内存空间，这些空间系统就不会再分配给别人了 当变量被回收的时候，代表变量占用的字节空间从此以后系统可以分配给别人使用了 但那个字节空间存储的数据还在那里 对象回收的本质 所谓的对象回收，指的是对象占用的空间可以分配给别人 当这个对象占用的空间没有分配给别人前，对象的数据还在 野指针 C 语言中的野指针 定义了一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，指向一块随机的内存空间，这个指针叫做野指针 OC 中的野指针 指针变量指向的对象已经被回收了，这样的指针叫野指针 僵尸对象 一个已经被释放的对象，但是它所占用的空间还没被系统分配给别人，这样的对象叫僵尸对象 开启僵尸对象功能，将会使僵尸对象内存空间不能被访问，直接报错 Edit Scheme - Run - Diagnostics - Enable Zombie Objects 使用野指针访问僵尸对象会报错，如何避免僵尸对象错误？ 当一个指针成为野指针后，将它设置为 nil 当一个指针的值为 nil 后，通过这个指针去调用对象方法时，包括使用点语法时，不会报错 只是没有任何反应 但是通过 -> 直接访问属性就会报错 无法复活一个僵尸对象 开启僵尸对象检测 通过野指针访问僵尸对象，不管僵尸对象的空间有没有分配给别人，都会报错 如何避免使用僵尸对象 当指针为野指针的时候，将其赋值为 nil "},"知识库/笔记/iOS 知识点/函数指针、Block、Closure.html":{"url":"知识库/笔记/iOS 知识点/函数指针、Block、Closure.html","title":"Block / Closure / 函数指针","keywords":"","body":"函数指针、Block、Closure的使用 函数指针 函数的声明 返回值类型 函数名称([参数列表]) { ​ 写上那段需要被重用的代码； ​ 叫做函数体 } 指向函数的指针 声明 返回值类型 (*指针名) ([参数列表]); void (*pFunction) (); 表示声明了1个指向函数的指针，名字叫做pFunction。 这个指针只能指向没有返回值，并且没有参数的函数。 int (*pFun) (int num1, int num2); 表示声明了1个指向函数的指针，名字叫做pFun. 这个指针只能指向返回值为int类型，并且有两个整型的参数的函数。 初始化 取到符合指针条件的函数的地址 函数的名称就代表函数的地址 将地址赋值给指针变量 直接将符合条件的函数的名称赋值给这个指针。 使用指针间接调用指针指向的函数 void (*pFunc) () = test; // pFunc指针就指向了test函数 pFunc(); (*pFunc)(); Block (OC) OC中 方法 的声明 -(void) demo:(NSString *)name { function body; } OC 中声明 block 类型的 变量 返回值类型 (^block名称)(参数); void (^demo)(); void (^finishedBlock)(UIImage *image); OC 中声明 block 类型的 属性 // Block类型的属性：当网络任务完成时的回调block @property (nonatomic, copy) void (^finishedBlock)(UIImage *image); OC 中声明 block 类型的 函数参数 // 接收block参数的类方法 + (instancetype) operationWithURLString:(NSString *)urlString andFinishedBlock:(void (^)(UIImage *image)) finishedBlock; OC 中 block 的初始化 // 在Xcode中输入inlineblock就会出现 void (^demo)() = ^(参数) { NSLog(@\"快快快\"); }; [self setDemo:^{ NSLog(@\"快快快\"); }]; OC 中 block 的调用 demo(); Closure (Swift) Swift 中 函数/方法 的声明 func demo(_ name: Int) -> Void { 代码 } Swift 中声明 closure 类型的变量 /// 记录显示 VC 的闭包 var competionBlock:((_ clsName:String?)->())? (参数)->(返回值类型) Swift 中声明 closure 类型的函数参数 func tokenRequest(method:JLHTTPMethod = .GET, URLString:String, parameters:[String:Any]?, name:String? = nil, data:Data? = nil, completion: @escaping (_ json:Any?, _ isSuccess:Bool)->()){ } class func loadStatus(since_id:Int64 = 0, max_id:Int64 = 0, completion: @escaping (_ list:[[String:Any]]?, _ isSuccess:Bool)->()){ } Swift 中 closure 的初始化 // 完整写法 alphaAnim.completionBlock = {(anim, isSuccess)->() in // 需要执行回调 print(\"完成回调展现控制器\") self.competionBlock?(sender.clsName) } // 简写 alphaAnim.completionBlock = {_, _ in // 需要执行回调 print(\"完成回调展现控制器\") self.competionBlock?(sender.clsName) } "},"知识库/笔记/iOS 知识点/多线程/多线程.html":{"url":"知识库/笔记/iOS 知识点/多线程/多线程.html","title":"多线程、Runloop、自动释放池","keywords":"","body":"多线程 存在的意义 在主线程(UI线程)上执行耗时任务会造成卡顿，比如网络通信、循环等 屏幕两个控件接收用户点击，一个控件点击后会执行耗时操作，这时再点击另外一个就不起作用，界面卡死了(阻塞)。 解决办法：将耗时操作放到另外一个线程去执行 概念 进程 Process 指在系统中正在运行的一个应用程序 每个进程之间是独立的，每个进程均运行在其专用的受保护的内存空间内 通过\"活动监视器\"可以插卡Mac系统中所开启的进程 线程 Thread 1个进程由多个线程组成(1个进程只要要有1个线程) 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行 主线程 一个程序运行后，默认会开启一个线程，成为”主线程“或”UI线程“，一般用来刷新UI界面，处理UI事件(比如：点击、滚动、拖拽等事件) 主线程的runloop默认开启，保证程序不退出 子线程 除了主线程都是子线程，子线程的runloop默认不开启 多线程 Multi - Thread 一个进程可以开启多个线程，多个线程可以”同时“执行不同的任务 多线程可以解决程序阻塞的问题 多线程可以提高程序的执行效率 队列 Queue 将一些耗时的任务全部添加到队列中，CPU从队列中取出任务执行 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. 串行队列 Serial Queue 这种队列中的任务一个一个的按顺序执行 并行队列 Concurrent Queue 这种队列中的任务可以好几个同时开始执行 同步 sync CPU执行当前线程的代码时，遇到Sync会等待，Sync后的代码块执行完毕再执行下段代码 异步 async CPU执行当前线程的代码时，遇到Async会直接跳过其中的代码块直接执行下段代码【此段代码另开线程执行去了】 多线程原理 CPU快速在多个线程之间切换执行 CPU调度线程的时间足够快，就造成了多线程的“同时”执行 线程执行完毕会自动销毁 多线程优缺点 优点 能适当提高程序的执行效率 能适当提高资源的利用率(cpu, 内存) 线程上的任务执行完成后，线程会自动销毁 缺点 开启线程需要占用一定的内存空间(默认情况下，每一个线程都占512KB) 如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，cpu在调用线程上的开销就越大 程序设计更加复杂，比如线程间的通信、多线程的数据共享 线程间通信 从子线程回到主线程 比如: 当图片在子线程上异步下载完成后回归到主线程上更新UI 多线程访问共享资源的问题【线程安全】 共享资源 1块资源可能会被多个线程共享，也就是多个线程可能访问同一资源 比如多线程访问同一个对象、同一个变量、同一个文件 问题 当多个线程访问同一资源时，很容易引发数据错乱和数据安全问题 互斥锁 线程同步：一个线程一个线程的执行 使用 @synchronized(锁对象) {需要锁定的代码(有对共享变量或文件的读写操作)} 特点 能有效防止因多线程抢夺资源造成的数据安全(正确)问题 但会影响程序的执行效率，因为在锁住的时候，其他线程在等待，削弱了多线程的作用，所以这个锁锁的代码越少越好 原理 每一个对象(NSObject)内部都有一个锁(变量)，当有线程要进入synchronized到代码块中会先检查对象的锁是打开还是关闭状态，如果锁是打开状态(1), 如果是线程执行到代码块内部 会先上锁(0)。 如果锁被关闭，再有线程要执行代码块就先等待，直到锁打开才可以进入。 线程执行到synchronized i 检查上锁状态 如果是开锁状态(1)转到ii 如果上锁(0)转到v ii 上锁(0) iii 执行代码块 iv 执行完毕 开锁(1) v 线程等待(就绪状态) 加锁后程序执行的效率比不加锁的时候要低，因为线程要等待锁，但是锁保证了多个线程同时操作全局变量的安全性 自旋锁 原子属性 属性的修饰符 nonatomic 非原子属性 atomic 原子属性(线程安全)，针对多线程设计的，默认值 保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值) atomic 本身就有一把锁(自旋锁) nonatomic和atomic对比 atomic：线程安全，需要消耗大量的资源 nonatomic：非线程安全，适合内存小的移动设备 iOS开发建议 所有属性都声明为nonatomic 尽量避免多线程抢夺同一资源 尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 自旋锁无法解决卖票的问题，因为读写还是分开的 互斥锁和自旋锁的区别 互斥锁 如果发现其他线程正在执行锁定代码，线程会进入休眠(就绪状态)，等其他线程时间片到打开锁后，线程会被唤醒(执行) 自旋锁 如果发现有其他线程正在锁定代码，线程会用死循环的方式，一直等待锁定的代码执行完成，自旋锁更适合执行不耗时的代码 线程安全 线程同时操作是不安全的，多个线程同时操作一个全局变量 线程安全：在多个线程进行读写操作时，仍然能够保证数据的正确 主线程(UI线程)保证线程安全 几乎所有UIKit提供的类都是线程不安全的，所有更新UI的操作都在主线程上执行 所有包含Mutable的类都是线程不安全的 多线程和网络通信的关系 多线程是为了减少卡顿，而卡顿是由于在主线程上执行了耗时任务造成的，将耗时任务另外开子线程线程去执行就会减少卡顿，而网络通信就是耗时任务，所以，在网络通信任务一般都会开子线程执行。 "},"知识库/笔记/iOS 知识点/多线程/pthread.html":{"url":"知识库/笔记/iOS 知识点/多线程/pthread.html","title":"pthread","keywords":"","body":"pthread 简介 C语言 一套通用的多线程API 适用于Unix\\Linux\\Windows等系统 跨平台\\可移植 线程生命周期程序员管理 使用难度大 创建线程的函数 pthread_create(&pthread, NULL, runATask, (__bridge void *)(name)); 参数1：线程编号变量的地址 参数2：线程的属性变量的地址 参数3：要创建的线程中要执行的函数(我们要做的任务就在这里)。这是个函数signature: void () (void*) 这个函数signature分解: 返回值类型void，函数名( _Nonnull) 和参数类型(void* _Nullable) int 是指向int类型变量的指针，void 是指向任何类型变量的指针，有点类似OC中的id 参数4: 要执行的函数的参数 返回值 int 0是成功， 非0是失败(可以是其他任何数，用来表示失败的原因) "},"知识库/笔记/iOS 知识点/多线程/NSThread.html":{"url":"知识库/笔记/iOS 知识点/多线程/NSThread.html","title":"NSThread","keywords":"","body":"NSThread 简介 OC语言 使用更加面向对象 简单易用，可直接操作线程对象 线程生命周期程序员管理 线程的状态 新建 就绪 运行 阻塞 死亡 线程的属性和方法 线程名称name 设置线程名称可以当线程执行的方法内部出现异常的时候，记录异常和当前线程 线程优先级threadPriority 线程的优先级，并不能保证谁先执行完 内核调度算法在决定该运行哪个线程时，会把线程的优先级作为考量因素，较高优先级的线程会比较低优先级的线程具有更多的运行机会。较高优先级不保证你的线程具体执行时间，只是相比较低优先级的线程，它更有可能被调度器选择执行而已。 isMainThread 使用方法 // 线程状态之 - 创建 NSThread *thr = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; // 线程状态之 - 就绪(进入可调度线程池，CPU会来给它几毫秒的执行时间) [thr start]; "},"知识库/笔记/iOS 知识点/多线程/GCD.html":{"url":"知识库/笔记/iOS 知识点/多线程/GCD.html","title":"GCD","keywords":"","body":"GCD 简介 C语言 旨在替代NSThread等线程技术 充分利用设备的多核 线程生命周期自动管理 什么是 GCD 全称是Grand Central Dispatch 纯C语言，提供了非常多强大的函数 GCD 优势 GCD是苹果公司为多核的并行运算提出的解决方案 GCD会自动利用更多的CPU内核(比如双核、四核) GCD会自动管理线程的生命周期(创建线程、调度任务、销毁线程) 程序员只需告诉GCD想要执行什么任务，不需要编写任何线程管理代码 GCD 两个核心概念 任务 Operation：要执行的耗时操作，比如打开网页、循环等 队列 Queue：用来存放任务 GCD 使用的两个步骤 创建任务：确定要做的事情 将任务添加到队列中，就自动开始执行了 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. GCD中执行任务的2个函数 同步方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block) 同步，在当前线程中执行任务，不开新线程 异步方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block) 异步，在新的线程中执行任务，会开新线程(只有开多于1个线程才能异步执行) GCD队列的2大类型 并发队列(Concurrent Dispatch Queue) 作用 可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务) 并发功能只有在异步(dispatch_async)函数下才有效 全局队列 本质就是并发队列 全局队列和并发队列的区别 全局队列一直存在，并发队列任务执行完会销毁 并发队列有名称，可以跟踪错误，全局队列没有 在ARC中不需要考虑释放内存，因为不允许调用dispatch_release(q). 在MRC中需要手动释放内存，并发队列是create创建出来的，在MRC中见到create就要release，全局队列不需要release(只有一个)。 一般使用全局队列 全局队列的参数 第一个: 服务质量(线程的优先级) 第二个: future use 串行队列(Serial Dispatch Queue) 作用 让任务一个接一个执行(一个完成后再执行下一个) 主队列 是个特殊的串行队列 在async函数中【异步执行】 不开线程(特殊之处，与一般串行队列不同)，同步执行 主队列特点: 如果主线程正在执行代码暂时不调度任务，等主线程执行结束后再执行任务 又叫全局串行队列 在sync函数中【同步执行】 程序执行不出来(死锁) 死锁的原因: 当程序执行到下面sync函数这段代码的时候 主队列：如果主线程正在执行代码，就不调度任务 同步执行：如果第一个任务没有执行，就继续等待第一个任务执行完成，再执行下一个任务此时互相等待，程序就无法往下执行(死锁) 注意: 虽然主队列也是串行队列，但它执行异步任务时不开新线程，即做dipatch_async函数的参数时, 只是等主线程当前正在执行的任务结束后再执行主队列的任务 队列 和 同异步执行的组合 sync函数 + 串行队列 特点: 不开新线程(就在当前线程)，队列中任务一个一个按顺序执行 sync函数 + 并行队列 特点: 不开线程(只在当前线程)，队列中任务一个一个按顺序执行(因为只有一个线程，无法异步) async函数 + 串行队列 特点: 新开一个线程，队列中任务一个一个按顺序执行 注意: 虽然主队列也是串行队列，但它执行异步任务时不开新线程，只是等主线程当前正在执行的任务结束后再执行主队列的任务 async函数 + 并行队列 特点: 新开多个线程，无序执行 使用方法 选择一个用来存放任务的合适的队列 使用dispatch_async或dispatch_sync函数将任务block添加到队列并开始执行 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. // OC - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // // 创建队列 // dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // // 创建任务 // dispatch_block_t task = ^ { // NSLog(@\"%@\", [NSThread currentThread]); // }; // // 将任务添加到队列 // dispatch_async(queue, task); // 简易用法 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"%@\", [NSThread currentThread]); }); } // Swift // 模拟从网络异步加载视图配置信息 JSON，并存储到 沙盒中 DispatchQueue.global().async { let url = Bundle.main.url(forResource: \"main.json\", withExtension: nil) let data = try! Data(contentsOf: url!) let docPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] let docUrl = URL(fileURLWithPath: docPath) let fileURL = docUrl.appendingPathComponent(\"main.json\") print(fileURL.absoluteString) try? data.write(to: fileURL) } 理解方式 当 CPU 开始执行某线程上的代码时: 执行到async函数代码块时，会\"直接跳过\"函数参数Queue中的任务(代码块)[其实是开了另外的线程去执行Queue中的任务]，直接执行后面的代码。 执行到sync函数代码块时，当前线程会等待函数参数Queue中所有任务(代码块)执行完毕，才继续执行后面的代码 而Queue中的所有任务(代码块)，会根据Queue种类不同有不同的执行方式: serial串行执行: 所有任务一个一个按顺序执行 concurrent并发执行: 几个任务同时开始执行，高效率省时间，但是没有顺序 同时使用同步和异步保证任务执行顺序 // 模拟app store购买的过程 // 验证密码 - 扣费 - 下载应用 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 因为这三个环节都是通过网络，会是耗时操作，所以不能同步执行，不然会导致卡死 // // 这里是异步，所以肯定会开一个线程执行里面这三个添加任务的代码 dispatch_async(dispatch_get_global_queue(0,0), ^{ // 这里是同步(不开新线程)，所以在当前线程按顺序执行(不管什么队列) dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"1. 验证密码: %@\", [NSThread currentThread]); }); // 这里是同步(不开新线程)，所以在当前线程按顺序执行(不管什么队列) dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"2. 扣费: %@\", [NSThread currentThread]); }); // 这里是异步(开新线程执行，也可能会线程重用)，但是只有这一个任务了，前面两个任务都完成了，所以这最后一个任务无所谓按顺序与否 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"3. 下载应用: %@\", [NSThread currentThread]); }); }); } barrier阻塞 主要用于在多个异步操作完成后，统一对非线程安全的对象进行更新 适合于大规模的I/O操作 当访问数据库或文件的时候，更新数据的时候不能和其他更新或读取的操作在同一时间执行，可以使用调度组，不过有点复杂。 可以使用dispatch_barrier_async解决 延迟执行 // OC NSLog(@\"三秒后打印我爱你\"); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"我爱你\"); }); // Swift // 为了防止还没滚到顶部，就已经开始刷新数据了 DispatchQueue.main.asyncAfter(deadline: .now() + 1) { tvc.loadData() // 刷新新微博后，取消 tabbar 和 APP 红点 self.tabBar.items?[0].badgeValue = nil UIApplication.shared.applicationIconBadgeNumber = 0 } 一次执行 /* 原理是在常量区设置了一个变量，执行一次后设个值，以后每次过来检查如果是这个值就不执行 */ for (int i = 0; i 调度组监听所有任务完成通知 要异步(多个线程)下载三首歌，三首歌全部下载完成后通知用户，就可以使用dispatch_group【但并不能保证下载完成的先后顺序】 // Swift /* 1) loadImage 是 SDWebImage 的核心方法 2) 图像下载完成后，会自动保存在沙盒中，文件路径是 URL 的 md5 3) 如果沙盒中已经存在缓存的图像，后续使用 SD 通过 URL 加载图像，都会加载本地沙盒的图像 4) 不会发起网络请求，同时，回调方法，同样会调用！ 5) 方法还是同样的方法，调用还是同样的调用，不过内部不会再次发起网络请求！ ***注意*** 如果缓存的图像累计很大，要找后台要接口！ */ /// 缓存只有一张图像的微博的图像 /// - Parameter list: 本次下载的视图模型数组 private func cacheSingleImage(list:[JLStatusViewModel], finished: @escaping (_ isSuccess:Bool, _ shouldRefresh:Bool)->()) { // 记录所有单张图片缓存的内存大小 var cacheSize = 0 // 创建调度组 let group = DispatchGroup() // 遍历此次获取的微博数组 list.forEach{(vm) in // 找到只有 1 张图片的，进行下载缓存 if vm.picURLS?.count == 1, let urlStr = vm.picURLS?.first?.thumbnail_pic { // `入组` 将要执行图片下载任务 group.enter() // 用 SD 下载此图片并自动缓存 SDWebImageManager.shared.loadImage(with: URL(string: urlStr), options: [], context: nil, progress: nil) { (image, data, nil, _, _, _) in cacheSize += data?.count ?? 0 // 更新单个图片的尺寸 if let image = image { vm.updateSingleImageSize(with: image) } // `出组` 此图片任务完成， group.leave() } } } // 监听调度组任务完成情况 group.notify(queue: .main) { print(\"此次所有单张图片缓存完毕，大小为: \\(cacheSize / 1024)kb\") // 完成回调 finished(true, true) } } "},"知识库/笔记/iOS 知识点/多线程/NSOperation.html":{"url":"知识库/笔记/iOS 知识点/多线程/NSOperation.html","title":"NSOperation","keywords":"","body":" NSOperation NSOperation VS GCD NSOperation 其实就是要往队列里添加的耗时任务 简介 OC语言 基于GCD(底层是GCD) 比GCD多了一些更简单实用的功能 使用更加面向对象 线程生命周期自动管理 特点 NSOperation是一个抽象类 不能直接使用(方法只有声明没有实现) 用来约束子类都具有共同的属性和方法 NSOperation的子类 NSInvocationOperation 创建NSInvocationOperation对象 调用start方法开始执行操作 默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行，只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作。 NSBlockOperation 创建NSBlockOperation对象 通过addExecutionBlock:方法添加更多操作 只要NSBlockOperation封装的操作数>1，就会异步执行操作 自定义operation 即通过创建NSOperation的子类，可以定制一些功能，需要重写main方法，添加自动释放池等 目的: 封装如 下载图片 这样的耗时操作 自定义Operation，模拟下载图片 创建HMDownloaderOperation类，继承自NSOperation 重写自定义Operation的main方法 重写- (void)main方法，在里面实现想执行的任务 自己创建自动释放池(因为如果是异步操作，无法访问主线程的自动释放池) 经常通过-(BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 在controller中调用start方法，或者添加到队列。main方法会被调用 NSOperationQueue 队列 存放并执行操作的地方 使用步骤 先将需要执行的操作封装到一个 NSOperation 对象中 然后将 NSOperation 对象添加到 NSOperationQueue 中 系统会自动将 NSOperationQueue 中的 NSOperation 取出来执行 将取出来的 NSOperation 封装的操作放到一条新线程中执行 队列中操作的执行的过程 把操作添加到队列[self.queue addOperationWithBlock]; 去线程池取空闲的线程，如果没有就创建新线程 把操作交给从线程池中取出的线程执行 执行完成后，把线程再放回线程池中 重复2,3,4直到所有操作都执行完 线程间通信 从子线程回到主线程 比如: 当图片在子线程上异步下载完成后回归到主线程上更新UI 主队列 添加到主队列的操作，最终都执行在主线程上 当前队列 获取当前操作的队列 [NSOperationQueue currentQueue]; 最大并发数 什么是最大并发数？ 最多同时执行的任务数 比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 maxConcurrentOperationCount setMaxtConcurrentOperationCount 队列的暂停、取消、恢复 取消队列的所有操作 cancelAllOperations; 也可以调用NSOperation的cancel方法取消单个操作 暂停和恢复队列 setSuspended // YES代表暂停队列，NO代表恢复队列执行 isSuspended 操作的优先级 和 监听操作完成 不设置优先级的话，可以明显看出开了两个线程切换执行op1和op2 可以设置操作(任务)的优先级(服务质量),但并不能保证高优先级的任务执行过程中，低优先级的任务不执行 op1.qualityOfService = NSQualityOfServiceUserInteractive; 可以设置监听某个任务完成后回调某个方法 [op1 setCompletionBlock:^{ NSLog(@\"-----------------op1 finished--------------\"); }]; 操作依赖 (保证任务执行顺序) NSOperation之间可以设置依赖来保证执行顺序 下载、解压和升级完成分别在不同的线程上执行，用add dependency来确保执行顺序 下载和解压操作在子线程，升级完成在主线程执行，依然可以添加依赖。 NSOperation VS GCD GCD iOS4.0推出，主要针对多核cpu做了优化，是C语言的技术 GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数 GCD提供了一些NSOperation不具备的功能 一次性执行 延迟执行 调度组 NSOperation NSOperation是iOS2.0推出的，iOS4之后重写了NSOperation 将操作NSOperation(异步的任务)添加到队列(并发队列)，就会执行 NSOperation中提供的方便的操作 最大并发数 队列的暂定/继续(暂停的是没有执行的任务) 取消所有的操作 执行操作之间的依赖关系(GCD中用同步就可以实现) "},"知识库/笔记/iOS 知识点/多线程/Runloop 消息循环.html":{"url":"知识库/笔记/iOS 知识点/多线程/Runloop 消息循环.html","title":"Runloop 消息循环","keywords":"","body":"Runloop 消息循环 简介 消息循环属于线程，主线程的消息循环默认开启着，里面在等待着屏幕上的用户输入事件。 相当于给当前的代码这里插入一个while死循环而已，然后while里面可以运行代码。while循环体内的代码运行在当前线程的消息循环上，而外面的代码运行在当前线程上(非消息循环上)。 作用 保证程序不退出 接收和处理用户的事件【主线程的消息循环(while死循环)在程序加载完毕就一直在等待处理用户的输入事件】 原理 就是一个死循环 在每次循环中，一直卡在等待用户输入信息的位置(用户触摸屏幕) 当用户点击屏幕(产生事件)，就会有相应的处理事件的方法被调用 这个方法执行完毕后，这次消息循环完毕，又重新开始下一次消息循环 注意【消息循环模式会变化】 注意： 因为runloop在不同的情况下有不同的模式，比如当屏幕上的scrollView被拖动时，主线程的runloop就会由defaultMode模式变为UITrackingRunLoopMode，但是这两个模式都属于commonModes。如果timer源被添加在runloop的defaultMode，那它的方法在trackingMode就不会被执行，所以可以将它添加在runloop的commonModes来解决问题。 自动释放池 存在意义 / 作用 如果一个循环创建了大量的临时对象 你可以在循环内部使用自动释放池在下次循环开始前处理掉那些对象。这样可以减少程序的最大内存使用量。 如果你创建了一个子线程。 你必须在子线程开始执行前立即创建自动释放池，否则你的程序会发生内存泄漏。 自动释放池 标记为autorelease的对象，会被添加到最近一次创建的自动释放池中 当自动释放池被销毁或耗尽时，会向自动释放池中的所有对象发送release消息 自动释放池是什么时候创建的？又是什么时候销毁的？ 每一次主线程的消息循环开始的时候会先创建自动释放池 消息循环结束前，会释放自动释放池 自动释放池被销毁或耗尽时会向池中所有对象发送release消息，释放所有autorelease的对象 使用NSThread做多线程开发时，需要在线程调度方法中手动添加自动释放池 "},"知识库/笔记/iOS 知识点/网络/网络通信.html":{"url":"知识库/笔记/iOS 知识点/网络/网络通信.html","title":"网络","keywords":"","body":" 网络通信 网络通信的过程 - 理论 网络通信的过程 - 实践 遵守 HTTP 协议的网络通信 网络通信 详见 【网络新闻 App】、【网络通信】 网络的实际用途 登录验证 验证服务器上的用户名和密码，登录 发送HTTP请求，使用GET方法，将用户名和密码拼在url中 发送HTTP请求，使用POST方法，将用户名和密码拼在请求体中 获取 data 二进制数据 (html, json, plist, xml等) 上传文件 上传图片、视频等 发送HTTP请求，使用POST方法，将要上传的文件拼在请求体中，需要服务器端php文件支持 发送HTTP请求，通过session，使用PUT方法，不需要php支持，需要配置服务器webDav服务 上传单个文件 上传多个文件 暂停 继续 取消 断点续传 进度显示 下载文件 下载图片、视频等 概念 客户端: 应用 C/S(Client/Server ) B/S(Browser/Server) 服务器: 为客户端提供服务、数据、资源的机器 局域网服务器 外网服务器 本地测试服务器 服务器软件 Apache Nginx 请求：客户端向服务器索取数据 响应：服务器对客户端的请求做出反应，一般是返回给客户端数据 网络通信的过程 - 理论 【理论】网络通信的过程 网络模型 OSI 和 TCP/IP 存在的意义 数据传输时，数据流流经的每一段，也就是数据从网络一端传到另一端要经过的步骤 数据传输的流程 Joya微信打字发送hello到YL手机的微信 微信(应用层)给这段字加上http协议的字段->传输层给这段字加上加上微信的端口信息【TCP(UDP)协议的字段】->网络层给这段字加上Joya手机的IP地址信息[IP协议的字段等]->网络接入层再添加一些信息?就进入网线传递了->到YL所在的网络中后经过相反的拆信息的步骤显示在YL手机的微信上。 OSI模型(Open System Interconnection Model) Application Layer 应用层 Presentation Layer 表示层 Session Layer 会话层 Transport Layer 传输层 四层交换机、四层路由器 Network Layer 网络层 路由器、三层交换机 Datalink Layer 数据连接层 网桥、以太网交换机、网卡 Physical Layer 物理层 中继器、集线器、双绞线 TCP/IP 模型 应用层: 对应OSI的前三层，为用户提供所需的服务如FTP, Telnet, DNS,SMTP,HTTP等。浏览器应用对应http协议，文件传输软件对应ftp协议等。 传输层: 负责为要发送的数据加入始发程序的端口号或者按照接收到的数据的端口号在主机上寻找对应的指定的应用程序 为应用层提供端到端的通信功能，保证了数据包的传输顺序及数据完整性。 端到端，即端口到端口，也就是一个主机上的应用到另一个主机上的应用 两个主要传输协议：TCP和UDP TCP(传输控制协议) 可靠的、通过“三次握手”来连接的数据传输服务，一对一 UDP(用户数据报协议) 不保证可靠、无连接的数据传输服务，广播 网络层 负责为要发送的数据加入自己主机的和要发送到的主机的IP地址信息，或者接收网络上属于自己主机IP地址的信息数据 解决主机到主机的通信问题。它所保护的协议涉及数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。 该层有3个主要协议：IP网际协议、互联网组管理协议(IGMP)和互联网控制报文协议(ICMP)。 网络接入层 （网卡层面）对应数据链路层和物理层 负责监视数据在主机和网络之间的交换 网络通信的过程 - 实践 Socket 通信 介绍 位于应用层和传输层之间，应用程序构造数据，用户输入hello，应用层的软件把数据传给socket，socket把数据封装传输给传输层、网络层等。 Socket又称”套接字“，应用程序通过”套接字“向网络发送请求或向网络做出应答 网络通信其实就是Socket之间的通信 数据在两个Socket之间通过IO传输数据 Socket是纯C语言的，是跨平台的 HTTP协议时基于Socket的，HTTP协议的底层使用的就是Socket 作用 从这里开始传输数据，socket封装应用层App传入的用户要发送的数据，再将其传输给传输层、网络层直到网络通信的另一端(服务器) 通信过程 创建Socket 使用Socket()函数 连接到服务器 使用connect()函数 发送数据给服务器 使用send()函数 从服务器接收数据 使用recv()函数 关闭连接 使用close()函数 遵守 HTTP 协议的网络通信 请求 request 向服务器发送的数据 请求头、请求体 HTTP 请求 HTTP Request，即要发送给服务器的数据，遵守HTTP协议固定格式的数据 HTTP 请求方法 GET GET一般是获取服务器上的数据，可向服务器传递少量数据 优点 GET速度相对较快 GET方式是通过URL传递数据，效率高 缺点 请求的数据在URL上，相对不安全 login.php?username=zs&pwd=123456 GET请求的结果能够被浏览器缓存 URL 中的参数 a. login.php负责处理登录过程的服务器脚本 b. ?后面跟要传到服务器上的参数(http协议的一部分) c. 参数以 键=值 的形式传递 d. 如果有多个参数使用&连接 http://127.0.0.1/php/login.php?username=admin&password=123 e. 参数中如果有中文和空格创建URL会失败, 需要使用%转义，进行URL编码 // 获取网络服务器上JSON数据 NSString *username = @\"张三\"; NSString *password = @\"zhan\"; NSString *urlString = [NSString stringWithFormat:@\"http://127.0.0.1/php/login.php?username=%@&password=%@\",username, password]; // 如果url字符串中有汉字或空格，要对url字符串中?后面的空格或者汉字做百分号转义 urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL *url = [NSURL URLWithString:urlString]; POST POST速度相对GET较慢 传递大量数据时使用，比如上传文件使用post POST一般是往服务器提交数据，并获取服务器返回的结果 POST方式是通过请求体传输数据，效率低 POST请求的数据用户看不到，并且不能被浏览器缓存相对安全，传递隐私数据时使用 POST请求头比GET请求头中多的东西 Content-Length: 25 // 发送给服务器数据的大小 Cache-Control: max-age=0 // 永不缓存数据 Content-Type: application/x-www-form-urlencoded // 请求头中的Content-Type // 告诉服务器，发给服务器的数据格式和url中传参的格式是一样的 key=value&k1=v1 HEAD 不获取响应体，只获取响应头 一般在下载之前先获取文件的大小 PUT PUT 上传 配置Apache服务器WebDav功能 put直接以文件的方式写入 post需要服务器端脚本支持 DELETE OPTIONS TRACE CONNECT PATCH 请求体中各项的含义 请求体: ------WebKitFormBoundaryqwY1zO88PZll2khX Content-Disposition: form-data; name=\"userfile\"; filename=\"pic03.jpg\" Content-Type: image/jpeg 二进制数据(要上传的文件) ------WebKitFormBoundaryqwY1zO88PZll2khX-- 含义: 分隔符 ------WebKitFormBoundaryqwY1zO88PZll2khX name 表单的name属性值 filename 传递给服务器的文件名 Content-Type 告诉服务器传递的文件类型 text/plain image/jpeg image/jpg image/png application/octet-stream等 二进制数据 要上传文件的NSData 响应 response 即服务器返回的数据 HTTP 响应 HTTP Response 即从服务器接收的数据，遵守HTTP协议固定格式的数据 响应的构成 状态行Status Line 响应头Headers 响应体Content 状态码 200 正常 401 没有授权 HTTPS 发送请求之前先挑战服务器(进行https的协商) https的协商 信任服务器返回的证书(公钥) 客户端产生随机秘钥 公钥对随机秘钥进行对称加密(rsa) 把公钥加密后的随机秘钥发送给服务器 使用随机秘钥加密数据和服务器交互 // https的证书认证交换秘钥加密信息等，这个方法实现后，可正常接收https的网页信息 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler { NSLog(@\"收到服务器挑战\"); // 判断认证方式(是用户名密码还是证书认证) if (challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust) { // 设置信任服务器的证书 NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(0,credential); } } Charles抓包监视HTTP请求和响应内容 压缩和解压 SSZipArchive【如果走完所有步骤还是无法解压，查看被加压的文件权限】 一台服务器的不同端口可以处理不同的网络请求 192.168.31.254 此地址的服务器可以处理以下不同的网络请求 http://192.168.31.254:5000/ 此服务器上处于 5000 端口的程序处理遵守 http 协议的网络请求(发送的字符串数据是http协议格式) ftp://192.168.31.254:21/ 21 端口的程序处理遵守ftp协议的网络请求(发送的字符串数据是按照ftp协议格式组织的) smb://192.168.31.254:445/ 445 端口的程序处理遵守smb协议的网络请求(发送的字符串数据是按照smb协议格式编制的) afp://192.168.31.254:548 548 端口的程序处理符合afp协议的网络请求(发送的字符串数据是按照afp协议格式编制的) "},"知识库/笔记/iOS 知识点/网络/服务器软件.html":{"url":"知识库/笔记/iOS 知识点/网络/服务器软件.html","title":"服务器软件","keywords":"","body":"服务器软件配置 Apache Nginx "},"知识库/笔记/iOS 知识点/网络/加密和解密.html":{"url":"知识库/笔记/iOS 知识点/网络/加密和解密.html","title":"加密和解密","keywords":"","body":"加密和解密 作用 网络传输信息过程中可能会被窃取，所以需要加密 网络应用程序的数据安全 a. 网络上不允许传输用户隐私数据的\"明文\"; b. 在本地不允许保存用户隐私数据的\"明文\"; base 64 编码 可以将任意的二进制数据编码成字符串，在网络传输 在终端使用 base64 编码解码 在终端演示 base64 编码 base64 xx.png -o abc.txt 编码文件 echo -n \"Man\" | base64 编码字符串 在终端演示 base64 解码 base64 abc.txt -o xx.png -D 解码文件 echo -n \"TWFu\" | base64 -D 解码字符串 base64编码的原理 编码后的数据又a-z A-Z 0-9 + / = 表示 把自个字符转换成二进制取出前6位查表 不够6位的时候补0，如果是8位，则补4个0，编码后连接两个== 如果最后是4位，补2个0，编码后连接一个= 编码之后文件会变大，是源文件的4/3——12/8 6/4——3/2 加密算法 对称算法 特点: 加密和解密都使用相同的秘钥 速度快，适合对大数据加密 DES, 3DES, AES 非对称算法 特点: 加密和解密的秘钥不同 用公钥加密，用私钥解密 用私钥加密，用公钥解密 算法公开，可逆的加密算法 速度慢，适合对小数据加密 RSA 散列算法 不可逆算法 MD5, SHA1, SHA256, SHA512 MD5 算法简介 作用 对任意的数据源计算，生成固定长度的字符串。32个字符 一般用来加密密码 计算文件的md5值，用户可以验证从网络上下载的文件是否在下载的过程中被修改了 终端使用 md5 md5 -s \"admin\" MD5 破解 破解MD5，暴力破解(md5不可逆) 百度-在线破解md-5 防止暴力破解 加盐 原密码+一个复杂的字符串，防止用户输入的密码过于简单 HMAC 原密码+一个字符串 进行混合再 md5计算 把计算的结果+原密码 再进行md5计算 md5+时间，每次生成的md5值不一样 一个字符串key md5计算 把原密码和之前生成的md5值再进行hmac加密 从服务器后去当前时间 到分钟 的字符串 第二步产生的hmac值+时间 和第一步产生的md5值进行hmac加密 钥匙串 详见 网络【Day03 - NSURLConnection模拟登陆v3完整版】 通过系统提供的钥匙串功能可以在本地保存密码，系统使用 AES 的方式对密码加密 查看Safari中保存的密码 使用第三方框架SSKeychain[iOS10以后用SAMKeychain]把密码保存到钥匙串和获取钥匙串中的密码 第三方框架: SAMKeyChain 获取钥匙串中的所有用户 [SSKeychain allAccounts] 把密码保存到钥匙串中 service可以用bundleID 从钥匙串中获取密码 "},"知识库/笔记/iOS 知识点/网络/Socket.html":{"url":"知识库/笔记/iOS 知识点/网络/Socket.html","title":"Socket","keywords":"","body":"Socket 简介 在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 "},"知识库/笔记/iOS 知识点/网络/NSURLSession.html":{"url":"知识库/笔记/iOS 知识点/网络/NSURLSession.html","title":"NSURLSession","keywords":"","body":"NSURLSession 简介 之前发送网络请求的过程 URL -- URLRequest -- URLConnection iOS7以后 -- NSURLSession 用于替代NSURLConnection 支持后台运行的网络任务 暂停、停止、重启网络任务，不再需要自己封装NSOperation 下载、断点续传、异步下载 上传、异步上传 获取下载、上传的进度 DataTask 要拿网页HTML数据、JSON、XML数据时使用 【默认挂起，须resume】 UploadTask 要上传文件时使用 默认挂起，须resume 配置Apache服务器WebDav功能 演示 HTTP 的Method，PUT GET DELETE PUT 上传 put直接以文件的方式写入 post需要服务器端脚本支持 通过session发送put请求上传文件 如果直接上传返回状态码401 --没有授权 因为WebDav设置了基本身份验证，所以请求的时候得携带验证的字符串 自己上传或删除一个文件，用charles监视请求 请求头有意向Authorization: Basic YWRtaW46MTIzNDU2 YWRtaW46MTIzNDU2是base64编码的账号和密码 通过base64解码还原admin:123456 常用的请求头 post时候的Content-Type、Range、User-Agent、Authorization DownloadTask 要下载文件时使用 启动任务--执行的过程是异步的 默认挂起，须resume 回调获取文件数据 downloadDelegate获取文件下载进度和实现断点续传，不能使用sharedSession【delegate会出现循环引用】 会出现的问题 狂点暂停，再继续会闪退 暂停，关闭程序重新开始，继续会闪退 多次点击继续会重复从原来的地方继续下载，所以每点击一次就清空一下resumData 在界面上放个scrollView，拖动的时候下载任务不会停止 因为下载任务是异步执行的(即使把下载任务添加到主队列中) 当发生合适的事件后，通知代理对象 所有代理方法都是在主线程上异步执行的(任务添加到主队列的时候) 拖动scrollView的时候下载不会停止 内存暴涨的解决办法 NSFileHandle 在文件存储的路径，实现下一点，往那个路径存一点的功能 还能实现一点一点读的功能？可以解决数组全部加载到内存的问题？ // 为了防止把下载的数据全部加载到内存中，造成内存暴涨闪退，用fileHandle实现下一点往内磁盘存一点，不占用内存 - (void) saveData:(NSData *)data { // 创建保存文件的路径 NSString *filePath = @\"/Users/joyawang/Desktop/v.mp4\"; // NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:filePath]; if (handle == nil) { // 如果此路径还没有文件，先创建文件 [data writeToFile:filePath atomically:YES]; } else { // 开始处理文件 // handle offset指针默认指向文件的头部，而我们要往文件的尾部写入数据，所以，先将指针指向尾部 [handle seekToEndOfFile]; // 写入数据 [handle writeData:data]; // 关闭处理文件 [handle closeFile]; } } NSOutputStream NSStream 流 抽象类 -(void)open; -(void)close; NSOutputStream 输入流 在内存和硬盘之间创建一个管道，运送一些字节 把字节通过流写入文件 [write buffer maxLength]; 步骤 接收到响应头开始创建流并打开 接收到数据开始写文件 下载结束或下载出错，关闭流 问题 如果文件已存在，再次下载的时候会追加文件[导致文件比原来大] 在文件下载之前，先判断有文件，如果有则删除重新下载？ NSURLSessionConfiguration 在一个地方配置请求头的信息，所有任务都使用此请求头 作用 可以设置请求头(Content-Type Range User-Agent Authorization等) 可以设置最大连接数 可以设置超时时长，缓存策略 类构造方法 defaultSessionConfiguration 会使用磁盘缓存，账户信息存储到钥匙链，如果有cookie会携带cookie ephemeralSessionConfiguration 没有磁盘缓存，不存储账户信息，不携带cookie 数据存储在内存，速度快，如果要存储到磁盘须自己写 backgroundSessionConfigurationWithIdentifier 在一个单独的进程上下载 app进入后台或终止之后，依然可以继续下载 属性 HTTPAdditionalHeaders 添加请求头 requestCachePolicy 缓存策略 timeoutIntervalForRequest 请求的超时时长 allowsCellularAccess 运行蜂窝网络访问 HTTPMaximumConnectionPerHost 主机的最大连接数 NSURLResponse MIMEType 返回的文件的类型Content-Type ExpectedContentLength 文件的预期大小(实际大小) suggestedFilename 建议保存的文件的名字 "},"知识库/笔记/iOS 知识点/网络/AFNetworking.html":{"url":"知识库/笔记/iOS 知识点/网络/AFNetworking.html","title":"AFNetworking","keywords":"","body":"AFNetworking AFURLSessionManager AFHTTPSessionManager GET登录 POST登录 下载 返回存储文件的路径URL 获取进度：对progress的fractionCompleted进行KVO 断点续传 上传 当从网络获取数据时，显示菊花 [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 设置缓存文件夹名称和缓存大小 // 设置缓存 /* 内存缓存: 5M 磁盘缓存: 10M 缓存文件夹名称: joyaImages */ NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:1024*1024*5 diskCapacity:1024*1024*10 diskPath:@\"joyaImages\"]; [NSURLCache setSharedURLCache:cache]; "},"知识库/笔记/iOS 知识点/网络/URL 及其构成详解.html":{"url":"知识库/笔记/iOS 知识点/网络/URL 及其构成详解.html","title":"URL 及其构成详解","keywords":"","body":" URL 及其构成详解 组成部分2: 主机(服务器)IP地址或域名 组成部分3: 端口号 组成部分4: 路径 URL 及其构成详解 URL 组成格式 网络协议://主机IP地址或域名:端口号/路径 网络协议：不同的协议代表不同的资源获取方式 主机地址：主机的唯一标识(ip地址、域名) 路径: 此 url 要访问的资源在主机中的具体位置 组成部分1: 网络协议 存在意义 回忆socket，最原始的网络通信就是通过socket发送和接收二进制数据，在发送和接收时数据的编制遵循一定的规则，才可以正常通信，而不同的规则就是网络协议，比如http协议要求，发送的数据叫做请求，请求有请求头和请求体，请求头中不同field代表不同的含义，这样发送和接收时都遵守这个协议，数据就可发送成功，还有用于其他网络传输的协议。 http 发送的字符串数据是按照 HTTP 协议格式编制的，网络间传输网页(声音、视频、文字等)的URL协议，超文本传输协议 (默认端口80，需要有个处理http请求的软件如apache监听服务器电脑的80端口)超文本传输协议，网页(声音、视频、文字等)传输 http://192.168.31.254:5000/ http://www.baidu.com:80/ http:// www.itheima.com:80/images/xx00.png ftp 网络间传输文件的协议 ftp://192.168.31.254:21 FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。 smb 发送的字符串数据是按照smb协议格式编制的 Server Message Block SMB，网络间文件共享的协议，默认端口139、445等 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。 smb://192.168.31.254:139 afp Apple Filing Protocol （AFP）是一种网络协议，为Mac计算机提供文件服务，苹果的网络间文件传输协议 afp://192.168.31.254:548 file 可以访问的Mac本地的文件路径的URL file:///Users/joyawang/Desktop/qq空间/244092911 smtp 发送邮件的协议 pop3 接收邮件的协议 tel:// 电话通信协议 sms:// 短信通信协议 组成部分2: 主机(服务器)IP地址或域名 IP 地址 IPV4 IP 地址第 4 版 x.x.x.x 表示互联网中的一个地址 每个x可以是从0到255的任意一个数(256个)，而要表示这个范围的数需要8位二进制数，有4个这样的数，所以需要32位二进制数，而32位二进制数可以表示(2^32)42.95亿个ip地址(256256256*256) IPV6 IP 地址第 6 版 用128位二进制表示一个ip地址，所以可以有(2^128)2的128次方个IP地址 常见 IP 地址: 192.168.1.1 127.0.0.1 回环地址(本机地址) 255.255.255.255 广播 0.0.0.0 any 私有Private IP address: home router, business router 10. 192.168. 172.16. 举例 协议://主机ip地址或域名:端口号/路径 http://www.baidu.com/index.html http:// www.itheima.com:80/images/xx00.png smb://192.168.31.254 从finder去Joyacloud的URL https://joyacloud.cn8.quickconnect.cn/ 从浏览器去JoyaCloud的域名URL http://192.168.31.254:5000/ 从浏览器去JoyaCloud的本地ip地址URL afp://192.168.1.2 file:///Users/joyawang/Desktop/qq空间/244092911 可以访问的Mac本地的文件路径的URL /Users/joyawang/Desktop/qq空间/244092911 Mac本地的文件路径 域名 IP地址不好记，域名好记，但是在访问某域名时需要域名解析服务器将域名解析为对应的IP地址 www.baidu.com 和 182.61.200.6 访问的是同一台服务器，一个是域名，一个是 ip 地址 其它概念 Subnet Mask子网掩码 255.255.255.255 和IP地址一起使用可以确定另一个电脑是否和你在同一网络 which is used to decide whether or not some other computers on the same network as you Gateway/Router 网关/路由器 192.168.31.1 ISP Internet Service Provider 网络服务提供商 DHCP Server 动态IP地址分配服务器 DNS Server 域名解析服务器 免费DNS服务器 谷歌：8.8.8.8 国内：014.014.014.014 WAN口 Wide area network interface 广域网接口 主要用于连接外部网络，如ADSL、DDN、以太网等各种接入线路。 宽带路由器的【路由】功能就是体现在WAN口IP地址和LAN口IP地址之间的数据路由上，我们通常根据网络运营商提供的接入方式来设置WAN口的网络参数，通常有静态IP地址、动态IP地址或PPOE等方式，它与网络运营商的接入设备处于同一个【外部】网络中。 LAN口 Local Area Network Interface 局域网接口 用来连接家庭内部网络，主要与家庭中的交换机、集线器或PC相连。 LAN口的IP地址则设置为本地局域网内的IP地址，通常是我们自己可以在宽带路由器上自行设定的IP地址，LAN口下所连接的计算机组成一个【本地局域网】，路由器的LAN口IP地址是这个网络的网关。 hosts 域名本地解析 相当于本地域名服务器 操作系统中的hosts文件则是有着类似“本地DNS服务器”的作用，而且比网络上的DNS具有更高的优先级。如果你在hosts里面配置了某个域名和IP的对应关系，比如127.0.0.1 -> localhost，那么当你在本机访问localhost时，系统首先会从hosts里面解析出127.0.0.1这个IP，而不会再去查询网络上的DNS服务器。hosts文件仅对本机生效，对其他电脑和网站本身不会造成任何影响 Windows 系统 Hosts 文件路径：C:\\Windows\\System32\\drivers\\etc\\hosts； Mac 系统 hosts 文件路径：/etc/hosts； Linux 系统的 hosts 文件一般也是在：/etc/hosts； Android 系统的 hosts 文件路径：/system/etc/hosts (需要Root权限修改)； 组成部分3: 端口号 介绍 连接到某个服务器后，要根据URL协议类型选择服务器上不同的处理数据的程序，如处理http协议的apache软件一般是服务器的80端口。如果没有安装web服务器软件的话，80端口一般是空闲的。 服务器上会有不同的程序处理不同的网络请求，端口号就是每个程序的身份标识。(是逻辑地址意味着不是物理的，不是物质上实际存在的) HTTP默认的端口80：即向一个服务器发送一个HTTP网络请求时，这个网络请求到了服务器后，直接调用服务器上监听80端口的方法，也就是运行那个程序。 FTP协议默认的端口21 pop3 接收邮件的协议110 smtp 发送邮件的协议25 端口的分类 公认端口(Well Know Ports) 这类端口也常称为“常用端口”。这类端口的端口号从0-1024，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。比如:http默认80，ftp默认21 注册端口(Registered Ports) 端口号从1025到49151.分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了的公认端口的常用程序。 动态或私有端口(Dynamic or Private Ports) 从49152到65535.之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配 例如192.168.31.254这个服务器地址，不同的协议类型会导致访问时访问不同的端口号 http://192.168.31.254:5000/ 192.168.31.254这个地址上的服务器，遵守http协议的web请求会被5000端口的程序处理 smb://192.168.31.254 192.168.31.254这个地址上的服务器，遵守smb协议的请求会被端口的程序处理 组成部分4: 路径 /Users/joyawang/Desktop/qq空间/244092911 Mac本地的文件路径 "},"知识库/笔记/iOS 知识点/网络/URL 类.html":{"url":"知识库/笔记/iOS 知识点/网络/URL 类.html","title":"URL 类","keywords":"","body":"iOS 中的 URL 类 meituan:///showP1:P2:P3:P4:/大西瓜/红牛/小樱桃/小肥羊 属性 scheme 协议头 meituan host 主机头 nil 如果没有 /// pathComponents 返回数组 URL 中所有路径的数组 show：P1:P2:P3:P4: 大西瓜 红牛 小樱桃 小肥羊 query 查询字符串 URL 中 ? 后面所有的内容 "},"知识库/笔记/iOS 知识点/网络/WKWebView.html":{"url":"知识库/笔记/iOS 知识点/网络/WKWebView.html","title":"WKWebView","keywords":"","body":"WKWebView webView/WKWebView【详见Practices中的webView & HTML & JavaScript】 WKWebView的使用详解 实例应用 Practices中的webView & HTML & JavaScript 彩票设置界面 跳转到网页的指定位置 JL微博_JLOAuthViewController 自动填充用户名密码功能 webView 的用途 可加载本地doc、pdf、mp4、html等文件 使用 自动检测网页中的电话、邮件地址、链接 // 在创建webView时，用configuration设置【WKWebView】 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; config.dataDetectorTypes = WKDataDetectorTypeAll; WKWebView *wv = [[WKWebView alloc] initWithFrame:UIScreen.mainScreen.bounds configuration:config]; // 【webView，已废弃】 dataDetectorTypes = UIDataDetectorTypeAll iOS APP 与 HTML 交互 iOS 的控件执行 JavaScript 代码控制 Html5 页面的变化 WKWebView 在用 先设置WKWebView的navigationDelegate 在代理方法didFinishNavigation中调用 [webView evaluateJavaScript:code completionHandler:nil]; webView 已废弃 先设置webView的代理，在代理方法webViewDidFinishLoad里面调用下面方法 [webView stringByEvaluatingJavaScriptFromString:] webView 加载的 html5 页面上的控件执行 iOS 的方法 WKWebView 在用 将JavaScript中要调用的OC方法名先注册到wkWebView.configuration.userContentController中【只写一个方法名即可】 [wv.configuration.userContentController addScriptMessageHandler:self name:@\"showAlert\"]; 遵守WKScriptMessageHandler协议，在协议方法userContentController didReceiveScriptMessage中拦截已注册的方法名并进行本地处理【在这里实现JS要调用的方法】 在此页面销毁时，移除注册的方法，否则会造成内存泄漏[wv.configuration.userContentController removeScriptMessageHandlerForName:@\"showAlert\"] 在HTML5的JavaScript中使用window.webkit.messageHandlers.showAlert.postMessage(\"我是来自HTML网页里JavaScript中的消息\");调用注册的方法 showAlert为注册的方法名 postMessage中为传递给该方法的参数 webView 已废弃 先在html中创建一个超链接 调用OC的方法 source:/// 自定义协议 showMessage:方法名、方法参数 helloword 参数 在webView的代理方法中 从request获取协议信息、方法名、参数 request.URL.scheme协议信息 request.URL.pathComponents[1] 方法名 request.URL.pathComponents[2] 参数 通过方法名创建SEL 判断respondsToSelector后，使用performSelector执行这个SEL对象 delegate 方法 WKNavigationDelegate 页面开始加载时调用 didStartProvisionalNavigation 当内容开始返回时调用 didCommitNavigation 页面加载完成之后调用 didFinishNavigation 页面加载失败时调用 didFailProvisionalNavigation 接收到服务器跳转请求之后调用 didReceiveServerRedirectForProvisionalNavigation 在收到响应后，决定是否跳转 decidePolicyForNavigationResponse 在发送请求之前，决定是否跳转 decidePolicyForNavigationAction WKUIDelegate "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 原理 和 方法的调用.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 原理 和 方法的调用.html","title":"Runtime 运行时原理及应用","keywords":"","body":" 运行时原理和方法的调用 OC中对象方法和类方法的调用过程 运行时原理和方法的调用 OC中对象方法和类方法的调用过程 对象方法的调用过程 比如，[p1 run]; 调用都是 [receiver selector]; 的形式，本质就是让对象在运行时发送消息的过程。 编译阶段: [receiver selector]; 方法调用被编译器转换为下面的 C 函数: objc_msgSend(receiver, selector) (不带参数) objc_msgSend(receiver, selector, org1, org2,...) （带参数） 运行时阶段: 消息接受者receiver寻找对应的selector。 通过receiver的isa指针找到receiver的Class(类)；isa意思是is a，如jim对象is a Person类。 在Class(类)的cache(方法缓存)的散列表中寻找对应的IMP(Implementation方法实现，IMP是一个指向C函数的指针)； 通过给出的 SEL(方法名) 去找到对应的函数Implementation，即找到该方法名对应的 IMP 函数指针，再通过此指针找到那个函数实现并调用。 如果在cache中没有找到对应的IMP的话，就继续在Class的method list中找对应的selector，如果找到，填充到cache中，并返回selector； 如果在Class中没有找到这个selector，就继续在它的superClass(父类)中寻找； 一旦找到对应的selector，直接执行它所在method结构体中对应的方法实现IMP指针指向的函数？。 若找不到对应的selector，消息被转发或者临时向receiver添加这个selector对应的实现方法，否则会发生崩溃。 类方法的调用过程 和对象方法调用差不多，流程如下： 通过类对象 isa 指针 找到所属的 Meta Class（元类）； 在 Meta Class（元类） 的 method list（方法列表） 中找到对应的 selector; 执行对应的 selector。 "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 的应用.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 的应用.html","title":"运行时 的应用","keywords":"","body":"Runtime 运行时 利用 运行时 机制的 KVC KVO 获取属性列表、成员变量列表和方法列表 反射机制 注册监听通知 监听点击事件 代理模式？ 注册监听通知 实例应用 QQ聊天 特点 一对多，可以有多个监听者监听事件，只要有注册的监听者，在注销监听之前，都可以接收到通知！ 发生事件时，将通知发送给通知中心，通知中心再广播通知！，效率相对代理较低 如果层次嵌套太深，可以使用通知传值 使用 // 发布通知 NotificationCenter.default.post(name:Notification.Name.init(rawValue:JLUserShouldLoginNotification), object: \"bad token\") // 注册监听通知 NotificationCenter.default.addObserver(self, selector: #selector(userLogin), name: NSNotification.Name(rawValue: JLUserShouldLoginNotification), object: nil) // 移除通知，防止内存泄漏 NotificationCenter.default.removeObserver(self) 代理模式 特点 一对一，只能有一个监听者监听事件，最后一个设置的代理对象有效！ 发生事件时，直接让代理执行协议方法，效率更高 直接反向传值 如果层次嵌套太深，不利于传值，可以使用通知传值 监听点击事件 btn.addTarget(self, action: #selector(buttonTapped(_:)), for: .touchUpInside) "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVC 和 构造函数.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVC 和 构造函数.html","title":"运行时应用 - KVC 和 构造函数","keywords":"","body":"KVC 构造函数 即字典转模型 KVC 字典转模型 Key - Value - Coding 字典转模型，用字典给对象属性赋值 setValueForKey setValuesForKeys(_keyedValues: dict) dictionaryWithValuesForKeys KVC是利用OC的运行时 使用KVC创建构造函数注意点： 用KVC字典转模型方式创建构造函数时，必须直接或间接继承自NSObject，否则没有setValueForKey等KVC方法 想要用 KVC 赋值的属性，必须在前面使用@objc显式标记(Swift4.0以后)，否则无法成功【或在类名前用@objcMembers标记】 定义模型属性时 如果是对象，通常都是可选的 ( Optional ) 在需要的时候才创建，不需要就不创建，节省内存空间 避免写构造函数，可以简化代码 如果是基本数据类型，不能设置成可选的，而且要设置初始值，否则 KVC 会崩溃 如Int 是一个基本数据类型的结构体，OC 中没有相应的类，只有基本数据类型int，而基本数据类型没有可选一说，一旦设置成可选，KVC就找不到这个key了 如果需要使用 KVC 设置数值，属性(或方法)不能是私有 private 的，否则KVC会崩溃【可以使用@objc private】 在OC中，可以在私有扩展中\"藏\"属性，但是在运行时依然可以获取到 而Swift中，一旦将属性设置为 private ，运行时无法获取到此key，所以 KVC 无法使用 如果子类没有重写父类的 KVC 方法init(dict:) ，调用的时候，会直接调用父类的方法，setValues时，会给子类的属性一并赋值 如果字典中的key比对象的属性多，调用setValueforUndefinedKey并且函数体中不写任何实现，来保证在设置undefinedKey时不崩溃。 // KVC的基本实现 // 因为KVC是OC的东西，所以类必须是NSObject的子类才能使用KVC class Teacher:NSObject { @objc var name:String? // 可空、可选属性【因为在Swift中是结构体，对应OC是NSString对象】 @objc var age:Int = 0 // Int 是一个基本数据类型的结构体，OC 中没有相应的类，只有基本数据类型int，而基本数据类型没有可选一说，一旦设置成可选，KVC就找不到这个key了 init(dict:[String:Any]) { // 在调用self的KVC方法之前，必须保证本类和父类都已初始化 //【先将父类初始化，本类因为只有一个可选属性，可初始化为空，所以相当于本类自动初始化了】 super.init() setValuesForKeys(dict) } // 重写父类的方法 override func setValue(_ value: Any?, forUndefinedKey key: String) { // 没有调用 super，将父类的代码完全覆盖，保证碰见undefined key的时候不会崩溃 } } "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVO.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVO.html","title":"运行时应用 - KVO","keywords":"","body":"KVO 监听 NSObject 子类 属性变化 Key - Value - Observer 监听对象属性变化 addObserver(forKeyPath: ) 注册监听者，监听对象的 属性 变化 // KVO 监听父视图的 contentOffset scrollView?.addObserver(self, forKeyPath: \"contentOffset\", options: .new, context: nil) // 所有 KVO 方法会统一调用此方法 func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) // 移除监听者，防止内存泄漏 superview?.removeObserver(self, forKeyPath: \"contentOffset\") "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - YYModel.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - YYModel.html","title":"运行时应用 - YYModel","keywords":"","body":"YYModel JSON Object 和 Json Data JSON Object Dictionary 类型 Array 类型 JSON Data Data 类型 其它 转到 模型 字典 -> 模型 model.yy_modelSet(with:[:]) JSONObject -> 模型 model.yy_modelSet(withJSON:Any) 字典数组 转到 模型数组 NSArray.yy_modelArray(with: JLEmoticonPackage.self, json: array) as? [JLEmoticonPackage] 模型 转到 其它 模型 -> 字典 model.yy_modelToJSONObject() 模型 -> JSON data model.yy_modelToJSONData() 用字典键值对给模型设置属性 ​ model.yy_modelSet(with:Dict) "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 命名空间和反射机制.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 命名空间和反射机制.html","title":"运行时应用 - 命名空间和反射机制","keywords":"","body":" 命名空间 & 反射机制 命名空间 反射机制 在 OC 中如何利用反射机制 命名空间 & 反射机制 命名空间 Swift 中有命名空间 在同一个命名空间下，全局共享 第三方框架使用 Swift 如果直接拖拽到项目中，从属于一个命名空间，很可能有冲突！ 尽量使用 cocoapods 管理第三方框架 反射机制 反射机制 的概念 对于任意一个类，都能够知道这个类的所有属性和方法 对于任意一个对象，都能够调用它的任意一个方法和属性 这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制 Swift 中 NSClassFromString (反射机制) 的写法 反射最重要的目的，就是为了解耦！ 搜索 反射机制和工厂方法！ 提示：第一印象会发现一个简单的功能，写的很复杂 但是，封装的很好，而且弹性很大 在 OC 中如何利用反射机制 利用 NSClassFromString 方法来使用字符串获得类 利用 isMemberOfClass: 判断是否是一个类 利用 isKindOfClass 判断是否是一个类或者它的子类 利用 conformsToProtocol 判断对象是否遵守某个协议，即实现了此协议的方法实现 利用 respondsToSelector 判断是否实现了某一个方法【判断代理是否实现某方法】 利用 performSelector 或者 objc_msgSend 间接调用方法【webView 和 JavaScript 互相调用方法时使用】 Swift中使用反射机制 NSClassFromString ，字符串动态创建类对象 // 根据字符串动态创建类对象 // 本可以从info.plist中使用CFBundleName键取的，但是如果名字中有空格或-等，会被替换，所以用下面方法拿命名空间 // 获取该项目中任意一个类的类名【命名空间.类名】 let nameComponents = (NSStringFromClass(type(of: self)) as String).split(separator: \".\") // 获取该项目的命名空间【好像只有带横线的能创建成功】 guard let nameSpace = nameComponents.first else { return } // 构造创建类的字符串 let cls_name = nameSpace + \".\" + \"ViewController\" // 根据类名字符串创建类 guard let cls = NSClassFromString(cls_name) as? ViewController.Type else { return } // 创建类对象 let vc = cls.init() 修改命名空间、产品名 "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 获取成员变量列表、属性列表、方法列表.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 获取成员变量列表、属性列表、方法列表.html","title":"运行时应用 - 获取成员变量列表、属性列表、方法列表","keywords":"","body":"利用运行时获取属性列表和方法列表 用 KVC 字典转模型方式创建构造函数时，必须直接或间接继承自 NSObject，否则没有 setValueForKey 等KVC方法 在 swift4.0 以后要使用 runtime 获取的属性和方法必须显式标记 objc 才可以用 runtime 获取 如果只是获取属性列表的话【懒加载和计算属性都可获取的到】，不需要继承自 NSObject，只需标记@objc或@objcMembers即可 使用类方法获取属性列表时，在class_copyPropertyList(self, &cCount)中，第一个参数必须传入self，不能用object_getClass(self)，否则无法获取 与之相反，用对象方法获取属性列表时，第一个参数只能传入object_getClass(self) @objcMembers 加在类声明前面，那么它、它的子类、扩展里的属性和方法都会隐式的加上 @objc @objc 在属性或方法前加@objc，表示暴露给OC的运行时，在运行时可以用KVC给此属性赋值，也可获取到此属性或方法名 如果在扩展（extension）前加上 @objc，那么该扩展里的属性和方法都会隐式的加上 @objc。 @nonobjc 在属性前加@nonobjc，KVC无法赋值，运行时无法获取到属性或方法列表 如果在扩展（extension）前加上 @nonobjc，那么该扩展里的属性和方法都不会隐式的加上 @objc。 // Swift import Foundation @objcMembers class Person { // 存储属性，类型可在OC中用NSString对象代表，可以被初始化为nil var name:String? // 存储属性，类型不能在OC中用对象代表，不能被初始化为nil，必须设置初始值 @nonobjc var age:Int = 0 // 懒加载属性 lazy var scores = { return 80 + 6 }() // 计算属性 var money:Int { get { return 200 + 300 } } // 计算属性？ var interests:String = { return \"爱好\" }() // 存储属性，closure类型 var finishedCallBack:((_ result:[String])->())? // 类方法利用运行时获取属性列表【懒加载和计算属性都可获取的到】 // 类方法获取属性列表 // class_copyPropertyList(self, &cCount)与对象方法不同 class func propertyList()->[String] { var count:UInt32 = 0 // 用来存储属性的数量, C的类型 // 1. 获取到元素类型为objc_property_t的属性数组 let list = class_copyPropertyList(self, &count) print(\"使用类方法获取属性数量为:\\(count)\") // 2. 遍历数组获取属性名字列表 var propertyNames = [String]() // 用来保存属性名 for i in 0.. 每8位为一组 -> 8位为 1 byte(字节) -> Char占1字节 -> C语言字符串 let c_p_ame = property_getName(prop_t) // 将C字符串转为Swift字符串 let propName = String(cString: c_p_ame) // 添加到属性名数组 propertyNames.append(propName) } // 释放 C 语言对象 free(list) return propertyNames } // 类方法获取方法列表 // class_copyMethodList(self, &cCount)与对象方法不同 class func methodList()->[String] { var count:UInt32 = 0 // 用来存储方法的数量, C的类型 // 1. 获取到元素类型为SEL的数组 let list = class_copyMethodList(self, &count) print(\"使用类方法获取方法数量为:\\(count)\") // 2. 遍历数组获取方法名列表数组 var methodNames = [String]() // 用来保存方法名 // 遍历SEL数组获取方法名 for i in 0..[String] { var count:UInt32 = 0 // 用来存储方法的数量, C的类型 // 1. 获取到元素类型为ivar的属性数组 let list = class_copyIvarList(self, &count) print(\"使用类方法获取成员变量数量为:\\(count)\") // 2. 遍历数组获取成员变量名 var ivarNames = [String]()// 用来保存成员变量名字 for i in 0.. "},"知识库/笔记/iOS 知识点/绘图、动画/CoreGraphics 核心绘图.html":{"url":"知识库/笔记/iOS 知识点/绘图、动画/CoreGraphics 核心绘图.html","title":"绘图和动画","keywords":"","body":" CoreGraphics 核心绘图 Quartz2D UIBezierPath 在 UIView 的 drawRect 中进行绘图 CGRect CoreGraphics 核心绘图 Quartz2D 二维绘图引擎，包含在 CoreGraphics 中 绘制步骤 以下绘制代码写在 UIView 的 drawRect 中 获取 图形上下文 对象 CGContextRef 相当于草稿纸 ，是layer类型的，和当前view的大小相同 不同的上下文决定着不同的输出目标 主要包含以下信息 绘图路径 (各种各样的图形) 绘图状态 (颜色、线宽、样式、旋转、缩放、平移、图片裁剪区域等) 输出目标 绘制到什么地方去？ UIView、图片、pdf文件、Bitmap或者显示器的窗口上、打印机等 向 图形上下文 对象中添加 路径 渲染 (把 图形上下文 中的图形绘制到对应的设备上) 绘制图形 线条 三角形 矩形 圆 弧 绘制文字 绘制、生成图片 (图像) 读取、生成 PDF 截图、裁剪图片 自定义 UI 控件 通过继承 UIView，重写 drawRect 方法实现在控件上绘制各种内容 通过继承 UIView 实现自定义的 UIImageView 实现自定义的 下载进度条 控件 幸运转盘控件 实际应用 画板涂鸦 手势解锁 将矩形头像裁剪为圆形 报表 折线图 饼状图 柱状图 数据类型和函数基本都以 CG 作为前缀 ​ CGContextRef ​ CGPathRef ​ CGContextStrokePath(ctx) UIBezierPath 矩形 +bezierPathWithRect 圆角矩形 +bezierPathWithRoundedRect: radius: 椭圆 +bezierPathWithOvalInRect 圆弧 +bezierPathWithArcCenter 把笔头提到某坐标 -moveToPoint 从笔头处向某坐标处添加一条线 -addLineToPoint 设置线宽-setLineWidth 设置连接处的样式 -setLineJoinStyle 设置头尾的样式 -setLineCapStyle UIColor对象setStroke、setFill、set(同时设置描边和填充颜色)设置颜色 描边 -stroke 填充 -fill 使用奇偶填充规则 -useEvenOddRule 在 UIView 的 drawRect 中进行绘图 绘图代码为什么要写在drawRect当中 因为在这个方法中可以获取到正确的上下文 rect 参数的含义 当前View的bounds drawRect 什么时候调用 这个方法是系统调用，不能手动调用！！！ (1)当此view第一次显示的时候调用 (2)当此view进行重绘redraw的时候会调用(理解成tableView的刷新) 如何重绘 理解成tableView的刷新，当绘图的path中的坐标或其他数据改变时，如果不刷新重新显示的话，view显示的还是原来的绘图 (1)调用某个需要重绘的view对象的setNeedsDisplay。 (2)调用某个需要重绘的view对象的setNeedsDisplayInRect rect:参数表示需要重绘的区域 为什么不能手动调用drawRect 因为手动调用时可能获取不到正确的上下文，画也是白画。 如果需要重新画一些东西的话，调用setNeedsDisplay，系统会自动在适当的时候调用drawRect CGRect offsetBy 偏移后返回一个 Rect insetBy 向内收缩后返回一个 Rect "},"知识库/笔记/iOS 知识点/绘图、动画/动画相关.html":{"url":"知识库/笔记/iOS 知识点/绘图、动画/动画相关.html","title":"动画相关","keywords":"","body":"CALayer 图层、形变、核心动画、物理仿真 动画 UIView.animate 属性动画？ UIIMageView 序列帧动画 layer的Transform 形变 核心动画 CAAnimation pop 框架 UIView.animate 属性动画？ UIIMageView 序列帧动画 layer的Transform 形变 位置移动 变大、变小 旋转 iOS 系统中 UIView 封装的旋转动画 - 默认顺时针旋转 - 就近原则，往某个位置旋转的时候，那边弧度小就从哪边转 - 要想实现同方向旋转，需要调整一个 非常小的数字(近) - 如果想实现 360 旋转，需要核心动画 CABaseAnimation 核心动画 CAAnimation 步骤 创建动画对象 (做什么动画) 基本动画 CABasicAnimation (实例应用: JL微博_JLVisitorView) 透明度渐变 自旋转 关键帧动画 CAKeyframeAnimation 比如，走一个特定的路径 绕圆旋转 动画到某些指定的值 组动画 (将各种动画叠加使用) CAAnimationGroup 转场动画 CATransition 设置动画对象属性 (怎么做动画) keyPath 要做动画的属性 fromValue 从哪个值开始 toValue 到哪个值 byValue 在自身 value 的基础上加多少 不希望回到原来位置 anim.fillMode = kCAFillModeForwards; anim.removedOnCompletion = NO duration 每次动画持续时长 repeatCount 重复次数 添加动画到视图的 layer (对谁做动画) pop 框架 和 核心动画 使用方法差不多 实例应用: JL微博中 JLComposeTypeView 显示撰写微博按钮时 使用方法 // 创建动画 let anim:POPSpringAnimation = POPSpringAnimation(propertyNamed: kPOPLayerPositionY) // 设置动画属性 anim.fromValue = btn.center.y anim.toValue = btn.center.y + 400 // 设置动画时间，最后一个 btn 的启动时间最早 anim.beginTime = CACurrentMediaTime() + CFTimeInterval(v.subviews.count - i) * 0.025 // 添加动画 // propertyName 用的 layer 动画就往layer上加，否则往 view 上加 btn.layer.pop_add(anim, forKey: nil) "},"知识库/笔记/iOS 知识点/绘图、动画/UIDynamic 物理仿真.html":{"url":"知识库/笔记/iOS 知识点/绘图、动画/UIDynamic 物理仿真.html","title":"UIDynamic 物理仿真","keywords":"","body":"UIDynamic 物理仿真 动画者 UIDynamicAnimator 重力行为 UIGravityBehavior 碰撞行为 UICollisionBehavior 甩行为 UISnapBehavior 附着行为 UIAttachmentBehavior 推行为 UIPushBehavior 动力学元素自身属性 弹性 elasticity 密度 density 摩擦力 friction resistance "},"知识库/笔记/iOS 知识点/性能优化/性能优化.html":{"url":"知识库/笔记/iOS 知识点/性能优化/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 如何做出圆角，不用 CornerRadius ？ "},"知识库/笔记/iOS 知识点/常用功能/授权登录/OAuth.html":{"url":"知识库/笔记/iOS 知识点/常用功能/授权登录/OAuth.html","title":"常用功能集成","keywords":"","body":"OAuth 打开门户网站提供的登录页面进行登录 登录成功后，再次发送请求，将 授权码 和 应用程序信息 发送给服务器后获取 AccessToken "},"知识库/笔记/iOS 知识点/常用功能/授权登录/SSH.html":{"url":"知识库/笔记/iOS 知识点/常用功能/授权登录/SSH.html","title":"SSH","keywords":"","body":"SSH Secure Shell 安全外壳协议 使用方法 使用 RSA 非对称算法，生成 密钥对，自己留着 私钥 (用来解密信息) ssh-keygen -t rsa -C root 默认密钥对存放的位置 /Users/joyawang/.ssh/instance1.pub /Users/joyawang/.ssh/instance1 将 公钥 传递给服务器端(用来加密信息)，或直接去服务器页面手动设置 登录 Terminal - Shell - NewRemoteConnection 在 Server 框点击＋ 私钥公钥的应用场景 始终记得: 公钥可以随便给人，而私钥要保密 网络间传递加密信息时 这个场景下公钥用来加密信息，私钥用来解密信息 客户端生成密钥对AB，把公钥B给服务器 服务器生成密钥对CD，把公钥D给客户端 客户端给服务器发消息时用服务器给的公钥D加密，服务器收到后用自己的私钥C解密 服务器给客户端发消息时用客户端给的公钥B加密，客户端收到后用自己的私钥A解密 认证、确认身份时 【在这个场景下，私钥用来加密，公钥用来解密了】 数字签名、证书 客户端输入了一个网址给服务器发送了一个请求以后，确实拿到了服务器返回的公钥，但是这个服务器是不是冒充的它本意想访问的那个服务器是不确定的。 客户端要求服务器去一家双方都认可的权威的证书机构[如公安局]，公安局用自己的私钥将服务器的公钥加密生成一个数字证书，客户端给公安局打电话拿到了用来从数字证书中解密服务器公钥的公钥，这样当用户可以使用公安局给的公钥正常获得服务器的公钥时，就可以确定这个服务器是真正的服务器。 "},"知识库/笔记/iOS 知识点/常用功能/授权登录/SSO.html":{"url":"知识库/笔记/iOS 知识点/常用功能/授权登录/SSO.html","title":"SSO","keywords":"","body":"SSO 跳到第三方应用进行授权再跳回来 更加人性化 在真机上，如果用户安装了门户应用，可以直接跳转到门户应用进行授权 授权完毕后自动返回到应用程序 如果用户没有安装门户应用，会以 OAuth 的方式登录 "},"知识库/笔记/iOS 知识点/常用功能/IM即时聊天/环信客服云集成.html":{"url":"知识库/笔记/iOS 知识点/常用功能/IM即时聊天/环信客服云集成.html","title":"IM聊天","keywords":"","body":"环信客服云集成 可以不注册 APNs 的，不获取 APNs 推送证书 在集成环信的 UI 框架时，可能会出现它的依赖类库与你自己的依赖类库冲突的情况，这时候你就要进入蛋疼的合并冲突类库的过程了，用好git，删除旧的类库，导入最新的，编译、报错、更改。 完了以后，继承客服云最基本的只需要下面两步即可 在你的App用户注册的地方，注册环信客服云的账户，账户就用你App当前用户的账户，比如手机号，密码随便写 HDError *error = [[HDClient sharedClient] registerWithUsername:@\"username\" password:@\"password\"]; error.code: HDErrorNetworkUnavailable 网络不可用 HDErrorUserAlreadyExist 用户已存在 HDErrorUserAuthenticationFailed 无开放注册权限（后台管理界面设置[开放|授权]） HDErrorUserIllegalArgument 用户名非法 在用户点击进入客服时，登录并且显示与客服的会话界面 HDClient *client = [HDClient sharedClient]; if (client.isLoggedInBefore != YES) { HDError *error = [client loginWithUsername:@\"username\" password:@\"password\"]; if (!error) { //登录成功 } else { //登录失败 return; } } // 进入会话页面 HDMessageViewController *chatVC = [[HDMessageViewController alloc] initWithConversationChatter:@\"IM 服务号\"]; // 获取地址：kefu.easemob.com，“管理员模式 > 渠道管理 > 手机APP”页面的关联的“IM服务号” [self.navigationController pushViewController:chatVC animated:YES]; "},"知识库/笔记/Git/Git 基本指令.html":{"url":"知识库/笔记/Git/Git 基本指令.html","title":"Git","keywords":"","body":" Git Git 安装 Git 管理的文件状态 创建 Git 版本库 配置Git 将文件交给 Git 版本库管理 提交更改 查看当前 Git 状态 查看提交历史 回到过去的几种方式 Git Git 安装 Git 官网下载 pkg 安装 Git 管理的文件状态 Stage 状态【Cache】 变绿了，可以被 commit 了 Unstaged 状态 Unmodified 刚 commit 完的状态 Modified 上次 commit 完后，又修改了 创建 Git 版本库 创建本地文件夹 MyProject 在 终端 cd 到 MyProject 文件夹 在 MyProject 目录下创建版本库 git init 生成 .git 文件夹，意味着 MyProject 文件夹已经成为 git 管理的版本库 配置Git git config --list 查看 git 的完整配置信息 git config -l 查看当前 git 的配置 设置 git 管理员信息及查看 管理员名称 git config --global user.name \"Joya\" 邮箱 git config --global user.email \"244092911@qq.com\" 查看 git config user.name git config user.email 将文件交给 Git 版本库管理 比如在 MyProject 文件夹创建自己的文件 1.py，git status 查看当前 MyProject 版本库中文件的状态 新创建的文件必须 git add 1.py ，进入staged 转态，这样才能被 Git 管理，才能被 commit 修改了1.py 以后也要 git add 1.py ，进入 staged 状态，才能被 commit git add 1.py stage 单个文件 git add . stage 所有文件(新建的或者变化了的) 提交更改 git commit -m \"注释\" commit 提交此次修改 git commit -am \"注释\" add 和 commit 同时进行，先 stage，后提交【适用于已经被git管理的文件】 查看当前 Git 状态 git status 查看当前 git 状态 git status -s short 形式显示当前 Git 状态 查看提交历史 git log 查看提交历史 git log --oneline 查看提交历史(每个提交显示一行, 小头版本号) git log --pretty=oneline 每行显示一个commit(大头版本号) git log --oneline --graph 图形显示 回到过去的几种方式 amend【回到最后一次提交前修改】 reset【commit和commit之间穿梭】 checkout【单个文件和单个文件之间穿梭】 rebase【将 branch B 的 commit 插入到 branch A 中】 "},"知识库/笔记/Git/分支及合并 branch & merge.html":{"url":"知识库/笔记/Git/分支及合并 branch & merge.html","title":"分支及合并 branch & merge","keywords":"","body":" 分支及合并 branch & merge 查看所有分支，以及当前所在的分支 创建分支 切换分支 删除分支 创建分支的同时切换分支 合并分支 解决合并过程中的冲突 分支及合并 branch & merge 查看所有分支，以及当前所在的分支 git branch git branch -a 查看所有分支，包括远程仓库的，git branch貌似只能查看本地的 创建分支 【从当前分支，可以是任一分支】创建名为 dev 的分支 git branch dev 切换分支 切换到 dev 分支，将 HEAD 指针放到 dev 分支 git checkout dev 删除分支 删除 dev 分支【只有当前HEAD不在dev分支时才起作用】 git branch -d dev git branch -D boss 创建分支的同时切换分支 【从当前分支，可以是任一分支】创建 dev 分支的同时，切换到 dev 分支 (即将 HEAD 指针放到dev分支) git checkout -b dev 合并分支 先切回主分支 git checkout master git merge dev` 使用 fast forward 方式合并 dev 分支到 master 分支，不添加这次合并的注释信息 git merge --no-ff -m \"合并dev到master\" dev 合并分支，不使用 fast forward 的方式，会添加这次合并的注释。如果 dev 和 master 没有冲突的话就直接成功了 解决合并过程中的冲突 创建了 dev 后，你在 dev 上修改，但同时有人在 master 上修改，当你合并时，就会出现冲突，这时需要解决冲突，解决完了以后，切记！！！要 add 和 commit 一次，注释为 解决冲突 ，因为解决冲突后处于 modified 状态的，提交后就算合并成功了 解决冲突合并后，并不意味着 master 和 dev 的所有都一样了？，master 上会比 dev 多出 修改了但没有和 dev 冲突的部分? 将 dev 与 master 合并了一次以后，如果 dev 再不更改，即便 master 更改了，再次合并 dev ，也无法合并，会显示 \"already up to date\" "},"知识库/笔记/Git/回到过去 - amend.html":{"url":"知识库/笔记/Git/回到过去 - amend.html","title":"回到过去","keywords":"","body":"回到过去 - amend 如果当前处于刚 commit change2.1 后的状态，想回到 change2.1 前进行修改，重新进行一次change2.1的提交 这时，直接做你要做的修改，比如，重新新建了一个文件 2.py，然后使用 git add 2.py , 再使用git commit --amend --no-edit，这时去 git log --oneline 查看提交历史，发现最后一次提交还是 change2.1，只是前面的commit id 变了 "},"知识库/笔记/Git/回到过去 - reset.html":{"url":"知识库/笔记/Git/回到过去 - reset.html","title":"reset","keywords":"","body":"回到过去 - reset 【在 commit 和 commit 之间来回穿梭】 当前处于修改了 1.py ，刚 git add 1.py 后的 staged 状态，还没有 commit，但是我后悔刚才 git add 了，不想过早地处于 stage 状态，想返回到 staged 前的 modified 状态去继续进行修改。 使用 git reset 1.py ，就重新回到 modified unstaged 状态了，相当于之前没有 git add 1.py 当前还处于上述当前处于修改了 1.py ，刚 git add 1.py 后的 staged 状态，还没有 commit，但是我后悔刚才 git add 了，不想过早地处于 stage 状态，想返回到 staged 前的 modified 状态去继续进行修改 状态，我可以用 git reset --hard HEAD 回到最后一次 commit 后的 clean 状态，相当于最后一次 change 2.1 的提交后，我啥都没干，即舍弃了从那之后的所有更改 HEAD 指针在哪，当前文件夹中的文件就处于哪个时代，意味着我们就可以在哪个时代进行编辑和修改，master 指的是 git reset --hard HEAD 就相当于回到了上次提交后的状态，从那之后我啥都没干 git reset --hard HEAD git reset --hard HEAD 回到最后一次(上一次)提交，将 HEAD 指针放到最后一次 commit id 的头顶，当前文件夹中的文件处于刚进行了最后一次 commit 后的时代，从那时起啥都没弄 git reset --hard HEAD^ 回到倒数第二次(上上次)提交 git reset --hard HEAD^^ 或者git reset --hard HEAD~2 回到倒数第三次(上上上次)提交 git reset --hard 4077e4e 即使用 commit id 回到 commit id 那一次刚提交后的状态 通过 reset 回到过去某次提交3edb后，git log --oneline 就会发现3edb提交后的所有提交都不见了 这时如果想又回到未来，需要使用 git reflog 通过查看每一步 HEAD 的移动变化，找到未来的那次提交的 commit id， 在通过 git reset --hard commitid 的方法回到未来。 "},"知识库/笔记/Git/回到过去 - checkout.html":{"url":"知识库/笔记/Git/回到过去 - checkout.html","title":"checkout","keywords":"","body":"回到过去 - checkout 【单个文件和单个文件之间穿梭】 git checkout 要回到的commit id -- 单个文件 git checkout 3a2fc25 -- 1.py 将 1.py 文件穿梭到了 3a2fc25 这次刚 commit 后的时代，而 3a2fc25 到未来最后一次 commit 之间的数据就没有了呢！ 然后在那里进行修改，修改完后 add，再 commit，这样就又重新回到了未来，这时 1.py 就保持了此次 commit 后的状态，其它的文件都处于未来没有变 checkout 还可以在 branch 分支 之间来回穿梭 "},"知识库/笔记/Git/回到过去 - rebase.html":{"url":"知识库/笔记/Git/回到过去 - rebase.html","title":"rebase","keywords":"","body":"rebase branchB 是主分支，branch A 是基于 branchB 的 C1 (也就是以C1为base)的，在从 c1 处创建 branchA 以后，branch 经过两次提交 C2 和 C4 修复了两个 bug，这时 branchA 也想有 C2和C4 去修改那两个bug，但是依然保留自己从创建分支一直到现在的提交 C3。相当于把 branchB 上的 C2 和 C4 插入 branch A 上的 C1 和 C3 之间。 以 rebase master 为例【危险，因为会修改 master 的 commit 历史】 切换到要被 rebase 的分支，比如 master git rebase dev branch A 指的是 从 dev 分支被创建的 那次提交 C1 开始，将 master 上的 C1 后的提交 C3 先分离出来 把 C2 和 C4 合并到 branch A【已没有C3】 上来【这时没有冲突】，把 C3 最后再拿回来，合并到 branch A 上【此时会有冲突】 解决冲突 冲突就是 C2 和 C4 与 C3 的冲突，解决冲突 git add . 【mark them as resolved】 完成 rebase git rebase --continue 完成【就相当于把 dev 上的 C2 和 C4 插入到了 master 的 C1 和 C3 之间，但是此时的 C3已非之前的 C3， commit id 已经和之前的不同】 或者 git rebase --skip 【skip this commit】 git rebase --abort 【To abort and get back to the state before \"git rebase\"】 "},"知识库/笔记/Git/Stash 暂存.html":{"url":"知识库/笔记/Git/Stash 暂存.html","title":"Stash 暂存","keywords":"","body":" Stash 暂存 临时修改 场景 Stash 暂存 临时修改 场景 正在 devlop 分支写代码，所以当前 git 状态为 modified 突然接到 boss 电话，master 上需要新加几行代码，因为你现在的 modified 状态，你无法切回 master，所以只能 commit 或者 stash，但你的代码还不能 commit，所以就只能 暂存 stash 了 暂存前，先 git status -s 下看看 git stash 暂存 暂存完毕后，可再 git status -s 下看看 然后切到 master，创建一个 boss 分支，在此分支上写上 boss 的代码，然后提交，并把 boss 合并到 master，这样 boss 的任务就完成了，删除 boss 分支。 重新切回 develop ，取回暂存的代码，重新继续工作，就像一切没有发生过一样 取回暂存前，先 git status -s 下看看 git stash pop 取回暂存 取回暂存后，再 git status -s 下看看 "},"知识库/笔记/Git/查看更改前后不同.html":{"url":"知识库/笔记/Git/查看更改前后不同.html","title":"查看更改前后不同","keywords":"","body":"查看更改前后不同 git diff 【查看unstaged (modified)状态下异同】 查看当前文件 modified 之后 和 之前 的对比，也就是和上次 commit 完之后的对比 但是必须是在被 git add 之前，也就是处于 unstage 的状态，才能查看修改前后的对比 git diff --cached【查看staged状态下异同】 当文件已经处于 staged 状态时，用此命令查看 当前 staged 的状态和上一次 commit 的转态的对比 git diff HEAD 【查看当前文件所有状态下的不同，包括 staged 和 modified(属于unstaged)】 当一个文件有两个状态时，传入 HEAD 参数查看所有不同 当文件已经处于 staged 状态，但还没有被 commit 前，又进行了 modify，这时它就有 两个状态 MM，一个绿M是 staged 状态, 一个红M是 unstaged 中的 modified 状态 此时，如果用 git diff --cache 参数查看的话，只会显示绿M staged 的状态的异同 此时，如果用 git diff 查看，只会显示最后修改后的 unstaged 的异同 此时如果 git commit 的话，只会将 绿M 状态，也就是处于 staged 转态的更改提交 而处于 红M，也就是 modified 状态的更改依然需要 git add 后才能提交 如果提交以后，git diff 的所有命令都不起作用了 "},"知识库/笔记/Git/本地仓库与远程仓库.html":{"url":"知识库/笔记/Git/本地仓库与远程仓库.html","title":"本地仓库与远程仓库","keywords":"","body":" 本地仓库与远程仓库 Git 本地项目添加多个远程仓库，推送到指定仓库 本地仓库与远程仓库 origin 就代表 远程仓库源 将远程仓库项目下载到当前文件夹 git clone https://github.com/JoyaWang/VocKit.git 查看当前仓库的远程仓库URL git remote -v 为本地项目添加远程仓库 将本地的项目与github上的仓库连接起来 git remote add origin https://github.com/JoyaWang/VocKit.git git remote rm origin 取消与远程仓库的关联 git branch -a 查看所有分支，包括远程仓库的，git branch貌似只能查看本地的 推送到远程源仓库 将本地项目推送到远程源仓库的 master 分支 git push -u origin master 将本地项目推送到远程源仓库 develp 分支 git push -u origin develop 用远程源仓库的代码更新本地仓库代码 git pull origin master 用远程仓库 master 分支更新本地仓库 当前所在分支 会将代码直接合并，造成冲突等无法知道 git fetch origin master:branch2 等价于 git fetch origin :branch2 使用远程 master 分支在本地创建 branch2 (但不会切换到该分支), 如果本地不存在 branch2 分支, 则会自动创建一个新的 branch2 分支, 如果本地存在 branch2 分支, 并且是`fast forward', 则自动合并两个分支, 否则, 会阻止以上操作. Git 本地项目添加多个远程仓库，推送到指定仓库 本地项目添加多个远程仓库 第一种方式： 添加一个远程库 名字不能是origin git remote add 17MOX http://git.17byh.com/17MOX/mxhy.git 查看远程库及地址 git remote -v 拉，推 git pull 17MOX 远程分支名：本地分支名 git push 17MOx 本地分支名：远程分支名 第二种方式：（好处是，推送时，可以同时推送到另外一个库） 添加另外一个远程库 git remote set-url --add origin git@gitlab.com:mzc/DIVIDE_PKG.git 推送 git remote -v git push origin master:master 取消本地目录下关联的远程库 git remote remove origin 将本地项目推送到指定仓库 git push git push git@gitee.com:joyawang/jewelry_shopping_mall.git master 应该这样 git push A master "},"知识库/笔记/Git/修改注释.html":{"url":"知识库/笔记/Git/修改注释.html","title":"修改注释","keywords":"","body":" 修改注释 修改最后一次提交的注释 修改之前某次提交的注释 修改之前的某几次注释 修改注释 修改最后一次提交的注释 如果你只想修改最后一次注释（就是最新的一次提交），那好办：git commit --amend, 出现有注释的界面（你的注释应该显示在第一行）， 输入i进入修改模式，修改好注释后，按Esc键 退出编辑模式，输入:wq保存并退出。ok，修改完成。 修改之前某次提交的注释 其实这个原理我的理解就是先版本回退到你想修改的某次版本，然后修改当前的commit注释，然后再回到本地最新的版本 注：不能使用 reset 或 checkout 回退修改注释 输入：git rebase -i HEAD~2 最后的数字2指的是显示到倒数第几次 比如这个输入的2就会显示倒数的两次注释（最上面两行） 你想修改哪条注释, 就把哪条注释前面的pick换成edit【不在这里修改注释】 使用Vim方法编辑并保存: i---编辑，把pick换成edit---Esc---:wq git commit --amend【这个命令后修改注释】 输入上面的命令后，就会用Vim打开注释文本，直接在里面修改注释并保存退出 git rebase --continue【完成注释修改】 修改之前的某几次注释 修改多次的注释其实步骤和上面的一样，不同点在于： 1.同上 2.你可以将多个想修改的commit注释前面的pick换成edit 3.依次修改你的注释（顺序是从旧到新），Terminal基本都会提示你接下来的操作，每修改一个注释都要重复上面的3和4步，直到修改完你所选择的所有注释 已经将代码push到远程仓库 首先，你把最新的版本从远程仓库先pull下来，修改的方法都如上，最后修改完成后，强制push到远程仓库： git push --force origin master 注：很重要的一点是，你最好保证在你强制push之前没有人提交代码，如果在你push之前有人提交了新的代码到远程仓库，然后你又强制push，那么会被你的强制更新覆盖！！！ 最后，可以检查一下远程的提交记录~~ "},"知识库/笔记/Git/Git设置代理.html":{"url":"知识库/笔记/Git/Git设置代理.html","title":"Git 设置代理","keywords":"","body":" Git设置代理 Git设置代理 Git查看代理 Git取消代理 Git设置代理 Git设置代理 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 为github设置代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 Git查看代理 查看github的代理 git config --global --get http.https://github.com.proxy git config --global --get http.proxy git config --global --get https.proxy Git取消代理 取消github的代理 git config --global --unset http.https://github.com.proxy git config --global --unset http.proxy git config --global --unset https.proxy export http_proxy=socks5://127.0.0.1:1080 export http_proxy=\"http://127.0.0.1:1080\" export https_proxy=\"http://127.0.0.1:1080\" "},"知识库/笔记/Git/gitignore.html":{"url":"知识库/笔记/Git/gitignore.html","title":"gitignore","keywords":"","body":" gitignore 在项目开始时添加 gitignore 文件的步骤 如果在添加 gitignore 之前，某文件如 UserInterfaceState.xcuserstate 已被Git管理，需要做如下步骤使 gitignore 生效【试着效果不好?】 gitignore 在项目开始时添加 gitignore 文件的步骤 创建项目并生成项目文件夹 在 git init 之前把 .gitignore 文件拖到项目文件夹【要和.git文件夹在同级文件夹】 从 Github 搜索 gitignore，下载 Swift.gitignore 将 Swift.gitignore 重命名为 .gitignore【好像是必须的】 在项目文件夹根目录 git init，会在此文件夹生成 .git 文件夹 # 从 Github 下载的默认的 gitignore 应该就是可以的了，以下这些仅做解释，不必往里面添加 #忽略所有包含xcuserdata的文件(夹) xcuserdata #忽略所有以.xcuserstate结尾的文件 *.xcuserstate #忽略所有文件夹中后缀是.DS_Store的文件 .DS_Store 如果在添加 gitignore 之前，某文件如 UserInterfaceState.xcuserstate 已被Git管理，需要做如下步骤使 gitignore 生效【试着效果不好?】 从被 Git 管理的文件目录中删除此文件 git rm --cached 项目名.xcodeproj/project.xcworkspace/xcuserdata/joyawang.xcuserdatad/UserInterfaceState.xcuserstate git rm -r --cached . // 删除本地缓存【貌似】 git rm --cached CoreData\\ -\\ 旧.xcodeproj/project.xcworkspace/xcuserdata/joyawang.xcuserdatad/UserInterfaceState.xcuserstate 提交这次更改 git commit -m \"Removed file that shouldn't be tracked\" 暂时不知有什么用 # WARNING first try git clean -f -d --dry-run, otherwise you may lose uncommited changes. #Then: git clean -f -d "},"知识库/笔记/CocoaPods/CocoaPods.html":{"url":"知识库/笔记/CocoaPods/CocoaPods.html","title":"CocoaPods","keywords":"","body":" CocoaPods 用CocoaPods做iOS程序的依赖管理 安装 管理第三方框架 卸载 CocoaPods 用CocoaPods做iOS程序的依赖管理 用CocoaPods做iOS程序的依赖管理 唐巧的博客 安装 先安装ruby运行环境 查看当前 Ruby 源地址 gem source -l 添加 ruby 源 gem sources -a https://gems.ruby-china.com 两个源 https://rubygems.org/ https://gems.ruby-china.com 设置源 sudo gem sources -a https://ruby.taobao.org 删除源 sudo gem sources -r https://rubygems.org/ 删除ruby源 gem sources --remove http://gems.ruby-china.org/ 查看 ruby 版本 ruby -v 升级gem sudo gem update --system 安装CocoaPod sudo gem install cocoapods pod setup sudo gem install -n /usr/local/bin cocoapods 更新 cocoapods sudo gem update cocoapods 查看最新的 cocoapods 版本 gem search cocoapods 查看当前 Cocoapods 的版本pod --version 查看当前项目所安装的所有 Pods 的版本 cat Podfile.lock 管理第三方框架 CocoaPods使用 搜索 pod search SDWebImage 搜索pod search afnetworking --simple 切换到项目的根目录 echo \"pod 'SDWebImage'\" > Podfile 【会把pod 'SDWebImage'添加到pod文件中】 安装 pod install 升级 pod update 删除某框架 从 podfile 中删除，然后 pod install? pod deintegrate 更新pod pod install 同步其他团队成员的修改时，请使用pod install。 注意，pod outdated和pod update都会更新spec仓库，但是pod install不会，所以对于经常使用的pod库，建议经常pod outdated关注更新情况。 pod outdated需要更新依赖库时，先使用pod outdated查看有哪些库有更新，再使用pod update PODNAME有目的的更新指定库 pod update PODNAME 将某个pod库更新到最新版本时 pod update更新所有(Podfile中标明的)pods 效果1：等价于对所有pod库执行一遍pod update PODNAME。 效果2：若有pod库的版本发生变更，则会更新Podfile.lock文件记录当前本地库的状态。 不推荐的原因是所有库只要有新版本，都会发生更新，有可能导致整个工程变得不稳定；另外，由于每个团队成员执行该命令的时间不一样，一旦中间有某个依赖库发布了新版本，这将导致团队内不同成员获得的pod库代码并不相同。 卸载 完全卸载 CocoaPods，删除其主库后重新安装【已测试，很强大，会重新下载主库，一定要使用代理】 rm -rf ~/.cocoapods sudo gem install cocoapods git config --global http.https://github.com.proxy [socks5://127.0.0.1:1080](socks5://127.0.0.1:1080)在终端为 github 设置代理 卸载Cocoapods 【感觉没起什么作用】 sudo gem uninstall cocoapods 更新cocoapods的主库 pod repo update 对主库进行操作，没有尝试成功！ pod repo remove master 如果没有master, 创建 repos 的 master, 并拉取 cd ~/.cocoapods/repos/master git pull git clone --depth=1 https://github.com/CocoaPods/Specs.git "},"知识库/笔记/CocoaPods/pod install, pod update, podfile, podfile.lock.html":{"url":"知识库/笔记/CocoaPods/pod install, pod update, podfile, podfile.lock.html","title":"pod install, pod update, podfile, podfile.lock","keywords":"","body":" pod install, pod update, podfile, podfile.lock, 版本号控制 一、pod install VS pod update 1 pod install 的使用场景： 2 pod update 的使用场景： 3 正确的使用方法 二、对于版本号的控制 pod install, pod update, podfile, podfile.lock, 版本号控制 一、pod install VS pod update 1 pod install 的使用场景： 1.1 新创建工程，第一次引入pod库时。 效果1：此时会按照Podfile中给出的约束条件下载所需要的pod库，获得符合约束条件的最新版本。 效果2：将创建Podfile.lock文件，记录当前使用的所有pod库和版本。 效果3：同时也会创建Pods.xcodeproj和.xcworkspace，不过这不是主要功能。 1.2 修改了Podfile文件，添加或删除了所依赖的pod库时。 效果1：建议此时一定要使用pod install获取新的pod库或删除不要的pod库，若使用pod update其他库也会受到影响。 效果2：Podfile.lock会做相应的修改，记录当前使用的所有pod库和版本。 效果3：对于Podfile.lock中已有记录的其他pod库不会发生任何变化，不去检查是否有更新版本，即使有新的可用版本也不会更新。 1.3 新人加入团队，拉取了主工程之后要获取pod库时。 效果1：按照Podfile文件中的依赖关系获取pod库。 效果2：在满足Podfile文件的情况下，直接获取Podfile.lock中记录的pod库的对应版本，并不去检查是否有更新版本。因此，即使有新的可用版本也会仅获取Podfile.lock中的版本。 1.4 团队合作中，不同开发者之间要同步对pod库的依赖时。 效果1：有人改变依赖关系，修改了Podfile文件时，情况与见场景2相同。 效果2：Podfile文件未变化，但是有人执行了pod update导致Podfile.lock文件发生修改时，pod install会同步获取Podfile.lock中指定的pod库版本，而不是最新的版本。 效果3：如果Podfile与Podfile.lock的记述相冲突，如指定了低于Podfile.lock中记录的版本，会以Podfile为准，并在获取完成后更新Podfile.lock文件。 2 pod update 的使用场景： 2.1 需要将某个pod库更新到最新版本时，使用pod update PODNAME 效果1：检查指定pod库的最新版本，若最新版本满足Podfile中的约束，则更新到最新版本。 效果2：若最新版本不满足Podfile中的约束，则更新到满足约束的最高版本。 效果3：pod update命令不会检查Podfile.lock文件，即使其中有记录也是无效的。 效果4：若Podfile文件已发生变更，pod update命令也会将本地pod库更新为符合Podfile文件的版本（不建议这么做，因为非指定PODNAME的pod库也可能被改动，此处仅写明有此效果而已）。 效果5：若有pod库的版本发生变更，指定pod库版本变化、其他pod库由于Podfile的改动而发生变化、甚至因为Podfile的改动而被移除，都会更新Podfile.lock文件记录当前本地库的状态。 效果6：由于要检查pod库的新版本，会先拉取所有源的podspec文件，第一次做这件事将是个超级费时的操作。 2.2 超级懒人爱做，而官网极其不推荐的做法，直接使用pod update 效果1：等价于对所有pod库执行一遍pod update PODNAME。 效果2：若有pod库的版本发生变更，则会更新Podfile.lock文件记录当前本地库的状态。 不推荐的原因是所有库只要有新版本，都会发生更新，有可能导致整个工程变得不稳定；另外，由于每个团队成员执行该命令的时间不一样，一旦中间有某个依赖库发布了新版本，这将导致团队内不同成员获得的pod库代码并不相同。 3 正确的使用方法 根据这两个命令的功能差异，以及CocoaPods官网的建议，我总结它们的正确用法是： 第一次获取pod库时，应使用pod install。 需要更新依赖库时，先使用pod outdated查看有哪些库有更新，再使用pod update PODNAME有目的的更新指定库。 提交代码时，请注意一定同时提交Podfile.lock文件，以便其他人能同步到与你相同的pod库版本。 同步其他团队成员的修改时，请使用pod install。 注意，pod outdated和pod update都会更新spec仓库，但是pod install不会，所以对于经常使用的pod库，建议经常pod outdated关注更新情况。 官网提到的：为什么直接在Podfile文件中指定版本的方法不够用？ 原因是你所依赖的库可能还依赖于其他的库。 如果指定pod A的版本（如在Podfile中指定pod 'A', '1.0.0'），但是pod A依赖于pod A2（通过在A.podspec中的dependency 'A2', '~> 3.0'声明）。在这种情况下，Podfile的确会强制所有用户使用pod A的1.0.0版本，但是，用户1可能会使用A2的3.4版本，而在这之后A2有新版发布，若无Podfile.lock的帮助，用户2无论使用pod install还是pod update都不可避免的会使用A2的3.5版本。 一般情况下pod A对pod A2依赖关系你是不可见的，或者并不由你维护的。所以，直接在Podfile文件中指定版本的方法并不能保证所有用户都使用相同版本的pod库。 除非你的工程所依赖的所有pod库在对其他库进行依赖时也都采用指定版本的方法，而这只有在所有pod库都由你来维护时才能够得到保证。 二、对于版本号的控制 pod ‘AFNetworking’ //不指定依赖库版本，表示每次都获取最新版本 pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本 pod ‘AFNetworking’, ‘> 2.0’ //使用高于2.0的版本 pod ‘AFNetworking’, ‘>= 2.0’ //使用大于或等于2.0的版本 pod ‘AFNetworking’, ‘ 0.1.2’ //使用大于等于0.1.2但小于0.2的版本 pod ‘AFNetworking’, ‘~>0.1’ //使用大于等于0.1但小于1.0的版本 pod ‘AFNetworking’, ‘~>0’ //高于0的版本，写这个限制与什么都不写是同样效果，皆表示使用最新版本 作者：彭磊PL 链接：https://www.jianshu.com/p/118bbfba5c23 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 "},"知识库/笔记/CocoaPods/Cocoapods 发布框架.html":{"url":"知识库/笔记/CocoaPods/Cocoapods 发布框架.html","title":"Cocoapods 发布框架","keywords":"","body":" Cocoapods 发布框架 发布框架 Cocoapods 发布框架 发布框架 注册 pod trunk register xxx@gmail.com \"我的名字\" 查询 pod 注册信息 pod trunk me 生成 spec 文件 pod spec create https://github.com/liufan321/FFFirst 编辑 podspec 文件 验证 spec 文件 pod spec lint pod spec lint --verbose 推送 pod trunk push "},"知识库/笔记/Gitbook/Gitbook.html":{"url":"知识库/笔记/Gitbook/Gitbook.html","title":"GItbook","keywords":"","body":"Gitbook 在电脑上创建一个存储 Book 的文件夹 初始化项目 gitbook init 生成 \"README.md\" 和 \"SUMMARY.md\" 两个基本文件 README.md SUMMARY.md 总目录框架 可以在里面搭建好目录后，再 gitbook init, 会生成没有的的文件夹和文件 在md文件中创作 在本地服务器上查看电子书预览 gitbook serve 首先调用 gitbook build编译书籍，完成以后会打开一个 web 服务器，监听本地 4000 端口，在浏览器中输入http://localhost:4000，即可打开电子书。 生成电子书 gitbook build 该命令会在当前文件夹中生成_book文件夹，里面是 html 版本的电子书 插件 expandable-chapters 配置目录折叠功能如下 chapter-fold 导航目录折叠 page-toc-button 悬浮目录 貌似没起作用 back-to-top-button 回到顶部 lightbox 单击查看图片 custom-favicon 修改标题栏图标 splitter 侧边栏宽度可调节 tbfed-pagefooter 页面添加页脚 search-pro 高级搜索（支持中文） page-treeview 生成页内目录 必须用不同的标题字体才可以，挺有用 删除版权信息 大约43行，在generateContent方法定义中，该方法的返回值 return renderContent ? `${copyRight + renderContent}` : ''; // 改成： return renderContent; 在 node_modules 中全部删除 在 book.json 配置好 最后重新 gitbook install 即可 "},"知识库/笔记/Gitbook/Github Pages.html":{"url":"知识库/笔记/Gitbook/Github Pages.html","title":"Github Pages","keywords":"","body":"Github Pages Github Pages 功能介绍 首先，必须在 Github 创建一个 joyawang.github.io 为名的仓库(Repository)【只能创建一个?】用来当做Github Pages https://joyawang.github.io/ 的主页 在此仓库的设置界面找到 Github Pages 选项， 就可以设置主页的网页内容来源了，默认从此仓库的 master 分支加载 index.html 文件 从现在开始，Github 任何一个仓库都可以在 https://joyawang.github.io/ 上托管页面 在 Github 创建一个 ThinkTank 仓库，在设置界面找到 Github Pages，将来源选为 master 分支的 /docs 文件夹【也可选其他方式】 这样，https://joyawang.github.io/ThinkTank 就会从 ThinkTank 仓库 master 分支的 docs 文件夹加载 index.html 文件。 所以，只要将你生成的书的 html 文件实时上传到 ThinkTank 仓库 master 分支的 docs 文件夹，你就可以从 https://joyawang.github.io/ThinkTank 访问你的书内容了 GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 第一种方式 在生成静态网页时，将保存的目录指定为 ./docs【gitbook build会替换原来的_book文件夹，所以每次生成到./docs文件夹，让gitpages从那加载】 $ gitbook build ./ ./docs 然后 git add . 并且 git commit 提交 最后推送到 GitHub 仓库，更新 master 上的 /docs 文件夹中的内容 $ git push origin master 第二种方式 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。【gitbook build会替换原来的_book文件夹，所以每次上传的时候，也用最新的_books文件夹完全覆盖gh-pages】 $ git subtree push --prefix=_book origin gh-pages "},"知识库/笔记/Unix & Linux & Mac/终端命令 Unix_Linux 命令.html":{"url":"知识库/笔记/Unix & Linux & Mac/终端命令 Unix_Linux 命令.html","title":"终端命令 Unix_Linux 命令.md","keywords":"","body":" 终端命令 Unix / Linux Command 编辑 终止、退出 查看IP 清屏 目录/文件夹 目录快捷键 查看目录和切换目录 查看目录下的文件和文件夹 新建、删除、复制文件夹和文件 文件权限查看、更改 创建用户组、用户 终端命令 Unix / Linux Command 提权 sudo super user do 编辑 终端 control + u 删除一行命令 终止、退出 暂停终端当前运行的进程 Control z 强制退出终端 Command q 强制退出系统当前运行的某程序 killall WeChat 退出 man 手册 q 终止终端当前运行的进程 Control c cancel the running process 查看IP 查看 IP 地址 ifconfig en0 wifi地址; en1 ethernet 查看局域网所有设备 arp -a 查看本机与某 IP 地址的机器是否连通 ping 查看本机到目的地 IP 之间经过多少路由器 traceroute www.baidu.com 清屏 Control l(L) Command k 语音朗读 say hi 反射、重复、回声: echo \"求知若渴，虚心若愚\" 目录/文件夹 目录快捷键 根目录 / root directory 当前工作目录 . 当前工作目录的根目录 ./ 比如 ./a.out 就是当前文件夹中的 a.out 文件 家目录、当前用户的根目录 ~ 家目录的根目录 ~/ 查看目录和切换目录 查看当前在哪个目录 pwd print working directory 切换到某个目录cd /Users/joyawang/Desktop 切换到上一级文件夹 cd .. 切换到家目录 cd 切换到根目录 cd / 查看目录下的文件和文件夹 查看当前文件夹下所有文件和文件夹 ls List 查看当前文件夹下所有文件和文件夹(包含隐藏文件) ls -a 查看(详细)当前文件夹下所有文件和文件夹以及权限 ls -l 查看(详细)当前文件夹下所有文件和文件夹(包含隐藏文件)以及权限 ls -al 新建、删除、复制文件夹和文件 新建文件夹(在当前目录) mkdir newdirectoryname 删除文件夹 rmdir directoryname 新建文件 touch 删除文件 rm a.txt 复制文件 cp ~/Desktop/MyFile.rtf ~/Documents 复制文件 cp -R froshims0 froshims1 within same working directory, copy froshims0 directory and paste and rename to froshims1 within same directory 复制文件夹及其中所有内容 cp -R ~/Desktop/MyFolder /Documents 查看文件内容 cat a.txt 查看文件内容(分页) more a.txt (f,b) Forward下 一页和backword上一页 比较两个文件 diff Compares two files line by line (assumes text). 文件权限查看、更改 更改文件权限 chmod change file modes or Access Control Lists 更改文件 所有者 和 所有组 chown change file owner and group sudo chown -R acme:acme /usr/local/etc/certfiles chown 更改文件的所有者 -R 处理指定目录以及其子目录下的所有文件 acme 新的文件所有者ID :acme 新的文件所有者的所属组(group) /usr/local/etc/certfiles 要更改的文件 更改文件 属组 chgrp -- change group 创建用户组、用户 创建用户组 sudo groupadd certusers certusers 申请到证书后将证书所有权交给此用户组 允许此组内用户访问证书 创建用户 trojan sudo useradd -r -M -G certusers trojan -r 系统用户 -M 无需登录 无需家目录 -G certusers 加入群组 acme sudo useradd -r -m -G certusers acme -r 系统用户 -m 需要家目录 未设置密码，不能登录，只能通过其他已经登录的用户切换过去 需要读写证书文件，添加到用户组 certusers -G certusers -g 　指定用户所属的群组。 -G 　指定用户所属的附加群组。 -m 　自动建立用户的登入目录。 -M 　不要自动建立用户的登入目录。 -n 　取消建立以用户名称为名的群组． -r 　建立系统帐号。 在终端运行的程序 Git, Cocoa Pods, Trojan, Nginx, apache, Home brew, Vim "},"知识库/笔记/Unix & Linux & Mac/Unix_Linux 文件基本属性.html":{"url":"知识库/笔记/Unix & Linux & Mac/Unix_Linux 文件基本属性.html","title":"Unix_Linux 文件基本属性","keywords":"","body":"更改文件属主 chown 更改文件属组 chgrp 更改文件 9 个属性 chmod 某个用户对这个文件的权限的修改 chmod u=rwx,g=rx,o=r test1 即将 test1 文件权限修改为 -rwxr-xr-- u user g group o others "},"知识库/笔记/Vim.html":{"url":"知识库/笔记/Vim.html","title":"Vim","keywords":"","body":" Vim pacvim 游戏 Vim 打开文件 sudo vim httpd-dav.conf 搜索 / :/ 别管光标位置，直接输入命令行:/httpd-dav.conf （因为现在并非编辑状态，\"/\"代表搜索的意思），然后回车，光标自动跳到那个位置 将光标移动到行首 0 将光标移动到行尾 $ 进入编辑状态 i： 退出编辑状态 esc 方向 左 h 下 j 上 k 右 l 退出 必须按 Esc，处于非编辑状态后，输入下面的指令才会起作用 保存并退出 :wq 不保存退出 :qa q pacvim 游戏 pacvim [LEVEL_NUMBER] [MODE] 上述代码中的 LEVELNumber 取值范围为 0 - 9，数字越大，难度越高。 Mode 可选 N 或 H，N 表示 Normal ，正常难度；H 则表示 Hard ，困难。 pacvim 8 n "}}