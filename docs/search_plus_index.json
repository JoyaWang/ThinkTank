{"./":{"url":"./","title":"前言","keywords":"","body":" Introduction iOS 必备知识 内存管理 Block 多线程 Runtime Runloop 第三方库的源码 生命周期 UI 数据存储 架构 OC 语言特性 其他 必备书单 通用必备基础知识 计算机网络 算法 数据结构 编译原理 操作系统 数据库 设计模式 概率论 Linux 版本控制 通用语言基础 Introduction iOS 必备知识 内存管理 ARC 和 MRC 的区别 属性的关键字，他们具体的底层实现以及区别，被问烂的知识点包括 copy， 浅拷贝和深拷贝的区别， weak 的底层实现。稍微新颖一点的 assgin 和 weak，unsafe_unretained 具体有什么区别，assgin是否可以用来修饰对象。这一部分是面试必问，一定要弄懂。 Autorelease pool的底层实现原理，与 Runloop 的关系， autoreleasing 关键字。 Block 本质，基础概念 使用时要注意的地方 block的实现，如何截获自动变量的，如何修改自动变量的值的，block的几种形式 __block的本质 forwarding 指针 block怎么避免循环引用。是不是所有的block都会产生循环引用，block里面怎么避免被提前释放 多线程 iOS 中多线程的几种方式，区别，使用场景，基本概念，同步异步，串行并行的区别。 GCD，写一个死锁，并行和串行队列，同步和异步的区别，GCD怎么控制最大并发数 怎么让子线程定时执行一个方法，具体的实现方法 如何控制线程的最大并发数为10，然后加载十个图片最后展示出来，具体方法 子线程的runloop是怎么执行的，它里面的 autoreleasepool 是怎么执行的。 NSMutableArray 怎么保证线程安全的。 GCD怎么避免block中的变量被提前释放 Runtime 消息的动态转发 给 Category 添加属性，关联对象都有几种形式 method swizzling 说一说类的结构，运行时中的class都有什么属性，property都有什么属性 说一说isa指到NSObject的那个过程 Category的本质，load方法什么时候加载，Category重写了父类的方*怎样，底层源码 ，如果两个Category和一个基类，都有同名方法，先执行哪个 property会自动生成什么，如果此时已经有下划线_name的实例变量了那会生成什么 load 和 initialize Runloop runloop实现原理 source 类型 线程保活的方式 runloop和多线程的关系，以及timer的关系 第三方库的源码 生命周期 app 的声生命周期 控制器的生命周期 视图的生命周期 UI UICellectionView 瀑布流 UITableView 相关的优化，底层原理等 页面布局 layoutSubviews 和 drawRect 等的区别 自己实现一个 UIScrollView 事件的传递链和响应链 界面非常卡顿怎么定位到具体的类和方法 UIView 和 CALayer 区别 数据存储 数据持久化都有什么，用过什么，归档，偏好设置都可以存储什么类型 架构 MVC、MVVM 从 0 到 1 实现一个 app 的思路 对于项目从 main 函数执行之前到之后启动优化，卡顿优化和界面优化 OC 语言特性 OC 和 C 的区别， OC 和 Java、C++ 的区别 iOS 中的协议 OC 动态性 C 语言如何动态的交换两个方法的实现 其他 KVO 的底层原理，自己实现 KVC 的底层原理，自己实现 NSNotification 的底层原理，是同步还是一部，如何实现一个，如果在子线程接收一个通知能不能接收到 几种页面传值方式的区别 界面非常卡顿怎么定位到具体的类和方法 一个 int 类型的值，被 @ 包装成 NSNumber 类型，传递到一个接受 id 类型的方法参数中，这个值能不能保持正确 在 iPad 上面，分屏功能，拖拽 wps 的文件到 qq 的过程是怎么实现的 (进程间通信的方法) 如何实现 dispatch_once Instrument 的使用 热修复用过吗，平时版本怎么迭代，线上 bug 怎么修复？ 必备书单 ​ 图解 TCP/IP, 图解 HTTP ​ 剑指offer ​ Effective Objective-C ​ iOS 与 OSX 高级编程 ​ 以上都是必须要重复看很多遍的书单，其他不太重要的暂不列出 通用必备基础知识 ​ 抛开iOS 开发这一项技能，我们最基础的本质还是一名软件开发工程师，所以基础的部分必不可少，本篇面经中，不会具体总结出每个公司每一面具体考的内容，而是会根据不同的知识点将面试真题分为不同的专题部分来具体分析。 计算机网络 ​ 对于大前端类，计算机网络主要考量的还是传输层和应用层部分的知识。 ​ 浏览器输入url到网页显示经历了什么过程? ​ TCP三次握手：具体是怎么握手？为什么要三次握手？两次行不行？为什么不行？三次握手，第二次和第三次分别因为什么? ​ TCP是如何保持可靠传输的（拥塞控制，慢启动等等概念的理解） ​ TCP为什么要四次挥手，TIME_WAIT为什么至少设置两倍的MSL时间？ ​ TCP三次握手的详细数据传递，四次挥手详细数据内容，数据包组成、TIME_WAIT状态，2MSL，RTT，重传、滑动窗口、拥塞原理等等 ​ TCP、UDP面向连接、无连接具体理解，他们的区别，如何将 UDP 改造成和 TCP 功能相似 ​ TCP/IP四层协议，OSI七层协议，每层都有啥对应的协议，原理是啥 ​ http报文结构，http中超文本超是啥意思，http请求的组成 ​ http 报文头部含有什么，multipart了解吗 ​ http的状态码，200，304，301，http请求报文，响应报文 ​ get和post请求的区别？什么情况下用到？POST传输的数据都有哪些格式呢（这里需要搞定http各种请求传输的数据格式） ​ 描述一次完整的http请求 ​ 什么是cookie，什么是session，区别联系，cookie的本质是什么 ​ http1.0，1.1，2.0的区别 ​ https有几次握手和挥手？https的原理。http有几次挥手和握手？TLS在哪一网络层，基本原理是什么？ ​ https与中间人攻击 ​ HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数 ​ HTTPS是什么？握手过程，SSL原理，非对称加密了解多少 ​ 证书是干什么用的 算法 ​ 剑指 offer 上面的题目都是面试过程中的算法高频题，特别是二叉树和字符串，栈队列，链表，跳台阶问题一定要弄懂并且熟练。 ​ 八大排序算法的复杂度，概念，最好最坏情况，手写都是必须要掌握的，其中的重点是快排和堆排序，对于快排的优化，快排的基础原理，系统 API 快排的实现原理等都是必须要掌握的基础知识。 ​ 二分查找在面试过程中也比较常见，因为比较简单，包括二分查找的变种。 ​ 二叉树的前中后序的递归与非递归遍历方式，以及层序遍历和蛇形遍历都是重点。 ​ 海量数据如何找到重复次数最多的那个 优化 ​ 海量数据，但是都是1~100之间的，如何找到重复次数最多的那个 ​ 面试算法题一般不难，掌握技巧很重要。二叉树相关的算法题基本都要往二叉树的遍历上靠，链表相关的算法题基本都要往额外的“帮助指针”上面靠。 数据结构 ​ 在面试过程中这一类主要是和算法来一起考，数据结构一般主要会问栈与堆的区别，栈与队列的区别等等，在前端的面试中，红黑树这类的很少被问到。 编译原理 ​ 主要需要了解程序的编译过程的基础概念就OK。 操作系统 ​ 操作系统老生常谈的就是进程，线程的概念和区别，几个状态，以及他们的调度方式，通信方式，保持安全等等知识点，基本面试都会被考到一点，这一部分需要牢牢掌握，实在理解不了就背下来。 ​ 说说递归和普通的循环方式有什么区别 ​ 计算机存储系统是指？哪些存储系统能提高程序执行的效率？ ​ 段错误和栈溢出分别在什么时候会出现，为什么 ​ 其他方面的包括页置换等等基础知识，知道概念就OK，在前端面试过程中这部分不是特别重点考量的点。 数据库 ​ 数据库这部分也比较简单，主要就是 ACID 等基础概念，几大范式，简单的 sql 语句。 设计模式 ​ 工厂方法，抽象工厂，简单工厂的区别和联系 ​ 装饰者 ​ 观察者 ​ *模式等等 概率论 ​ 三门问题 ​ 红黑球等等常见问题百度即可 Linux ​ 主要包括基本的 shell 编程，基本的脚本命令，重点是 grep，ps，top，free等 版本控制 ​ 版本控制主要包括 Git 和 SVN ​ git 的基础概念，基本命令，包括 merge 和 rebase 的区别等。 ​ Git 和 SVN 的区别，异同点 ​ 平时开发中，版本控制的流程是怎么样的 通用语言基础 ​ 面向对象的多态。多态的几种方式 ​ 各个语言中的单例模式 ​ 内存管理方式 ​ static 和 const 的作用和区别 ​ C 语言的内存分段 "},"知识库/笔记/Git/Git 基本指令.html":{"url":"知识库/笔记/Git/Git 基本指令.html","title":"Git","keywords":"","body":" Git Git 安装 Git 管理的文件状态 创建 Git 版本库 配置Git 将文件交给 Git 版本库管理 提交更改 查看当前 Git 状态 查看提交历史 回到过去的几种方式 Git Git 安装 Git 官网下载 pkg 安装 Git 管理的文件状态 Stage 状态【Cache】 变绿了，可以被 commit 了 Unstaged 状态 Unmodified 刚 commit 完的状态 Modified 上次 commit 完后，又修改了 创建 Git 版本库 创建本地文件夹 MyProject 在 终端 cd 到 MyProject 文件夹 在 MyProject 目录下创建版本库 git init 生成 .git 文件夹，意味着 MyProject 文件夹已经成为 git 管理的版本库 配置Git git config --list 查看 git 的完整配置信息 git config -l 查看当前 git 的配置 设置 git 管理员信息及查看 管理员名称 git config --global user.name \"Joya\" 邮箱 git config --global user.email \"244092911@qq.com\" 查看 git config user.name git config user.email 将文件交给 Git 版本库管理 比如在 MyProject 文件夹创建自己的文件 1.py，git status 查看当前 MyProject 版本库中文件的状态 新创建的文件必须 git add 1.py ，进入staged 转态，这样才能被 Git 管理，才能被 commit 修改了1.py 以后也要 git add 1.py ，进入 staged 状态，才能被 commit git add 1.py stage 单个文件 git add . stage 所有文件(新建的或者变化了的) 提交更改 git commit -m \"注释\" commit 提交此次修改 git commit -am \"注释\" add 和 commit 同时进行，先 stage，后提交【适用于已经被git管理的文件】 查看当前 Git 状态 git status 查看当前 git 状态 git status -s short 形式显示当前 Git 状态 查看提交历史 git log 查看提交历史 git log --oneline 查看提交历史(每个提交显示一行, 小头版本号) git log --pretty=oneline 每行显示一个commit(大头版本号) git log --oneline --graph 图形显示 回到过去的几种方式 amend【回到最后一次提交前修改】 reset【commit和commit之间穿梭】 checkout【单个文件和单个文件之间穿梭】 rebase【将 branch B 的 commit 插入到 branch A 中】 "},"知识库/笔记/Git/分支及合并 branch & merge.html":{"url":"知识库/笔记/Git/分支及合并 branch & merge.html","title":"分支及合并 branch & merge","keywords":"","body":" 分支及合并 branch & merge 查看所有分支，以及当前所在的分支 创建分支 切换分支 删除分支 创建分支的同时切换分支 合并分支 解决合并过程中的冲突 分支及合并 branch & merge 查看所有分支，以及当前所在的分支 git branch git branch -a 查看所有分支，包括远程仓库的，git branch貌似只能查看本地的 创建分支 【从当前分支，可以是任一分支】创建名为 dev 的分支 git branch dev 切换分支 切换到 dev 分支，将 HEAD 指针放到 dev 分支 git checkout dev 删除分支 删除 dev 分支【只有当前HEAD不在dev分支时才起作用】 git branch -d dev git branch -D boss 创建分支的同时切换分支 【从当前分支，可以是任一分支】创建 dev 分支的同时，切换到 dev 分支 (即将 HEAD 指针放到dev分支) git checkout -b dev 合并分支 先切回主分支 git checkout master git merge dev` 使用 fast forward 方式合并 dev 分支到 master 分支，不添加这次合并的注释信息 git merge --no-ff -m \"合并dev到master\" dev 合并分支，不使用 fast forward 的方式，会添加这次合并的注释。如果 dev 和 master 没有冲突的话就直接成功了 解决合并过程中的冲突 创建了 dev 后，你在 dev 上修改，但同时有人在 master 上修改，当你合并时，就会出现冲突，这时需要解决冲突，解决完了以后，切记！！！要 add 和 commit 一次，注释为 解决冲突 ，因为解决冲突后处于 modified 状态的，提交后就算合并成功了 解决冲突合并后，并不意味着 master 和 dev 的所有都一样了？，master 上会比 dev 多出 修改了但没有和 dev 冲突的部分? 将 dev 与 master 合并了一次以后，如果 dev 再不更改，即便 master 更改了，再次合并 dev ，也无法合并，会显示 \"already up to date\" "},"知识库/笔记/Git/回到过去 - amend.html":{"url":"知识库/笔记/Git/回到过去 - amend.html","title":"回到过去","keywords":"","body":"回到过去 - amend 如果当前处于刚 commit change2.1 后的状态，想回到 change2.1 前进行修改，重新进行一次change2.1的提交 这时，直接做你要做的修改，比如，重新新建了一个文件 2.py，然后使用 git add 2.py , 再使用git commit --amend --no-edit，这时去 git log --oneline 查看提交历史，发现最后一次提交还是 change2.1，只是前面的commit id 变了 "},"知识库/笔记/Git/回到过去 - reset.html":{"url":"知识库/笔记/Git/回到过去 - reset.html","title":"reset","keywords":"","body":"回到过去 - reset 【在 commit 和 commit 之间来回穿梭】 当前处于修改了 1.py ，刚 git add 1.py 后的 staged 状态，还没有 commit，但是我后悔刚才 git add 了，不想过早地处于 stage 状态，想返回到 staged 前的 modified 状态去继续进行修改。 使用 git reset 1.py ，就重新回到 modified unstaged 状态了，相当于之前没有 git add 1.py 当前还处于上述当前处于修改了 1.py ，刚 git add 1.py 后的 staged 状态，还没有 commit，但是我后悔刚才 git add 了，不想过早地处于 stage 状态，想返回到 staged 前的 modified 状态去继续进行修改 状态，我可以用 git reset --hard HEAD 回到最后一次 commit 后的 clean 状态，相当于最后一次 change 2.1 的提交后，我啥都没干，即舍弃了从那之后的所有更改 HEAD 指针在哪，当前文件夹中的文件就处于哪个时代，意味着我们就可以在哪个时代进行编辑和修改，master 指的是 git reset --hard HEAD 就相当于回到了上次提交后的状态，从那之后我啥都没干 git reset --hard HEAD git reset --hard HEAD 回到最后一次(上一次)提交，将 HEAD 指针放到最后一次 commit id 的头顶，当前文件夹中的文件处于刚进行了最后一次 commit 后的时代，从那时起啥都没弄 git reset --hard HEAD^ 回到倒数第二次(上上次)提交 git reset --hard HEAD^^ 或者git reset --hard HEAD~2 回到倒数第三次(上上上次)提交 git reset --hard 4077e4e 即使用 commit id 回到 commit id 那一次刚提交后的状态 通过 reset 回到过去某次提交3edb后，git log --oneline 就会发现3edb提交后的所有提交都不见了 这时如果想又回到未来，需要使用 git reflog 通过查看每一步 HEAD 的移动变化，找到未来的那次提交的 commit id， 在通过 git reset --hard commitid 的方法回到未来。 "},"知识库/笔记/Git/回到过去 - checkout.html":{"url":"知识库/笔记/Git/回到过去 - checkout.html","title":"checkout","keywords":"","body":"回到过去 - checkout 【单个文件和单个文件之间穿梭】 git checkout 要回到的commit id -- 单个文件 git checkout 3a2fc25 -- 1.py 将 1.py 文件穿梭到了 3a2fc25 这次刚 commit 后的时代，而 3a2fc25 到未来最后一次 commit 之间的数据就没有了呢！ 然后在那里进行修改，修改完后 add，再 commit，这样就又重新回到了未来，这时 1.py 就保持了此次 commit 后的状态，其它的文件都处于未来没有变 checkout 还可以在 branch 分支 之间来回穿梭 "},"知识库/笔记/Git/回到过去 - rebase.html":{"url":"知识库/笔记/Git/回到过去 - rebase.html","title":"rebase","keywords":"","body":"rebase branchB 是主分支，branch A 是基于 branchB 的 C1 (也就是以C1为base)的，在从 c1 处创建 branchA 以后，branch 经过两次提交 C2 和 C4 修复了两个 bug，这时 branchA 也想有 C2和C4 去修改那两个bug，但是依然保留自己从创建分支一直到现在的提交 C3。相当于把 branchB 上的 C2 和 C4 插入 branch A 上的 C1 和 C3 之间。 以 rebase master 为例【危险，因为会修改 master 的 commit 历史】 切换到要被 rebase 的分支，比如 master git rebase dev branch A 指的是 从 dev 分支被创建的 那次提交 C1 开始，将 master 上的 C1 后的提交 C3 先分离出来 把 C2 和 C4 合并到 branch A【已没有C3】 上来【这时没有冲突】，把 C3 最后再拿回来，合并到 branch A 上【此时会有冲突】 解决冲突 冲突就是 C2 和 C4 与 C3 的冲突，解决冲突 git add . 【mark them as resolved】 完成 rebase git rebase --continue 完成【就相当于把 dev 上的 C2 和 C4 插入到了 master 的 C1 和 C3 之间，但是此时的 C3已非之前的 C3， commit id 已经和之前的不同】 或者 git rebase --skip 【skip this commit】 git rebase --abort 【To abort and get back to the state before \"git rebase\"】 "},"知识库/笔记/Git/Stash 暂存.html":{"url":"知识库/笔记/Git/Stash 暂存.html","title":"Stash 暂存","keywords":"","body":" Stash 暂存 临时修改 场景 Stash 暂存 临时修改 场景 正在 devlop 分支写代码，所以当前 git 状态为 modified 突然接到 boss 电话，master 上需要新加几行代码，因为你现在的 modified 状态，你无法切回 master，所以只能 commit 或者 stash，但你的代码还不能 commit，所以就只能 暂存 stash 了 暂存前，先 git status -s 下看看 git stash 暂存 暂存完毕后，可再 git status -s 下看看 然后切到 master，创建一个 boss 分支，在此分支上写上 boss 的代码，然后提交，并把 boss 合并到 master，这样 boss 的任务就完成了，删除 boss 分支。 重新切回 develop ，取回暂存的代码，重新继续工作，就像一切没有发生过一样 取回暂存前，先 git status -s 下看看 git stash pop 取回暂存 取回暂存后，再 git status -s 下看看 "},"知识库/笔记/Git/查看更改前后不同.html":{"url":"知识库/笔记/Git/查看更改前后不同.html","title":"查看更改前后不同","keywords":"","body":"查看更改前后不同 git diff 【查看unstaged (modified)状态下异同】 查看当前文件 modified 之后 和 之前 的对比，也就是和上次 commit 完之后的对比 但是必须是在被 git add 之前，也就是处于 unstage 的状态，才能查看修改前后的对比 git diff --cached【查看staged状态下异同】 当文件已经处于 staged 状态时，用此命令查看 当前 staged 的状态和上一次 commit 的转态的对比 git diff HEAD 【查看当前文件所有状态下的不同，包括 staged 和 modified(属于unstaged)】 当一个文件有两个状态时，传入 HEAD 参数查看所有不同 当文件已经处于 staged 状态，但还没有被 commit 前，又进行了 modify，这时它就有 两个状态 MM，一个绿M是 staged 状态, 一个红M是 unstaged 中的 modified 状态 此时，如果用 git diff --cache 参数查看的话，只会显示绿M staged 的状态的异同 此时，如果用 git diff 查看，只会显示最后修改后的 unstaged 的异同 此时如果 git commit 的话，只会将 绿M 状态，也就是处于 staged 转态的更改提交 而处于 红M，也就是 modified 状态的更改依然需要 git add 后才能提交 如果提交以后，git diff 的所有命令都不起作用了 "},"知识库/笔记/Git/本地仓库与远程仓库.html":{"url":"知识库/笔记/Git/本地仓库与远程仓库.html","title":"本地仓库与远程仓库","keywords":"","body":" 本地仓库与远程仓库 Git 本地项目添加多个远程仓库，推送到指定仓库 本地仓库与远程仓库 origin 就代表 远程仓库源 将远程仓库项目下载到当前文件夹 git clone https://github.com/JoyaWang/VocKit.git 查看当前仓库的远程仓库URL git remote -v 为本地项目添加远程仓库 将本地的项目与github上的仓库连接起来 git remote add origin https://github.com/JoyaWang/VocKit.git git remote rm origin 取消与远程仓库的关联 git branch -a 查看所有分支，包括远程仓库的，git branch貌似只能查看本地的 推送到远程源仓库 将本地项目推送到远程源仓库的 master 分支 git push -u origin master 将本地项目推送到远程源仓库 develp 分支 git push -u origin develop 用远程源仓库的代码更新本地仓库代码 git pull origin master 用远程仓库 master 分支更新本地仓库 当前所在分支 会将代码直接合并，造成冲突等无法知道 git fetch origin master:branch2 等价于 git fetch origin :branch2 使用远程 master 分支在本地创建 branch2 (但不会切换到该分支), 如果本地不存在 branch2 分支, 则会自动创建一个新的 branch2 分支, 如果本地存在 branch2 分支, 并且是`fast forward', 则自动合并两个分支, 否则, 会阻止以上操作. Git 本地项目添加多个远程仓库，推送到指定仓库 本地项目添加多个远程仓库 第一种方式： 添加一个远程库 名字不能是origin git remote add 17MOX http://git.17byh.com/17MOX/mxhy.git 查看远程库及地址 git remote -v 拉，推 git pull 17MOX 远程分支名：本地分支名 git push 17MOx 本地分支名：远程分支名 第二种方式：（好处是，推送时，可以同时推送到另外一个库） 添加另外一个远程库 git remote set-url --add origin git@gitlab.com:mzc/DIVIDE_PKG.git 推送 git remote -v git push origin master:master 取消本地目录下关联的远程库 git remote remove origin 将本地项目推送到指定仓库 git push git push git@gitee.com:joyawang/jewelry_shopping_mall.git master 应该这样 git push A master "},"知识库/笔记/Git/修改注释.html":{"url":"知识库/笔记/Git/修改注释.html","title":"修改注释","keywords":"","body":" 修改注释 修改最后一次提交的注释 修改之前某次提交的注释 修改之前的某几次注释 修改注释 修改最后一次提交的注释 如果你只想修改最后一次注释（就是最新的一次提交），那好办：git commit --amend, 出现有注释的界面（你的注释应该显示在第一行）， 输入i进入修改模式，修改好注释后，按Esc键 退出编辑模式，输入:wq保存并退出。ok，修改完成。 修改之前某次提交的注释 其实这个原理我的理解就是先版本回退到你想修改的某次版本，然后修改当前的commit注释，然后再回到本地最新的版本 注：不能使用 reset 或 checkout 回退修改注释 输入：git rebase -i HEAD~2 最后的数字2指的是显示到倒数第几次 比如这个输入的2就会显示倒数的两次注释（最上面两行） 你想修改哪条注释, 就把哪条注释前面的pick换成edit【不在这里修改注释】 使用Vim方法编辑并保存: i---编辑，把pick换成edit---Esc---:wq git commit --amend【这个命令后修改注释】 输入上面的命令后，就会用Vim打开注释文本，直接在里面修改注释并保存退出 git rebase --continue【完成注释修改】 修改之前的某几次注释 修改多次的注释其实步骤和上面的一样，不同点在于： 1.同上 2.你可以将多个想修改的commit注释前面的pick换成edit 3.依次修改你的注释（顺序是从旧到新），Terminal基本都会提示你接下来的操作，每修改一个注释都要重复上面的3和4步，直到修改完你所选择的所有注释 已经将代码push到远程仓库 首先，你把最新的版本从远程仓库先pull下来，修改的方法都如上，最后修改完成后，强制push到远程仓库： git push --force origin master 注：很重要的一点是，你最好保证在你强制push之前没有人提交代码，如果在你push之前有人提交了新的代码到远程仓库，然后你又强制push，那么会被你的强制更新覆盖！！！ 最后，可以检查一下远程的提交记录~~ "},"知识库/笔记/Git/Git设置代理.html":{"url":"知识库/笔记/Git/Git设置代理.html","title":"Git 设置代理","keywords":"","body":" Git设置代理 Git设置代理 Git查看代理 Git取消代理 Git设置代理 Git设置代理 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 为github设置代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 Git查看代理 查看github的代理 git config --global --get http.https://github.com.proxy git config --global --get http.proxy git config --global --get https.proxy Git取消代理 取消github的代理 git config --global --unset http.https://github.com.proxy git config --global --unset http.proxy git config --global --unset https.proxy export http_proxy=socks5://127.0.0.1:1080 export http_proxy=\"http://127.0.0.1:1080\" export https_proxy=\"http://127.0.0.1:1080\" "},"知识库/笔记/Git/gitignore.html":{"url":"知识库/笔记/Git/gitignore.html","title":"gitignore","keywords":"","body":" gitignore 在项目开始时添加 gitignore 文件的步骤 如果在添加 gitignore 之前，某文件如 UserInterfaceState.xcuserstate 已被Git管理，需要做如下步骤使 gitignore 生效【试着效果不好?】 gitignore 在项目开始时添加 gitignore 文件的步骤 创建项目并生成项目文件夹 在 git init 之前把 .gitignore 文件拖到项目文件夹【要和.git文件夹在同级文件夹】 从 Github 搜索 gitignore，下载 Swift.gitignore 将 Swift.gitignore 重命名为 .gitignore【好像是必须的】 在项目文件夹根目录 git init，会在此文件夹生成 .git 文件夹 # 从 Github 下载的默认的 gitignore 应该就是可以的了，以下这些仅做解释，不必往里面添加 #忽略所有包含xcuserdata的文件(夹) xcuserdata #忽略所有以.xcuserstate结尾的文件 *.xcuserstate #忽略所有文件夹中后缀是.DS_Store的文件 .DS_Store 如果在添加 gitignore 之前，某文件如 UserInterfaceState.xcuserstate 已被Git管理，需要做如下步骤使 gitignore 生效【试着效果不好?】 从被 Git 管理的文件目录中删除此文件 git rm --cached 项目名.xcodeproj/project.xcworkspace/xcuserdata/joyawang.xcuserdatad/UserInterfaceState.xcuserstate git rm -r --cached . // 删除本地缓存【貌似】 git rm --cached CoreData\\ -\\ 旧.xcodeproj/project.xcworkspace/xcuserdata/joyawang.xcuserdatad/UserInterfaceState.xcuserstate 提交这次更改 git commit -m \"Removed file that shouldn't be tracked\" 暂时不知有什么用 # WARNING first try git clean -f -d --dry-run, otherwise you may lose uncommited changes. #Then: git clean -f -d "},"知识库/笔记/iOS 知识点/常用功能和第三方库/常用功能和第三方库.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/常用功能和第三方库.html","title":"常用功能集成","keywords":"","body":" 常用功能和第三方库 第三方库 自动布局 网络访问 数据处理、压缩、解析、反射、KVC、字典转模型 IM聊天 通知推送 加密、解密 弹窗、指示器、进度提示 轮播图 分页菜单显示 音频、视频 相册图片/视频选择、相机拍摄、保存到相册 选择器 PickerView 数据库、存储 工具条 UIToolbar 搜索 导航栏 NavigationBar 下拉/上拉 状态栏 TabBar 输入框、字符串、文本框、键盘 日期、时间、日历事件、定时器 UIImage 图片、截图、Gif 颜色 UIColor 动画、渐变 绘图 列表，表格 UITableView UICollectionView 网格视图 UIScrollView StackView 滑块 地图、定位 分享 二维码、条形码 电话、短信、邮件、通讯录 设备信息、传感器、网络连接状态、系统声音服务、震动 图表 侧滑菜单 国际化、打包、发布 UI控件、组件、界面搭建、画界面 其他待分类 常用功能和第三方库 第三方库 source 'https://github.com/CocoaPods/Specs.git' platform :ios, '9.0' pod 'CYLTabBarController', '~> 1.24.0' #TabbarController pod 'ZLCollectionViewFlowLayout'#类似淘宝首页，京东首页，国美首页等复杂布局 pod 'MJRefresh'#上拉下拉刷新 pod 'Masonry', '1.1.0' #自动布局-OC pod 'SnapKit', '4.2.0' #自动布局-Swift # pod 'EasyPeasy', '1.9.0' #自动布局 pod 'CocoaLumberjack'#日志 pod 'XCGLogger', '~> 7.0.1'#日志-Swift pod 'PYSearch', '0.9.1' #搜索 pod 'Eureka'#表单-Swift pod 'XLForm', '~> 4.1' #表单-OC pod 'SwiftForms' #表单 pod 'WMZDropDownMenu'#下拉菜单、筛选 pod 'SDCycleScrollView','>= 1.80' #轮播图 pod 'SideMenu' #侧滑菜单栏 pod 'SwipeCellKit' #单元格滑动按钮库 pod 'FoldingCell', '5.0.2' #折叠单元格 pod \"RATreeView\", \"~> 2.1.2\"#树层次结构列表 pod 'TYPagerController' #分页显示 pod \"PagingMenuController\" #分页显示 pod 'SVProgressHUD', '2.2.5' #进度指示器、弹窗【优先使用】 pod 'MBProgressHUD', '~> 1.2.0' #进度指示器、弹窗 pod 'ProgressHUD'#进度指示器、弹窗 pod 'JCAlertController' #替代UIAlertController的弹窗库 pod 'TZImagePickerController' #iOS8 and later 选择图片 pod 'SJVideoPlayer' #视频播放 pod \"SwViewCapture\" #滚动截图-Swift pod ‘AFNetworking’, ‘4.0.0’ #网络请求-OC pod 'Alamofire', '~> 5.1'#网络请求-Swift pod 'Moya', '~> 14.0' #网络访问层 # or pod 'Moya/RxSwift', '~> 14.0' # or pod 'Moya/ReactiveSwift', '~> 14.0' pod 'YYModel', '1.0.4' #数据解析字典转模型、KVC pod 'SwiftyJSON', '~> 4.0' #JSON数据解析-swift pod 'CryptoSwift', '~> 1.0' #加密 pod 'SAMKeychain'#钥匙串 pod 'SSZipArchive'#压缩 pod 'BRPickerView', '2.5.7' #日期/地址等选择器 pod 'SwiftDate', '~> 5.0'#日期处理 pod \"pop\" #动画 pod 'AAInfographics', :git => 'https://github.com/AAChartModel/AAChartKit-Swift.git' #图表库 pod 'Charts' #图表库 pod \"PromiseKit\", \"~> 6.8\"#异步编程库 pod 'Highlightr'#字符串高亮 pod 'mob_smssdk' #免费短信验证、掌淘科技MobTech pod 'Bugly' #腾讯bugly异常上报崩溃收集集成 pod 'FMDB', '2.7.5' #SQLite数据库 pod 'RealmSwift' #数据库 pod 'IceCream' #realm和iCloud同步 自动布局 Swift - 使用Auto Layout和Size Classes实现页面自适应弹性布局 Swift - 伸缩优先级详解（Content Hugging、Content Compression Resistance） Swift - 自动布局库SnapKit的使用详解1（配置、使用方法、样例） Swift - 自动布局库SnapKit的使用详解2（约束的更新、移除、重做） Swift - 自动布局库SnapKit的使用详解3（约束优先级，约束做动画） Swift - 自动布局库SnapKit的使用详解4（样例1：实现一个登录页面） Swift - 自动布局库SnapKit的使用详解5（样例2：实现一个计算器界面） 网络访问 Swift - 网络抽象层库Moya的使用详解 Swift - 使用原生方式同时上传多个文件和参数（form表单提交、post方式） Swift - 获取文件的MIMEType类型（根据后缀名自动获取） Swift - 实现大文件的后台上传功能（附样例） Swift - 实现大文件的后台下载功能（附样例） Swift - HTTP网络操作库Alamofire使用详解1（配置，以及数据请求） Swift - HTTP网络操作库Alamofire使用详解2（文件上传） Swift - HTTP网络操作库Alamofire使用详解3（文件下载，断点续传） Swift - HTTP网络操作库Alamofire使用详解4（用户权限认证） Swift - 使用Alamofire通过HTTPS进行网络请求，及证书的使用 Swift - 取消未完成的网络请求（使用Alamofire） Swift - 将网页缓存到本地（抓取html页面，并实现离线浏览） Swift - 拦截Alamofire的网络请求（缓存请求结果，从缓存中读取数据） Swift - Cookie内容的读取、删除、写入（附：手动清除Session） Swift - GCDWebServer使用详解1（介绍、安装配置、HTTP服务实现） Swift - GCDWebServer使用详解2（实现静态、动态网站，Web服务器） Swift - GCDWebServer使用详解3（文件传输、WebDav服务器实现） Swift - HTTP网络操作库SwiftHTTP使用详解1（配置，及数据请求） Swift - HTTP网络操作库SwiftHTTP使用详解2（文件上传、下载） Swift - HTTP网络操作库SwiftHTTP使用详解3（用户权限认证） Swift - 使用SwiftHTTP通过HTTPS进行网络请求，及证书的使用 Swift - FTP客户端的制作（使用Rebekka库） Swift - 做一个简单的无线U盘（手机端Http服务器搭建） Swift - 使用URLSession通过HTTPS进行网络请求，及证书的使用 Swift - 网络抓包工具Charles使用介绍1（模拟器、真机HTTP请求捕获） Swift - 网络抓包工具Charles使用介绍2（HTTPS请求捕获） 数据处理、压缩、解析、反射、KVC、字典转模型 Swift - 使用ObjectMapper实现模型转换1（JSON与Model的相互转换） Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍） Swift - 使用反射将自定义对象数据序列化成JSON数据 Swift - SwiftyJSON的使用详解（附样例，用于JSON数据处理） Swift - 使用gzip压缩Data数据（附：请求时将JSON数据进行压缩） Swift - 使用SSZipArchive实现文件的压缩、解压缩 Swift - 解析JSON数据（内置JSONSerialization与第三方JSONKit） XML Swift - 使用原生的XMLParser类来解析xml数据（附样例） pod 'XMLParsing', :git => 'https://github.com/ShawnMoore/XMLParsing.git' #Swift - 生成XML格式数据1（使用XMLParsing库） pod 'AEXML' #Swift - 生成XML格式数据3（使用AEXML库） GDataXML pod 'KissXML' #KissXML（DDXML） IM聊天 Swift - 使用vapor socks库进行socket通信（基于TCP、UDP协议） Swift - 使用socket进行通信（附聊天室样例） Swift - socket不定长消息发送接收的几种方法 （以聊天室为例） 通知推送 Swift - UserNotifications框架使用详解1（基本介绍，权限的申请与判断） Swift - UserNotifications框架使用详解2（发送本地通知） Swift - UserNotifications框架使用详解3（推送远程通知） Swift - UserNotifications框架使用详解4（通知的处理、回调、应用内展示） Swift - JPush极光推送的使用1（配置、简单的推送测试样例） Swift - UserNotifications框架使用详解5（Actionable可交互通知） Swift - UserNotifications框架使用详解6（ServiceExtension、多媒体内容推送） Swift - UserNotifications框架使用详解7（自定义通知详情视图） Swift - JPush极光推送的使用2（PHP调用服务接口给所有人发推送） Swift - JPush极光推送的使用3（根据Alias别名，给某个指定用户发推送） Swift - JPush极光推送的使用4（根据Tag标签，给同一类别用户发推送） Swift - JPush极光推送的使用5（发送通知时附带自定义参数） Swift - JPush极光推送的使用6（定时推送通知） Swift - JPush极光推送的使用7（发送自定义消息） Swift - 使用NotificationCenter发送通知，接收通知 加密、解密 Swift - 将图片、文件转成Base64编码字符串（Base64加密、解密） pod 'CryptoSwift', '~> 1.0' #Swift - 第三方加密库CryptoSwift使用详解 Swift - 使用RSA算法进行数据加密，解密以及数字签名 Swift - 如何实现字符串的HMAC_SHA1加密 Swift - 获取字符串的MD5值 弹窗、指示器、进度提示 Swift - 第三方透明指示器SwiftNotice使用详解 Swift - 第三方Alert弹出框组件（SCLAlertView）使用详解 Swift - 第三方透明指示器MBProgressHUD使用详解 Swift - 自定义UIAlertController的样式2（添加自定义视图） Swift - 自定义UIAlertController的样式1（修改标题、按钮的字体和颜色） 轮播图 Swift - 图片循环轮播组件的实现（附样例） 分页菜单显示 Swift - 分页菜单的实现（使用PagingMenuController库实现tab标签切换） 音频、视频 Swift - 使用AVKit播放本地视频，在线视频（AVPlayerViewController） Swift - 使用Media Player播放本地视频，在线视频 Swift - 制作一个在线流媒体音乐播放器（使用StreamingKit库） Swift - 制作一个录音机（声音的录制与播放） Swift - 使用AVPlayer制作一个音乐播放器 Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放） Swift - 使用ijkplayer框架播放直播视频2（RTSP视频流播放） Swift - 获取视频截图（本地视频、网络视频的缩略图） Swift - 视频录制教程1（调用摄像头录像，并保存到系统相册） Swift - 视频录制教程2（小视频拍摄，将多段视频进行合并） Swift - 视频录制教程3（设置拍摄窗口大小，录制正方形视频） Swift - 视频录制教程4（设置视频压缩质量、分辨率） 相册图片/视频选择、相机拍摄、保存到相册 Swift - 使用ALAssetsLibrary获取相簿里所有图片，视频（附样例） Swift - 监听照片库里的变化（自动获取最新添加的图片） Swift - 从相册中选择照片并上传（使用UIImagePickerController） Swift - 使用相机拍摄照片 Swift - 相册图片多选功能的实现 Swift - 从相册中选择视频（过滤掉照片，使用UIImagePickerController） Swift - 保存图片到系统相册（相机胶卷），并获取存放路径、缩略图 Swift - 从ALAsset中获取照片的原图并转换成NSData Swift - 使用Photos框架（PhotoKit）将图片保存到自定义相簿 选择器 PickerView Swift - 让UIPickerView里的选项文字自动换行（多行显示） Swift - UIPickerView无限循环滚动的实现（数据循环显示） Swift - 省市县三级联动功能的实现（使用UIPickerView选择框） 数据库、存储 Swift - 第三方SQLite库FMDB使用详解 Swift - 常用文件目录路径获取（Home目录，文档目录，缓存目录等） Swift - 文件，文件夹操作大全 Swift - 本地数据的保存与加载（使用NSCoder将对象保存到.plist文件） Swift - 使用Core Data进行数据持久化存储 Swift - 在已有项目上添加CoreData（之前创建时未勾选Use Core Data） Swift - 操作SQLite数据库（引用SQLite3库） Swift - SQLiteDB库新增的SQLTable功能详解（便于操作SQLite库） Swift - Realm数据库的使用详解（附样例） Swift - .plist文件数据的读取和存储 Swift - iCloud存储介绍 工具条 UIToolbar Swift - 工具条（UIToolbar）的用法 搜索 Swift - 实现带有搜索框的导航栏（将UISearchController集成到Navigation上） Swift - 使用UISearchController实现带搜索栏的表格 Swift - searchBar放在tableView外部，固定位置（点击消失问题解决） Swift - 修改UISearchControlle取消按钮的文字（默认为Cancel） Swift - 搜索条（UISearchBar）的用法 Swift - 修改搜索条（UISearchBar）中取消按钮的文字、颜色 Swift - 在表格头部添加一个带范围选择（scope bar）的搜索栏 导航栏 NavigationBar Swift - 在导航栏左侧或者右侧放置多个按钮 Swift - 将导航栏标题修改成自定义视图（图片、按钮、分段选择等） Swift - 修改导航栏的样式（文字颜色，背景颜色，背景图片） Swift - 修改导航栏“返回”按钮文字，图标 Swift - 实现带有搜索框的导航栏（将UISearchController集成到Navigation上） Swift - 导航栏标题下拉菜单的实现（BTNavigationDropdownMenu库） Swift - 实现下拉时背景图片放大效果（仿QQ个人资料页面） Swift - 导航栏滑动透明渐变效果的实现（透明度随视图滚动而改变） Swift - 导航栏背景全透明效果的实现（沉浸式效果） Swift - 去掉导航栏的半透明效果（元素被导航栏遮挡问题） Swift - edgesForExtendedLayout属性介绍（元素被导航栏遮挡问题） Swift - 当存在导航栏时，scrollview自动下移的问题解决 Swift - 让导航栏随页面一起移动，而不是淡入淡出 Swift - 自定义导航栏leftBarButtonItems导致滑动返回失效问题解决 Swift - 导航控制器（navigationController）全屏滑动返回功能实现 Swift - 导航栏标题文字太长，导致返回按钮文字消失问题解决 下拉/上拉 Swift - 导航栏标题下拉菜单的实现（BTNavigationDropdownMenu库） Swift - 实现下拉时背景图片放大效果（仿QQ个人资料页面） Swift - MJRefresh库的使用详解1（配置，及库自带的下拉刷新组件） Swift - MJRefresh库的使用详解2（创建自定义的下拉刷新组件） Swift - MJRefresh库的使用详解3（库自带的上拉加载组件） Swift - MJRefresh库的使用详解4（创建自定义的上拉加载组件） Swift - MJRefresh库的使用详解5（CollectionView上实现上拉下拉刷新） Swift - MJRefresh库的使用详解6（WebView上实现下拉刷新） Swift - MJRefresh库的使用详解7（ScrollView上实现上拉下拉刷新） Swift - 表格tableView上拉加载新数据的功能实现（附样例） Swift - 下拉刷新数据的功能实现（使用UIRefreshControl） Swfit - 使用自定义的UIRefreshControl下拉刷新界面 Swift - UIRefreshControl下拉时，刷新时分别使用不同的描述文字 Swift - 下拉刷新数据的功能实现（使用UIRefreshControl） 状态栏 Swift - 动态改变状态栏statusBar文字颜色（preferredStatusBarStyle无效问题） Swift - 修改顶部状态栏（statusBar）文字颜色为白色 Swift - 隐藏状态栏（statusBar）的两种方法 Swift - 点击状态栏使tableView返回顶部（附：状态栏点击事件响应） TabBar Swift - 标签条（UITabBar）标签页控制器（UITabBarController）用法 Swift - 让TabBarItem的图标和文字在iPad下仍然是上下排列 Swift - 让标签栏按钮UITabBarItem图片居中（没有文字） Swift - 标签栏按钮UITabBarItem样式修改（图标文字尺寸，颜色等） 输入框、字符串、文本框、键盘 Swift - 去除UITextView的内边距（去掉Padding） Swift - 在数字键盘上添加自定义按钮（增加return键） Swift - 键盘出现后自动改变页面布局，防止下方元素被键盘遮挡 Swift - 解决表格中TextField,TextView编辑时，输入框被键盘遮挡的问题 Swift - 输入框抖动效果的实现（扩展UIView、支持所有UI组件） Swift - 手机号码输入框的实现（手机号验证、格式化显示） Swift - 修改UITextView中链接的样式（链接颜色、下划线样式） Swift - 让textview支持特殊标签点击响应（@标签、#标签） Swift - 给UITextView添加自定义链接，以及链接的点击响应 Swift - 使用NSDataDetector进行URL验证，及提取字符串中所有链接 Swift - 字符串的替换与过滤（附：过滤emoji表情符号） Swift - 去除字符串前后的空白（trim方法） Swift - 实现URL字符串的编码与解码（urlEncoded、urlDecoded） Swift - 扩展String增加字符串截取方法subString(start:, length:) Swift - 在字符串中查找另一字符串首次出现的位置（或最后一次出现位置） Swift - 文本框textView图文混排的实现（附样例） Swift - 将字符串拆分成数组（把一个字符串分割成字符串数组） 日期、时间、日历事件、定时器 Swift - 第三方日期处理库SwiftDate使用详解 Swift - 实现公历、农历日期之间的相互转换 Swift - 获取本周（或指定日期所在周）的第一天、最后一天日期 Swift - 获取（当月、当年、任意月|年）的第一天、最后一天日期 Swift - 计算当月、任意月一共有多少天 Swift - 获取当前时间的时间戳（时间戳与时间互相转换） Swift - 实现日期（Date）与字符串（String）的相互转换 Swift - 第三方日历组件CVCalendar使用详解 Swift - 判断两个日期是不是同一天的几个办法 Swift - 使用EventKit获取系统日历事件，添加事件 Swift - 获取日历中所有的事件并显示在表格中（带有搜索功能） Swift - 时间控制器NSTimer（每隔一定时间执行某个函数） UIImage 图片、截图、Gif Swift - 使用Image Literal实现代码中图片的智能提示（Xcode自带功能） Swift - 图片处理库ImageHelper详解（扩展UIImage,UIImageView） Swift - 圆形图片的生成及显示（两种办法） Swift - 实现图片（UIImage）的水平翻转(镜像)，垂直翻转 Swift - 截图功能的实现1（通过扩展实现将UIView转成UIImage) Swift - 截图功能的实现2（使用SwViewCapture库实现滚动视图的截屏） Swift - 获取视频截图（本地视频、网络视频的缩略图） Swift - 实现下拉时背景图片放大效果（仿QQ个人资料页面） Swift - 使用resizableImage拉伸图片的指定部分（九宫格拉伸） Swift - 设置UIView的背景图片（平铺、拉伸） Swift - 改变UIImage图片的大小尺寸，或按比例缩放 Swift - 将图片裁剪成指定的长宽比例（自动裁掉多余部分，确保图片不变形） Swift - 将图片缩放至指定尺寸（自动裁掉多余部分，确保图片不变形） Swift - 将图片、文件转成Base64编码字符串（Base64加密、解密） Swift - 实现图片全屏展示功能（可左右滑动切换图片） Swift - 抠图，及图片合成功能的实现（适用于纯色背景） Swift - 去处图片的白色、黑色背景（使UIImage背景透明） Swift - 使用OpenCV2进行图片拼接（将多张照片合并成全景图） Swift - 人脸检测，以及人脸打码的功能实现（附样例） Swift - 使用CIPixellate给图片打码（全图马赛克，部分区域马赛克） Swift - 自动优化照片，改善图像质量 Swift - 给图片（imageView）添加阴影边框 Swift - 给图片添加滤镜效果（棕褐色老照片滤镜，黑白滤镜） Swift - 给图片添加图片水印（图片上绘制另一张图，并可设透明度） Swift - 给图片添加文字水印（图片上写文字，并可设置位置和样式） Swift - 使用CGBlendMode改变UIImage颜色 Swift - 实现图片的模糊效果（高斯模糊滤镜） Swift - GIF动态图片的播放（分别使用SwiftGif和YLGIFImage-Swift） Swift - 微信聊天群头像实现 （群聊的组合头像） Swift - QQ讨论组头像的实现 （多人聊天的组合头像） 颜色 UIColor Swift - 使用Color Literal实现代码中颜色的智能提示（Xcode自带功能） Swift - 获取UIColor的HSV/HSB值（Hue色相、S饱和度、B亮度） Swift - 获取图片UIImage指定像素的颜色值 Swift - 十六进制颜色字符串与UIColor之间的相互转换（附样例） Swift - 计算一个颜色的反色（UIColor的反色） Swift - 生成随机颜色（扩展UIColor） 动画、渐变 Swift - 动画效果的实现方法总结（附样例） Swift - CAGradientLayer使用详解 Swift - 沿路径运动的动画实现（圆形、曲线、直线等路径轨迹） Swift - 刮刮卡效果的实现（附样例） Swift - 使用CAKeyframeAnimation实现关键帧动画 Swift - 使用CABasicAnimation实现动画效果 Swift - 通过设置视图的transform属性实现动画 Swift - 使用CATransition制作过渡动画（页面切换转场效果） 绘图 Swift - Core Graphics绘图框架详解1（绘制线条） Swift - Core Graphics绘图框架详解2（绘制图形） Swift - Core Graphics绘图框架详解3（绘制渐变、填充渐变色） Swift - Core Graphics绘图框架详解4（绘制图片、图形变换） Swift - Core Graphics绘图框架详解5（绘制文字、文字复杂排版） Swift - 捕获用户签名（用户在屏幕上手写签名，并生成图片） Swift - 在UIView上绘制图形阴影 Swift - 在UIView上使用自定义曲线绘制复杂图形（贝塞尔曲线） Swift - 在UIView上使用多条子路径绘制图形 Swift - 在UIView上绘制矩形（直角，圆角，带边框） Swift - 设置圆角样式的图片，圆角样式的按钮 列表，表格 UITableView Swift - SwiftForms的使用详解 Swift - 表格UITableView的plain、grouped两种样式详解（附分组头悬停） Swift - 两个 tableView 间联动功能的实现（左侧分类列表，右侧商品列表） Swift - tableView与collectionView联动功能的实现（左侧大分类，右侧小分类） Swift - 实现表格tableViewCell里嵌套collectionView（附样例） Swift - 单元格滑动按钮库SwipeCellKit使用详解 Swift - 自定义tableViewCell滑动事件按钮 Swift - 表格section header增加滑动删除功能（删除该分区下所有cell） Swift - 设置表格cell的分隔线边距（分割线与边框距离） Swift - 实现tableView中section分组圆角效果1（没有分区头、尾的情况） Swift - 给tableView中的单元格设置左右边距（margin left、margin right） Swift - 去除tableView在编辑模式下的自动缩进（单元格头部不留空白） Swift - 通过代码让tableview左滑出现的删除按钮消失 Swift - 在单元格里的按钮点击事件中获取对应的cell以及indexPath Swift - 在TableViewCell中获取父TableView（附：获取任意类型的父View） Swift - 时间轴效果的实现（附样例） Swift - 实现tableView静态单元格与动态单元格混合使用（附样例） Swift - 使用xib自定义表格中分组section的header和footer Swift - 修改tableView分组（section）头部、尾部的字体颜色和大小 Swift - tableView单元格高度自适应1（默认单元格，只有1个Label标签） Swift - tableView单元格高度自适应2（自定义单元格，有2个Label标签） Swift - tableView单元格高度自适应3（图片宽度固定，高度自适应） Swift - tableView的单元格多选功能的实现（获取多选值、多选删除） Swift - 可编辑表格样例（可直接编辑单元格中内容、移动删除单元格） Swift - 修改表格选中单元格（Cell）的样式（背景色，文字颜色） Swift - 在ViewController中表格使用静态单元格（Static Cell） Swift - 表格图片加载优化（拖动表格时不加载，停止时只加载当前页图片） Swift - 实现点击UITableView单元格时自动展开单元格 Swift - 给表格UITableView添加索引功能（快速定位） Swift - 给表格TableView添加页眉和页脚 Swift - 给表格添加移动单元格功能（拖动行） Swift - 动态添加删除TableView的单元格（以及内部元件） Swift - 使用TableView的静态单元格进行页面布局 Swift - 列表项尾部附件点击响应（感叹号，箭头等） Swift - 给表格添加Cell的显示动画（3D缩放） Swift - 给表格添加编辑功能（删除，插入） Swift - 将表格UITableView滚动条移动到底部 Swift - 自定义单元格实现微信聊天界面 Swift - 给表格的单元格UITableViewCell添加图片，详细文本标签 Swift - 使用表格组件（UITableView）实现分组列表 Swift - 使用表格组件（UITableView）实现单列表 UICollectionView 网格视图 Swift - 使用网格（UICollectionView）进行流布局 Swift - 使用网格（UICollectionView）的自定义布局实现复杂页面 Swift - 让CollectionView里的Section分别设置不同的背景色 Swift - tableView与collectionView联动功能的实现（左侧大分类，右侧小分类） Swift - 实现表格tableViewCell里嵌套collectionView（附样例） Swift - 使用CollectionView实现图片Stack层叠效果 Swift - 使用CollectionView实现图片Gallery画廊效果（左右滑动浏览图片） Swift - 实现UICollectionView中元素的环形布局 Swift - 动态切换UICollectionView的layout布局（附样例） Swift - 带有多section分区的collectionView的使用样例 Swift - 实现UICollectionView分组头悬停效果（方法1：使用自定义布局） Swift - 实现UICollectionView分组头悬停效果（方法2：使用iOS9新特性） Swift - 多列表格组件的实现（样例1：基本功能的实现） Swift - 多列表格组件的实现（样例2：带排序功能） Swift - 多列表格组件的实现（样例3：表头、列头固定） Swift - 多列表格组件的实现（样例4：表格样式美化） Swift - 实现内边框为1像素的collectionView（内间距为1px） Swift - 异步加载表格数据，内容不能及时显示的问题解决 Swift - 设置网格UICollectionView的单元格间距 UIScrollView wift - 调整UIScrollView的滑动速度（适用于tableView、collectionView） Swift - 滚动视图（UIScrollView）的用法 StackView Swift - UIStackView使用详解 滑块 Swift - 实现自定义的Slider滑块组件（轨道上带有刻度标记） 地图、定位 Swift - 使用CoreLocation实现定位（经纬度、海拔、速度、距离等） Swift - 使用CoreLocation获取设备方向（真实方向，磁极方向） Swift - 经纬度位置坐标与真实地理位置相互转化 Swift - 使用MapKit显示地图，并在地图上做标记 Swift - 百度静态地图的使用样例（显示当前位置地图，可调整缩放级别） Swift - 获取、设置MKMapView的地图缩放级别（zoomlevel） Swift - 百度地图SDK的配置和使用（附样例） Swift - 集成百度地图的周边雷达功能（附样例） 分享 Swift - 腾讯官方SDK的配置及使用（分享到QQ空间、分享到好友） Swift - 使用友盟实现应用的统计分析 Swift - 发送消息（文本,图片,文件等）给微信好友或分享到朋友圈 Swift - 自定义UIActivity分享 二维码、条形码 Swift - 二维码QRCode的读取（从图片读取 ，或通过摄像头扫描） Swift - 使用AVFoundation实现条形码扫描（附：拉近镜头改善读取） Swift - 使用CIFilter生成二维码图片（QRCode） 电话、短信、邮件、通讯录 Swift - 实现拨打电话 Swift - 邮件发送功能的实现 Swift - 短信发送功能的实现 Swift - 添加、修改、删除通讯录联系人 Swift - 访问通讯录联系人（使用纯代码实现） Swift - 访问通讯录联系人（使用系统提供的通讯录交互界面） 设备信息、传感器、网络连接状态、系统声音服务、震动 Swift - 手机摇晃的监测和响应 Swift - 加速传感器（CoreMotion）的用法，小球加速运动并反弹样例 Swift - 判断设备方向（或监听设备方向的改变） Swift - 判端网络连接状态，连接类型（3G还是Wifi） Swift - 系统声音服务的使用（播放声音，提醒，震动） Swift - 使用CoreTelephony获取运营商信息、网络制式（4G、3G、2G） Swift - 获取应用名称、应用版本、设备型号、系统版本等信息 图表 Swift - 第三方图表库AAInfographics使用详解 Swift - 第三方图表库Charts使用详解 侧滑菜单 Swift - 第三方侧栏菜单组件SideMenu使用详解 Swift - 侧滑菜单的实现（样例2：仿QQ，菜单带缩放效果） Swift - 侧滑菜单的实现（样例1：主页向右滑动，露出下方菜单页） 国际化、打包、发布 Swift - iOS应用的国际化与本地化 Swift - 在fir.im上发布程序（免费的应用内测托管平台） Swift - 企业账号进行IPA的打包、分发、下载安装的详细流程 Swift - 真机调试正常，打包成IPA安装后一启动就闪退的问题解决 UI控件、组件、界面搭建、画界面 Swift - XIB结合UIView制作自定义组件（xib加载绘制UIView） Swift - 继承UIView实现自定义可视化组件（附记分牌样例） Swift - 在StoryBoard中添加使用自定义组件（自定义进度条组件为例） Swift - 通过UIView对象找到其所在的UIViewController Swift - UIViewController生命周期详解（附：VC相关方法介绍） Swift - 使用addSubview()方法将StoryBoard中的视图加载进来 Swift - iOS中各种视图控制器（View Controller）的介绍 Swift - 生成各种控件的工厂类（包含标签，按钮，输入框等） Swift - 字体图标的使用及样例（使用Font Awesome字体库，非图片） 其他待分类 Swift - 异步编程库PromiseKit使用详解 Swift - 使用Highlightr库实现语法高亮、代码高亮展示（支出实时编辑渲染） Swift - 正则表达式的使用（附用户名、邮箱、URL等常用格式验证） Swift - 封装一个正则表达式工具类（附：正则替换、正则匹配样例） Swift - 判断UILabel文字是否被截断（是否有多余文字被省略） Swift - 日志框架XCGLogger的使用详解 Swift - 实现日志输出的封装1（显示出调用的文件名、方法、行号） Swift - 实现日志输出的封装2（同步记录到文件中去） Swift - 使用Carthage来安装管理第三方库 Swift - 使用EventKit操作\"提醒事项\"（1、查询出所有提醒） Swift - 使用EventKit操作\"提醒事项\"（2、新增、修改、删除提醒） Swift - 使用OpenWeatherMap获取天气的实时数据、预测数据 Swift - 实现毛玻璃效果（Blur、模糊、虚化背景元素） Swift - URL schemes的使用样例（如：在Safari中打开App） Swift - 打开第三方应用，并传递参数（附常用App的URL Scheme） Swift - QQ授权登录，并获取个人信息（用户资料） Swift - 使用AirPrint进行打印 Swift - 使用AirPrint打印报表（表格） Swift - 代码设置AirPrint打印的纸张大小（打印尺寸） Swift - UIPasteboard剪贴板的使用详解（复制、粘贴文字和图片） Swift - 使用Segmented Control进行多个视图View的切换 Swift - 使用LINQ操作数组/集合（附Swift的LINQ扩展、及替代方法） Swift - 人脸检测，以及人脸打码的功能实现（附样例） Swift - 使用HTML5进行iOS开发（将HTML5打包成iOS应用） Swift - 重写UIKit框架类的init初始化方法（以UITabBarController为例） Swift - 触摸事件（点击，移动，抬起等）说明及用例 Swift - 各种手势检测大全（UIGestureRecognizer及其子类） Swift - 项目部署配置（支持的系统，设备和状态条样式等） Swift - 二进制，八进制，十六进制的表示方法 Swift - 下标脚本方法介绍及实例 Swift - Framework的制作与使用教程1（纯Swift实现） Swift - Framework的制作与使用教程2（引用第三方库） Swift - Framework的制作与使用教程3（与Objective-C混合编程） "},"知识库/笔记/iOS 知识点/常用功能和第三方库/RxSwift.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/RxSwift.html","title":"RxSwift","keywords":"","body":"RxSwift Swift - RxSwift的使用详解1（基本介绍、安装配置） Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例） Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列） Swift - RxSwift的使用详解4（Observable订阅、事件监听、订阅销毁） Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder） Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性） Swift - RxSwift的使用详解7（Subjects、Variables） Swift - RxSwift的使用详解8（变换操作符：buffer、map、flatMap、scan等） Swift - RxSwift的使用详解9（过滤操作符：filter、take、skip等） Swift - RxSwift的使用详解10（条件和布尔操作符：amb、takeWhile、skipWhile等） Swift - RxSwift的使用详解11（结合操作符：startWith、merge、zip等） Swift - RxSwift的使用详解12（算数&聚合操作符：toArray、reduce、concat） Swift - RxSwift的使用详解13（连接操作符：connect、publish、replay、multicast） Swift - RxSwift的使用详解14（其他操作符：delay、materialize、timeout等） Swift - RxSwift的使用详解15（错误处理） Swift - RxSwift的使用详解16（调试操作） Swift - RxSwift的使用详解17（特征序列1：Single、Completable、Maybe） Swift - RxSwift的使用详解18（特征序列2：Driver） Swift - RxSwift的使用详解19（特征序列3：ControlProperty、 ControlEvent） Swift - RxSwift的使用详解20（调度器、subscribeOn、observeOn） Swift - RxSwift的使用详解21（UI控件扩展1：UILabel） Swift - RxSwift的使用详解22（UI控件扩展2：UITextField、UITextView） Swift - RxSwift的使用详解23（UI控件扩展3：UIButton、UIBarButtonItem） Swift - RxSwift的使用详解24（UI控件扩展4：UISwitch、UISegmentedControl） Swift - RxSwift的使用详解25（UI控件扩展5：UIActivityIndicatorView、UIApplication） Swift - RxSwift的使用详解26（UI控件扩展6：UISlider、UIStepper） Swift - RxSwift的使用详解27（双向绑定：） Swift - RxSwift的使用详解28（UI控件扩展7：UIGestureRecognizer） Swift - RxSwift的使用详解29（UI控件扩展8：UIDatePicker） Swift - RxSwift的使用详解30（UITableView的使用1：基本用法） Swift - RxSwift的使用详解31（UITableView的使用2：RxDataSources） Swift - RxSwift的使用详解32（UITableView的使用3：刷新表格数据） Swift - RxSwift的使用详解33（UITableView的使用4：表格数据的搜索过滤） Swift - RxSwift的使用详解34（UITableView的使用5：可编辑表格） Swift - RxSwift的使用详解35（UITableView的使用6：不同类型的单元格混用） Swift - RxSwift的使用详解36（UITableView的使用7：样式修改） Swift - RxSwift的使用详解37（UICollectionView的使用1：基本用法） Swift - RxSwift的使用详解38（UICollectionView的使用2：RxDataSources） Swift - RxSwift的使用详解39（UICollectionView的使用3：刷新集合数据） Swift - RxSwift的使用详解40（UICollectionView的使用4：样式修改） Swift - RxSwift的使用详解41（UIPickerView的使用） Swift - RxSwift的使用详解42（[unowned self] 与 [weak self]） Swift - RxSwift的使用详解43（URLSession的使用1：请求数据） Swift - RxSwift的使用详解44（URLSession的使用2：结果处理、模型转换） Swift - RxSwift的使用详解45（结合RxAlamofire使用1：数据请求） Swift - RxSwift的使用详解46（结合RxAlamofire使用2：结果处理、模型转换） Swift - RxSwift的使用详解47（结合RxAlamofire使用3：文件上传） Swift - RxSwift的使用详解48（结合RxAlamofire使用4：文件下载） Swift - RxSwift的使用详解49（结合Moya使用1：数据请求） Swift - RxSwift的使用详解50（结合Moya使用2：结果处理、模型转换） Swift - RxSwift的使用详解51（MVVM架构演示1：基本介绍、与MVC比较） Swift - RxSwift的使用详解52（MVVM架构演示2：使用Observable样例） Swift - RxSwift的使用详解53（MVVM架构演示3：使用Driver样例） Swift - RxSwift的使用详解54（一个用户注册样例1：基本功能实现） Swift - RxSwift的使用详解55（一个用户注册样例2：显示网络请求活动指示器） Swift - RxSwift的使用详解56（结合MJRefresh使用1：下拉刷新） Swift - RxSwift的使用详解57（结合MJRefresh使用2：上拉加载、以及上下拉组合） Swift - RxSwift的使用详解58（DelegateProxy样例1：获取地理定位信息 ） Swift - RxSwift的使用详解59（DelegateProxy样例2：图片选择功能 ） Swift - RxSwift的使用详解60（DelegateProxy样例3：应用生命周期的状态变化） Swift - RxSwift的使用详解61（sendMessage和methodInvoked的区别） Swift - RxSwift的使用详解62（订阅UITableViewCell里的按钮点击事件） Swift - RxSwift的使用详解63（通知NotificationCenter的使用） Swift - RxSwift的使用详解64（键值观察KVO的使用） Swift - RxSwift的使用详解65（表格图片加载优化） Swift - RxSwift的使用详解66（检测当前值与初始值是否相同：isEqualOriginValue） Swift - RxSwift的使用详解67（重复执行某个操作序列：repeatWhen） Swift - RxSwift的使用详解68（监听滚动条滚动到底部的行为：reachedBottom） Swift - RxSwift的使用详解69（RxFeedback架构1：安装配置、基本用法） Swift - RxSwift的使用详解70（RxFeedback架构2：一个用户注册样例） Swift - RxSwift的使用详解71（RxFeedback架构3：GitHub资源搜索样例） Swift - RxSwift的使用详解72（ReactorKit架构1：安装配置、基本用法） Swift - RxSwift的使用详解73（ReactorKit架构2：一个用户注册样例） Swift - RxSwift的使用详解74（ReactorKit架构3：GitHub资源搜索样例） "},"知识库/笔记/iOS 知识点/常用功能和第三方库/SDWebImage.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/SDWebImage.html","title":"SDWebImage","keywords":"","body":"SDWebImage 常用功能: 图片下载图片缓存 下载进度监听 gif处理 默认缓存时间: 1周 使用的缓存对象: NSCache SDImageCache内处理内存警告，以通知的方式，clearMemory cleanDisk的执行过程 先遍历所有的缓存文件，记录过期的文件，计算缓存文件的总大小 删除过期的文件 判断macCacheSize的值是否>0,如果大于0再判断缓存文件总大小是否大于maxCacheSize 如果缓存文件的总大小超过maxCacheSize，删除最早的文件 最大并发数: 6 支持gif 怎么判断图片文件的类型的 NSData + ImageContentType.m中 根据文件头的第一个字节判断的 case 0xFF (jpg) case 0x89 (png) case 0x47 (gif) case 0x4D (tiff) SDWebImage缓存文件的名称 为了防止缓存的图片名称冲突，根据md5计算的 md5重复的几率很小很小很小 终端测试echo -n '图片路径' | md5 maxMemoryCost 内存缓存的最大空间 maxMemoryCountLimit 内存缓存的最大数量 maxCacheAge 磁盘缓存存储的最长时间。默认值为1周 maxCacheSize 磁盘缓存的最大空间。默认值为0，不限制占用磁盘大小 1) loadImage 是 SDWebImage 的核心方法 2) 图像下载完成后，会自动保存在沙盒中，文件路径是 URL 的 md5 3) 如果沙盒中已经存在缓存的图像，后续使用 SD 通过 URL 加载图像，都会加载本地沙盒的图像 4) 不会发起网络请求，同时，回调方法，同样会调用！ 5) 方法还是同样的方法，调用还是同样的调用，不过内部不会再次发起网络请求！ 注意 如果缓存的图像累计很大，要找后台要接口！ "},"知识库/笔记/iOS 知识点/常用功能和第三方库/授权登录/OAuth.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/授权登录/OAuth.html","title":"登录授权","keywords":"","body":"OAuth 打开门户网站提供的登录页面进行登录 登录成功后，再次发送请求，将 授权码 和 应用程序信息 发送给服务器后获取 AccessToken "},"知识库/笔记/iOS 知识点/常用功能和第三方库/授权登录/SSH.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/授权登录/SSH.html","title":"SSH","keywords":"","body":"SSH Secure Shell 安全外壳协议 使用方法 使用 RSA 非对称算法，生成 密钥对，自己留着 私钥 (用来解密信息) ssh-keygen -t rsa -C root 默认密钥对存放的位置 /Users/joyawang/.ssh/instance1.pub /Users/joyawang/.ssh/instance1 将 公钥 传递给服务器端(用来加密信息)，或直接去服务器页面手动设置 登录 Terminal - Shell - NewRemoteConnection 在 Server 框点击＋ 私钥公钥的应用场景 始终记得: 公钥可以随便给人，而私钥要保密 网络间传递加密信息时 这个场景下公钥用来加密信息，私钥用来解密信息 客户端生成密钥对AB，把公钥B给服务器 服务器生成密钥对CD，把公钥D给客户端 客户端给服务器发消息时用服务器给的公钥D加密，服务器收到后用自己的私钥C解密 服务器给客户端发消息时用客户端给的公钥B加密，客户端收到后用自己的私钥A解密 认证、确认身份时 【在这个场景下，私钥用来加密，公钥用来解密了】 数字签名、证书 客户端输入了一个网址给服务器发送了一个请求以后，确实拿到了服务器返回的公钥，但是这个服务器是不是冒充的它本意想访问的那个服务器是不确定的。 客户端要求服务器去一家双方都认可的权威的证书机构[如公安局]，公安局用自己的私钥将服务器的公钥加密生成一个数字证书，客户端给公安局打电话拿到了用来从数字证书中解密服务器公钥的公钥，这样当用户可以使用公安局给的公钥正常获得服务器的公钥时，就可以确定这个服务器是真正的服务器。 "},"知识库/笔记/iOS 知识点/常用功能和第三方库/授权登录/SSO.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/授权登录/SSO.html","title":"SSO","keywords":"","body":"SSO 跳到第三方应用进行授权再跳回来 更加人性化 在真机上，如果用户安装了门户应用，可以直接跳转到门户应用进行授权 授权完毕后自动返回到应用程序 如果用户没有安装门户应用，会以 OAuth 的方式登录 "},"知识库/笔记/iOS 知识点/常用功能和第三方库/IM即时聊天/环信客服云集成.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/IM即时聊天/环信客服云集成.html","title":"IM聊天","keywords":"","body":"环信客服云集成 可以不注册 APNs 的，不获取 APNs 推送证书 在集成环信的 UI 框架时，可能会出现它的依赖类库与你自己的依赖类库冲突的情况，这时候你就要进入蛋疼的合并冲突类库的过程了，用好git，删除旧的类库，导入最新的，编译、报错、更改。 完了以后，继承客服云最基本的只需要下面两步即可 在你的App用户注册的地方，注册环信客服云的账户，账户就用你App当前用户的账户，比如手机号，密码随便写 HDError *error = [[HDClient sharedClient] registerWithUsername:@\"username\" password:@\"password\"]; error.code: HDErrorNetworkUnavailable 网络不可用 HDErrorUserAlreadyExist 用户已存在 HDErrorUserAuthenticationFailed 无开放注册权限（后台管理界面设置[开放|授权]） HDErrorUserIllegalArgument 用户名非法 在用户点击进入客服时，登录并且显示与客服的会话界面 HDClient *client = [HDClient sharedClient]; if (client.isLoggedInBefore != YES) { HDError *error = [client loginWithUsername:@\"username\" password:@\"password\"]; if (!error) { //登录成功 } else { //登录失败 return; } } // 进入会话页面 HDMessageViewController *chatVC = [[HDMessageViewController alloc] initWithConversationChatter:@\"IM 服务号\"]; // 获取地址：kefu.easemob.com，“管理员模式 > 渠道管理 > 手机APP”页面的关联的“IM服务号” [self.navigationController pushViewController:chatVC animated:YES]; "},"知识库/笔记/iOS 知识点/常用功能和第三方库/推送通知/推送通知.html":{"url":"知识库/笔记/iOS 知识点/常用功能和第三方库/推送通知/推送通知.html","title":"推送/通知","keywords":"","body":"推送通知 不是 NSNotification iOS 中两种 本地推送通知 Local Notification 不需要联网就能发出的推送通知 (不需要服务器的支持) 本地推送通知的场景 常用来定时提醒用户完成一些任务，比如 清理垃圾、记账、买衣服、看电影、玩游戏 UILocalNotification 远程推送通知 Remote Notification 从远程服务器推送给客户端的通知 (需要联网) APNs (Apple Push Notification Services) 为什么要远程推送通知？ 传统获取数据的局限性，只要用户关闭了 app，就无法跟 app 的服务器沟通，无法从服务器上获得最新的 不管用户打开还是关闭 app，只要联网了，都能接收到服务器推送的远程通知 远程推送通知，所有苹果设备，在联网状态下，都会与 苹果的服务器 建立 长连接 推送通知的呈现效果总结 5 种 在屏幕顶部显示一块横幅 (显示具体内容) 在屏幕中间弹出一个 UIAlertView (显示具体内容) 在锁屏界面显示一块横幅 (锁屏状态下，显示具体内容) 更新 app 图标的数字 (说明新内容的数量) 播放音效 (提醒作用) "},"知识库/笔记/iOS 知识点/其他/常用类.html":{"url":"知识库/笔记/iOS 知识点/其他/常用类.html","title":"其他","keywords":"","body":"常见类 UIView 视图类 UILabel 文本框类 UITextView 文本视图类 UIImageView 图片视图类 UIButton 按钮类 UIImage 图片类 Runloop 运行循环/消息循环 Runtime 运行时 UIControl UIResponder UITouch UIGestureRecognizer 手势类 UIEvent CALayer 图层类 CGRect URL UIScrollView 滚动视图 UICollectionView 集合视图 UITableView 列表视图 UINavigationController 导航控制器 UITabBarController WebKit WKWebView CoreGraphics 核心绘图 CoreAnimation 核心动画 "},"知识库/笔记/iOS 知识点/其他/日期时间相关.html":{"url":"知识库/笔记/iOS 知识点/其他/日期时间相关.html","title":"日期时间相关","keywords":"","body":" 日期相关 NSDate、NSDateFormatter、NSCalendar 日期格式 日期相关 NSDate、NSDateFormatter、NSCalendar Tue Sep 15 12:12:00 +0800 2015 星期 月 日 时:分:秒 时区 年 要从一个字符串中解析得到准确的时间，必须要指定 正确的格式字符串 ，以及对应的 时区标示 日期格式 年 y 将年份 (0-9) 显示为不带前导零的数字 yy 以带前导零的两位数字格式显示年份 yyy 以三位数字?格式显示年份 yyyy 以四位数字格式显示年份 月 M 将月份显示为不带前导零的数字 (如一月表示为 1) MM 将月份显示为带前导零的数字 (例如 01/12/01) MMM 将月份显示为缩写形式 (例如 Jan) MMMM 将月份显示为完整月份名 (例如 January) 日 d 将日显示为不带前导零的数字 (如 1) dd 将日显示为全名 (例如 Sunday) 星期 EEE 将日显示为缩写形式 (例如 Sun) EEEE 将日显示为全名 (例如 Sunday) 小时 h 使用 12 小时制将小时显示为不带前导零的数字 (例如 1:15:15 PM) hh 使用 12 小时制将小时显示为带前导零的数字 (例如 01:15:15 PM) H 使用 24 小时制将小时显示为不带前导零的数字 (例如 1:15:15) HH 使用 24 小时制将小时显示为带前导零的数字 (例如 01:15:15) 分钟 m 将分钟显示为不带前导零的数字 (例如 12:1:15) mm 将分钟显示为带前导零的数字 (例如 12:01:05) 秒 s 将秒显示为不带前导零的数字 (例如 12:15:5) ss 将秒显示为带前导零的数字 (例如 12:15:05) f 显示秒的小数部分 ff 将精确显示到百分之一秒 ffff 将精确显示到万分之一秒 用户自定义格式中最多可使用七个 f 符号 上午&下午 t 使用 12 小时制 中午之前任意一小时显示大写的 A 中午到 11:59 PM 之间的任一小时显示大写的 P tt 对于使用 12 小时制的区域设置 中午之前任一小时显示大写的 AM 中午到 11:59 PM 之间的任一小时显示大写的 PM 对于使用 24 小时制的区域设置，不显示任何字符 时区 z 显示不带前导零的时区偏移量 zz 显示带前导零的时区偏移量 (例如 -08) zzz 显示完整的时区偏移量 (例如 -0800) 纪元 gg 显示时代/纪元字符串 (例如 A.D.) "},"知识库/笔记/iOS 知识点/其他/正则表达式 Regular Expression.html":{"url":"知识库/笔记/iOS 知识点/其他/正则表达式 Regular Expression.html","title":"正则表达式 Regular Expression","keywords":"","body":"iOS 中的使用 URL 正则表达式 Pattern let urlPattern = \"[a-zA-Z]*://[a-zA-Z0-9/\\\\.]*\" 正则表达式常用选项 CaseInsensitive 忽略大小写 DotMatchesLineSeparators . 匹配换行符 匹配方案 . 匹配任意字符 * 匹配 0~ 任意 多个字符 ? 尽可能少的重复 匹配函数 matchesInString 重复匹配多次 pattern 如果匹配成功，生成 NSTextCheckingResult 数组 firstMatchesInString 匹配第一个 pattern 如果匹配成功，生成 NSTextCheckingResult 匹配结果 numberOfRanges 匹配的 range 计数 如果匹配成功，是 () 的数量 + 1 rangeAtIndex "},"知识库/笔记/iOS 知识点/其他/UITest 界面测试.html":{"url":"知识库/笔记/iOS 知识点/其他/UITest 界面测试.html","title":"UITest 界面测试","keywords":"","body":"UITest 界面测试 比如界面有个 TextField 和 button，你想点击 TextField 输入 我爱你，然后点击 button，就这个操作顺序，可能会重复很多次 这时，创建 UITest，录制一次上面的步骤，这个步骤就可以被记录下来，后面自己在调试时就就可直接运行录制的操作顺序，而不用一直重复点击输入了。 "},"知识库/笔记/iOS 知识点/其他/UnitTest 单元测试.html":{"url":"知识库/笔记/iOS 知识点/其他/UnitTest 单元测试.html","title":"UnitTest 单元测试","keywords":"","body":"UnitTest 单元测试 就像在 playground 中测试 某个函数或者表达式是否正确一样，不需要在模拟器或真机上运行，直接点函数左侧的运行按钮运行。 界面测试 "},"知识库/笔记/iOS 知识点.html":{"url":"知识库/笔记/iOS 知识点.html","title":"iOS 知识点","keywords":"","body":" iOS知识点 架构 UI 数据读取解析存储 内存管理 Block / Closure / 函数指针 多线程、Runloop、自动释放池 网络 Runtime 原理及应用 生命周期 OC 语言特性 常用功能集成 支付 地图 音频、视频 IM 分享 崩溃收集 第三方库的源码 其他 iOS知识点 架构 MVC MVVM 从 0 到 1 实现一个 app 的思路 对于项目从 main 函数执行之前到之后启动优化，卡顿优化和界面优化 UI UICollectionView 瀑布流 UITableView 相关的优化，底层原理等 页面布局 layoutSubviews 和 drawRect 等的区别 自己实现一个 UIScrollView 事件的传递链和响应链 界面非常卡顿怎么定位到具体的类和方法 UIView 和 CALayer 区别 页面跳转的方法和区别 页面传值的方法和区别 数据读取解析存储 JSON 生成和解析 PropertyList 生成和解析 XML 生成和解析 NSFileManager 沙盒 UserDefaults 用户偏好 NSCache 钥匙串 本地数据库 FMDB CoreData Realm Firebase iCloud 内存管理 ARC 和 MRC 的区别 @property 属性的关键字 / 修饰符 他们具体的底层实现以及区别，被问烂的知识点包括 copy 浅拷贝和深拷贝的区别 weak 的底层实现 assgin 和 weak，assgin是否可以用来修饰对象 unsafe_unretained 具体有什么区别 Autorelease pool的底层实现原理，与 Runloop 的关系， autoreleasing 关键字 Block / Closure / 函数指针 本质，基础概念 使用时要注意的地方 block的实现，如何截获自动变量的，如何修改自动变量的值的，block的几种形式 __block的本质 forwarding 指针 block怎么避免循环引用。是不是所有的block都会产生循环引用，block里面怎么避免被提前释放 多线程、Runloop、自动释放池 iOS 中多线程的几种方式，区别，使用场景，基本概念，同步异步，串行并行的区别。 GCD，写一个死锁，并行和串行队列，同步和异步的区别，GCD怎么控制最大并发数 怎么让子线程定时执行一个方法，具体的实现方法 如何控制线程的最大并发数为10，然后加载十个图片最后展示出来，具体方法 子线程的runloop是怎么执行的，它里面的 autoreleasepool 是怎么执行的。 NSMutableArray 怎么保证线程安全的。 GCD怎么避免block中的变量被提前释放 runloop实现原理 source 类型 线程保活的方式 runloop和多线程的关系，以及timer的关系 网络 浏览器输入url到网页显示经历了什么过程? TCP三次握手：具体是怎么握手？为什么要三次握手？两次行不行？为什么不行？三次握手，第二次和第三次分别因为什么? TCP是如何保持可靠传输的（拥塞控制，慢启动等等概念的理解） TCP为什么要四次挥手，TIME_WAIT为什么至少设置两倍的MSL时间？ TCP三次握手的详细数据传递，四次挥手详细数据内容，数据包组成、TIME_WAIT状态，2MSL，RTT，重传、滑动窗口、拥塞原理等等 TCP、UDP面向连接、无连接具体理解，他们的区别，如何将 UDP 改造成和 TCP 功能相似 TCP/IP四层协议，OSI七层协议，每层都有啥对应的协议，原理是啥 http报文结构，http中超文本超是啥意思，http请求的组成 http 报文头部含有什么，multipart了解吗 http的状态码，200，304，301，http请求报文，响应报文 get和post请求的区别？什么情况下用到？POST传输的数据都有哪些格式呢（这里需要搞定http各种请求传输的数据格式） 描述一次完整的http请求 什么是cookie，什么是session，区别联系，cookie的本质是什么 http1.0，1.1，2.0的区别 https有几次握手和挥手？https的原理。http有几次挥手和握手？TLS在哪一网络层，基本原理是什么？ https与中间人攻击 HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数 HTTPS是什么？握手过程，SSL原理，非对称加密了解多少 证书是干什么用的 弱网优化 Runtime 原理及应用 KVO 的底层原理，自己实现 KVC 的底层原理，自己实现 NSNotification 的底层原理，是同步还是一部，如何实现一个，如果在子线程接收一个通知能不能接收到 消息的动态转发 给 Category 添加属性，关联对象都有几种形式 method swizzling 怎么获取已上架app崩溃日志？ 怎么为系统类添加存储属性？ 说一说类的结构，运行时中的class都有什么属性，property都有什么属性 说一说isa指到NSObject的那个过程 Category的本质，load方法什么时候加载，Category重写了父类的方*怎样，底层源码 ，如果两个Category和一个基类，都有同名方法，先执行哪个 property会自动生成什么，如果此时已经有下划线_name的实例变量了那会生成什么 load 和 initialize 生命周期 app 的声生命周期 控制器的生命周期 视图的生命周期 OC 语言特性 OC 和 C 的区别， OC 和 Java、C++ 的区别 iOS 中的协议 OC 动态性 C 语言如何动态的交换两个方法的实现 常用功能集成 支付 支付宝 微信 银联 Apple Pay 地图 百度地图 高德地图 苹果地图 音频、视频 AVPlayer AVMediaPlayer 直播 点播 IM XMPP 融云 分享 友盟 崩溃收集 bugly 第三方库的源码 其他 一个 int 类型的值，被 @ 包装成 NSNumber 类型，传递到一个接受 id 类型的方法参数中，这个值能不能保持正确 在 iPad 上面，分屏功能，拖拽 wps 的文件到 qq 的过程是怎么实现的 (进程间通信的方法) 如何实现 dispatch_once Instrument 的使用 热修复用过吗，平时版本怎么迭代，线上 bug 怎么修复？ "},"知识库/笔记/iOS 知识点/APP开发步骤、流程.html":{"url":"知识库/笔记/iOS 知识点/APP开发步骤、流程.html","title":"APP开发步骤、流程","keywords":"","body":" APP开发步骤、流程 分析功能需求 流程 画界面 数据处理 逻辑处理(用户交互) APP开发步骤、流程 分析功能需求 流程 画界面 -- 对接口(获取数据) -- 展示数据 -- 用户交互 -- 数据处理 -- 保存数据 画界面 创建UI控件并布局【在View类中进行】 纯代码形式 storyboard【中创建的是一个个UIKit类的单例对象，可以自定义UIKit的子类“绑定”它来添加更多自定义控制】 xib【单独创建一个UIKit类的单例对象，可以跟这个UIKit类“绑定”来实现更多自定义控制】 SwiftUI 数据处理 获取 网络(对接口) 使用AFN封装网络工具单例，传入参数访问接口地址，从网络获取到JSON、XML、pList等格式的Data(二进制数据) 本地 在bundle的话，用bundle的urlForResource获取到路径URL 在沙盒的话，找到沙盒路径URL 用data的contentsOfUrl创建Data(二进制数据) 解析(反序列化，字典转模型) 分析要获取的数据，根据其属性创建对应的model(数据模型类),必须有两个符合规范的构造方法，可以从字典直接转换为数据模型（可使用YYModel快速实现） 在视图控制器中设置字典数组属性，并且重写其getter方法，让其可以在懒加载时直接将把从存储介质获得的字典数组，通过遍历将其元素(数据字典)转换为数据模型，并存储到此字典数组中返回。 使用JSONSerialization、JSONDecoder、PropertyListSerialization、SAX或DOM等将获取到的二进制数据解析为数组或字典 将数据数组或字典转换成数据模型数组 展示 创建自定义view的类(创建一个model属性，和与model属性的属性对应的用来显示其内容的控件属性，重写model属性的setter方法setModel，在其中将数据赋值给相应控件来显示, 必须有两个符合规范的构造方法, 如果视图需要从文件获取数据，则创建一个同名构造方法，在其中直接获取好数据赋值给视图属性，然后返回此视图，记得控制器中只需得到一个已经fully ready，只需和数据模型相结合的视图了) 创建xib文件，将view size设置为freeform，然后设置view的尺寸，为所有子控件添加好尺寸 将model数据和view相结合，调用视图的setModel方法即可 展示数据【在Controller类中进行】 直接将模型传递给View类 在set方法中为控件赋值来展示数据 生成(序列化) 将模型数据数组转换为json、xml、plist等二进制形式data 存储(持久化) 存储在bundle, 沙盒, iCloud等地方 逻辑处理(用户交互) 用户交互【】 监听屏幕事件(用户交互) 为屏幕控件注册事件add target 屏幕控件通过调用代理协议的方法名通知遵守了代理协议，即实现了代理协议方法的对象 通过函数指针、block、closure等方式回调 处理屏幕事件 做相应的反应 获取到用户的数据，生成一定格式并保存 做动画 跳转到下个场景 进行网络连接 展示某些数据 ... ... "},"知识库/笔记/iOS 知识点/项目/项目简介.html":{"url":"知识库/笔记/iOS 知识点/项目/项目简介.html","title":"项目","keywords":"","body":" 项目简介 项目组 项目文档 项目架构 分配任务 项目简介 项目组 移动开发组 (Android 和 iOS) 服务器(web)开发组 产品需求组 测试组 美工组 ... 项目文档 需求文档 接口文档 开发文档 产品文档 ... 项目架构 UI 界面层 业务类层 网络处理层 工具类层 ... 分配任务 按照功能和模块分 按照项目架构的层次分 ... "},"知识库/笔记/iOS 知识点/项目/项目部署.html":{"url":"知识库/笔记/iOS 知识点/项目/项目部署.html","title":"项目部署","keywords":"","body":" 项目部署 开源中国社区 官方网站 与 GitHUB 对比 使用 私钥秘钥的应用场景 网络间传递加密信息时 认证、确认身份时 项目部署 开源中国社区 官方网站 https://git.oschina.net 开源中国社区成立于2008年8月，其目的是为中国的IT技术人员提供一个全面的、快捷更新的用来检索开源软件以及交流使用开源经验的平台 目前国内很多公司将项目部署在OSChina 与 GitHUB 对比 服务器在国内，速度更快 免费账户同样可以建立 私有 项目，而 GitHUB 上建立私有项目要付费【已免费】 使用 注册账号 建议使用网易的邮箱，使用其他免费邮箱可能收不到验证码 添加 SSH 公钥 Public Key 私钥是系统随机生成的，公钥是由私钥计算得出的，钱包地址是由公钥计算得出的，也就是：私钥——公钥——钱包地址，这样一个过程； 数字签名，是由交易信息＋私钥信息计算得出的，因为数字签名隐含私钥信息，所以可以证明自己的身份 公钥负责加密，私钥负责解密 公钥全网公开，我用依依的公钥给信息加密，依依用自己的私钥可以解密 私钥负责签名，公钥负责验证 我给依依发信息，我加上我自己的私钥信息形成数字签名，依依用我的公钥来验证，验证成功就证明的确是我发送的信息。 SSHKey 示意图如下 开源中国帮助文档地址: https://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys 进入终端，并输入以下命令 # 生成 RSA 密钥对 # 1> \"\" 中输入个人邮箱 # 2> 提示输入存储密钥对的文件夹名称，直接回车 # 3> 提示输入密码，可以随便输入，只要本次能够记住即可 $ ssh-keygen -t rsa -C \"xxx@126.com\" # 查看公钥内容 $ cat ~/.ssh/id_rsa.pub 将公钥内容复制并粘贴到 https://git.oschina.net/profile/sshkeys 测试公钥 # 测试 SSH 连接 $ ssh -T git@git.oschina.net # 终端提示 `Welcome to Git@OSC，刀哥` 书名连接成功 新建项目 克隆项目 # 切换至项目目录 $ cd 项目目录[从finder拖拽] # 克隆项目，地址可以在项目首页复制 $ git clone git@git.oschina.net:xxx/ProjectName.git 添加 gitignore 1> 将 Swift.gitignore 复制到项目目录 2> 进入终端 # cd 项目目录目录[从finder拖拽] $ mv Swift.gitignore .gitignore 提示: 从 http://github.com/github/gitignore 获取最新版本的 gitignore 文件 添加 .gitignore 文件之后，每次提交时不会将个人的项目设置信息 (例如：上次代开的文件，调试断点等) 提交到服务器，在团队开发中非常重要 提示: 是否知道 .gitignore 是是否有团队开发经验的重要特征 私钥秘钥的应用场景 始终记得: 公钥可以随便给人，而私钥要保密 网络间传递加密信息时 【这个场景下公钥用来加密信息，私钥用来解密信息】 客户端生成密钥对AB，把公钥B给服务器 服务器生成密钥对CD，把公钥D给客户端 客户端给服务器发消息时用服务器给的公钥D加密，服务器收到后用自己的私钥C解密 服务器给客户端发消息时用客户端给的公钥B加密，客户端收到后用自己的私钥A解密 认证、确认身份时 【在这个场景下，私钥用来加密，公钥用来解密了】 数字签名、证书 客户端输入了一个网址给服务器发送了一个请求以后，确实拿到了服务器返回的公钥，但是这个服务器是不是冒充的它本意想访问的那个服务器是不确定的。 客户端要求服务器去一家双方都认可的权威的证书机构[如公安局]，公安局用自己的私钥将服务器的公钥加密生成一个数字证书，客户端给公安局打电话拿到了用来从数字证书中解密服务器公钥的公钥，这样当用户可以使用公安局给的公钥正常获得服务器的公钥时，就可以确定这个服务器是真正的服务器。 "},"知识库/笔记/iOS 知识点/项目/项目架构.html":{"url":"知识库/笔记/iOS 知识点/项目/项目架构.html","title":"项目架构","keywords":"","body":" 架构 项目架构的重要性 项目架构 项目架构中的技术点 代码加载根控制器 通过反射机制使用字典加载各分控制器 架构 项目架构的重要性 走向工作岗位之后，一般会遇到两种工作情况： 新项目开发 通常在项目开始之前，公司的产品经理会提供完整的产品原型图，或功能设计文档 通过对这些文档的解读，能够梳理出目标项目的整体架构，从而协助项目框架的搭建 旧项目维护 很多老项目是缺乏文档的，这种情况在一些小公司中表现尤为突出 要想快速上手一个老项目，首先运行项目，并且整理项目整体框架结构 然后用整理出的框架结构与代码结构相互印证，无疑可以对了解项目的整体架构起到重要的辅助 综上所述，无论是新项目，还是老项目，在开发之前确定项目的主题架构都是非常重要，也是十分必要的！ 项目架构 UI 界面层 业务类层 网络处理层 工具类层 ... 项目架构中的技术点 代码加载根控制器 实例应用 JL微博_SceneDelegate 通过反射机制使用字典加载各分控制器 实例应用 JL微博_JLMainViewController "},"知识库/笔记/iOS 知识点/项目/MVC 和 MVVM.html":{"url":"知识库/笔记/iOS 知识点/项目/MVC 和 MVVM.html","title":"MVC 和 MVVM","keywords":"","body":" MVVM MVC 回顾 MVVM MVVM 的优点 MVVM MVVM 是 Model-View-ViewModel 的简写，MVVM 和 MVC 一样，主要目的是分离视图 (View) 和模型 (Model) 用一个 viewModel 为整个视图中所有控件提供数据，控制器只负责刷新一下就行，大大减少了控制器中的代码 V 视图【View + Controller】 VM 视图模型【viewModel】 字典转模型 加载数据【调用 JLNetworkTool 方法】 下拉刷新 上拉刷新 M 数据模型【Model】 MVC 回顾 MVC 存在的问题 模型的代码很少 控制器的代码一不小心就越来越多 不好测试 MVVM MVVM 结构图 MVVM 概念 在 MVVM 中，view 和 view controller 正式联系在一起，我们把它们视为一个组件 view 和 view controller 都不能直接引用 model，而是引用视图模型 view model 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码 MVVM 使用事项 view 引用 view model ，但反过来不行 view model 引用了 model，但反过来不行 如果破坏了这些规则，便无法正确的使用 MVVM MVVM 的优点 低耦合: View 可以独立于 model 变化和修改，一个 ViewModel 可以绑定到不同的 View上 可重用性: 可以把一些试图逻辑放在一个 ViewModel 里，让很多 view 重用这段视图逻辑 独立开发: 开发人员可以专注于业务逻辑和数据开发 ViewModel，设计人员可以专注于页面设计 可测试: 通常界面是比较难于测试的，而 MVVM 模式可以针对 ViewModel 来进行测试 "},"知识库/笔记/iOS 知识点/UI/UI 界面 搭建.html":{"url":"知识库/笔记/iOS 知识点/UI/UI 界面 搭建.html","title":"UI","keywords":"","body":"UI 界面搭建 搭建方式 XIB Storyboard 纯代码 SwiftUI 如何选择 看界面的自定义程度，如果有许多自定义效果，定制程度比较高，就使用代码搭建。 如果界面是由普通的控件组成，则用storyboard。 XIB 搭建界面 加载视图控制器时，如果 XIB 和 视图控制器类重名，默认构造函数会优先加载 XIB 文件 XIB 中拖的是 View 不是 ViewController XIB 的创建 加载控制器 +(instancetype)viewControllerFromXib { return [[JLRecoverPwdViewController alloc] initWithNibName:@\"JLRecoverPwdViewController\" bundle:[NSBundle mainBundle]]; } 加载 View + (instancetype)rotationView { return [[NSBundle mainBundle] loadNibNamed:@\"JLTopImageRotationView\" owner:nil options:nil][0]; } - 当 XIB 中的 根视图是控制器的根视图时 > - 给此 XIB 设置 视图控制器类 > > 将 File's Owner 中的类设置为 XIB 的类 > > - 将 视图控制器类 的 根视图 view 设置为 XIB 的 view > > 在 File's Owner 上右键将 view 与 Xib 中的 view 连接 > > - 否则会报错 > > -[UIViewController _loadViewFromNibNamed:bundle:] loaded the \"JLComposeViewController\" nib but the view outlet was not set.' - 当 XIB 中的根视图 不是控制器的根视图则不需要设置 File Owner - 如果 Xib 文件对应的是 view， 不是 控制器，那么 fileOwner 不需要设置 - Xib 中的 collectionView 不像 Storyboard 中一样，不能添加 item，创建自定义 UICollectionViewCell - 如果 collectionView 的superView 是从 Xib 中加载的，设置 itemSize 和 superView 相关的话，要在 layoutSubviews 中设置，因为 awakeFromNib 中 superView 的 size 还是 xib 中的size - 创建 Cocoa Touch 类时，只有 Controller 的子类，可以直接自动创建 Xib，view 则不行 纯代码搭建界面 直接在控制器类中自己用代码创建View，创建各种控件添加到View中，并设置frame、自动布局等 "},"知识库/笔记/iOS 知识点/UI/UI 界面间 传值.html":{"url":"知识库/笔记/iOS 知识点/UI/UI 界面间 传值.html","title":"UI 界面间 传值","keywords":"","body":"UI 界面间 传值 如果要传的值有2个以上，封装数据模型传送 传值方式 顺传值 Storyboard 拖线的话，prepareForSegue 手动 push 或 present 的话，在当时传 逆传值 代理模式 一对一，代理只能设置一次，如多次设置，只最后一次设置的起作用 block / closure 实例：私人通讯录_新建修改 通知 一对多 AddTarget "},"知识库/笔记/iOS 知识点/UI/UI 界面间 跳转.html":{"url":"知识库/笔记/iOS 知识点/UI/UI 界面间 跳转.html","title":"UI 界面间 跳转","keywords":"","body":"UI 界面间[控制器间]跳转的方式[转场] 跳转方式 控制器间拖线1：自动型segue 控制器间拖线2：手动型segue 纯代码：使用navigationController的push方法 Modal present 如何选择 如果两个控制器有业务关系用push，否则用modal push需要外包一个navigationController，modal不需要 Modal是谁负责跳转谁负责关闭 在storyboard中，连接两个控制器时依然选show，如果有导航控制器，系统会进行push跳转，即从右往左过来，否则会modal跳转，即从下往上出来。 Storyboard 控制器间拖线1：自动型segue 使用场景： 不需要做任何逻辑条件判断，一点就跳转 步骤： 从A控制器要跳转的控件拖线到B控制器 Storyboard 控制器间拖线2：手动型segue 使用场景： 点击后需要进行一些逻辑判断才能确定要不要跳转 步骤： 从A控制器上面控制器图标拖线到B控制器 给此线(segue)添加identifier 在A控制器的类文件中合适的地方调用performSegueWithIdentifier进行跳转 注意： 只要是在storyboard拖线进行的跳转，无论手动还是自动型，都会调用 prepareForSegue 这个方法，所以可以在这里做传值、设置代理等方法。(纯代码方式不调用) 纯代码: navigationController的push // 显示 let vc = JLDemoViewController() navigationController?.pushViewController(vc, animated: true) // 退出 popViewController(animated: true) 纯代码: Modal present // 显示 let vc = JLOAuthViewController() let nav = UINavigationController(rootViewController: vc) self.present(nav, animated: true, completion: nil) // 退出 dismiss(animated: true, completion: nil) "},"知识库/笔记/iOS 知识点/UI/自动布局.html":{"url":"知识库/笔记/iOS 知识点/UI/自动布局.html","title":"自动布局","keywords":"","body":"自动布局 autoResizing 和 autolayout 不能共存，用纯代码写默认是 autoresizing，用 xib 默认是 autolayout 实例应用 UI基础10 _JL微博_JLVisitorView UI基础_Day09自动布局 autoresizing【纯代码】 translatesAutoresizingMaskIntoConstraints 此属性如果设置为 true ​ 自动将它的 autresizing mask 转换为相应的约束 ​ 可以修改 frame、bounds、center 等属性来静态控制控件的位置 ​ 而 autresizing mask 完全设定了视图的位置和尺寸，所以不能再添加其它额外的约束 ​ 如果需要“自动布局”来动态计算控件的位置和尺寸，则需要将此属性设置为false，并且为此控件添加一个不冲突的约束 ​ 如果用纯代码创建控件，则此属性被系统自动设置为 true ​ 如果在 Interface Builder 中创建控件，则此属性被系统自动设置为 false If this property’s value is true, the system creates a set of constraints that duplicate the behavior specified by the view’s autoresizing mask. This also lets you modify the view’s size and location using the view’s frame, bounds, or center properties, allowing you to create a static, frame-based layout within Auto Layout. Note that the autoresizing mask constraints fully specify the view’s size and position; therefore, you cannot add additional constraints to modify this size or position without introducing conflicts. If you want to use Auto Layout to dynamically calculate the size and position of your view, you must set this property to false, and then provide a non ambiguous, nonconflicting set of constraints for the view. By default, the property is set to true for any view you programmatically create. If you add views in Interface Builder, the system automatically sets this property to false. autolayout【XIB、Storyboard】 SizeClasses 纯代码自动布局 // 自动布局 - 设置 xib 控件的自动布局，需要指定宽高约束 // 禁用 autoResizing (因为会以 autolayout 冲突) refreshView.translatesAutoresizingMaskIntoConstraints = false // 设置 中心点 X 约束 addConstraint(NSLayoutConstraint(item: refreshView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0)) // 设置宽度约束 refreshView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: refreshView.bounds.width)) Snapkit Xib 和 Storyboard 中的控件自动布局 (动态高度) Frame 中 x, y, height, width (autoResizing) 和 autoLayout 中 leading, top, trailing, bottom 是两个系统的 需要动态高度的控件，比如微博正文的 Label，使用内建默认高度，将 leading, top, trailing 设好就行，将父容器的 bottom 设置始终 >= label bottom，也可加 constant 来设定间距 上面的做法，对于 UIView 还需要先设置一个高度，因为没有内建的默认高度，而且，label 只要设置了多行(0)，会随着文字增多而撑开，但是 UIView 貌似不行，所以需要把它的 height Constraint 连线到 code中，用 code 动态改变来达到动态高度的效果 "},"知识库/笔记/iOS 知识点/UI/苹果原生代码自动布局.html":{"url":"知识库/笔记/iOS 知识点/UI/苹果原生代码自动布局.html","title":"苹果原生代码自动布局","keywords":"","body":"苹果原生代码自动布局 自动布局核心公式 view.attr1 = view2.attr2 * multiplier + constant 自动布局构造函数 NSLayoutConstraint(item: iconView, 视图 attribute: .centerY, 约束属性 relatedBy: .equal, 约束关系 toItem: **self**, 参照视图 attribute: .centerY, 参照属性 multiplier: 1.0, 乘积 constant: -60) 约束数值 如果指定 宽 高 约束 参照视图设置为 nil 参照属性选择 .notAnAttribute 自动布局类函数 NSLayoutConstraint.constraints(withVisualFormat: , VFL公式 options: [], metrics: , 约束数值字典 [String:数值] views: ) 视图字典 [String:子视图] VFL 可视化格式语言 H 水平方向 V 垂直方向 | 边界 () 包含控件的名称字符串，对应关系在 views 字典中定义 () 定义控件的宽/高，可以在 metrics 中指定 提示: VFL 通常用于连续参照关系，如果遇到居中对齐，通常直接使用参照 // 6> 遮罩图像 let dict = [\"maskIconView\":maskIconView, \"registerButton\":registerButton] let metrics = [\"spacing\":-60] addConstraints(NSLayoutConstraint.constraints( withVisualFormat: \"H:|-0-[maskIconView]-0-|\", options: [], metrics: nil, views: dict)) addConstraints(NSLayoutConstraint.constraints( withVisualFormat: \"V:|-0-[maskIconView]-spacing-[registerButton]\", options: [], metrics: metrics, views: dict)) "},"知识库/笔记/iOS 知识点/UI/UIScrollView中子控件的布局.html":{"url":"知识库/笔记/iOS 知识点/UI/UIScrollView中子控件的布局.html","title":"UIScrollView中子控件的布局","keywords":"","body":"ScrollView 中 子控件的布局 设置 有导航控制器时, scrollView 不自动调整自己的原点 self.edgesForExtendedLayout = UIRectEdgeNone; self.automaticallyAdjustsScrollViewInsets = YES; 使用 containerView 如果只有一个子视图, 且scrollView高度由子视图确定的话. // MARK: - 布局子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局 scrollView [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 布局 容器视图 [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // 已保证scrollView 的contentSize 随着 containerView 的size 变化, 但是 container的高度未确定 }]; // 布局 imgView [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.leading.top.trailing.mas_equalTo(0); }]; // 最后, 通过设置 container 的底部与最后一个子控件图片框的底部相同, 从而设置了 container 的高度与图片相同, 从而使得 scrollView 的高度与 图片相同 [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.imgView.mas_bottom); }]; } 如果有多个子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局子控件 // 设置scrollView约束 [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 设置参照视图的约束 [self.contentView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // make.height.greaterThanOrEqualTo(@0.0f); }]; // 第一个测试view的约束 [self.oneView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.contentView).offset(30); make.left.equalTo(self.contentView); make.width.mas_equalTo(200); make.height.mas_equalTo(300); }]; // 第二个测试view的约束 [self.twoView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.oneView.mas_bottom).offset(50); make.right.equalTo(self.contentView); make.width.mas_equalTo(400); make.height.mas_equalTo(500); }]; // 第三个测试view的约束 [self.threeView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.twoView.mas_bottom).offset(70); make.left.right.equalTo(self.contentView); make.height.mas_equalTo(300); }]; // 最后设置最后一个view的与参照容器view的约束 [self.contentView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.threeView.mas_bottom).offset(-10); }]; } 不使用 containerView 如果只有一个子视图, 且scrollView高度由子视图确定的话. Edges都为0, 只是说明它的大小会随着父控件变化, 并不意味着它的 contentSize 就确定了, 只有父控件的大小确定了才行 将 scrollView 的edges 都equal to 它的父控件, 或者要显示的大小. 布局 scrollView 的子控件, 如果是动态高度的话, 只先布局它除去高度外的约束 最后, 设置 scrollView 的 bottom 与最后一个子控件的bottom 相等, 相当于确定了 scrollView 的高度 // MARK: - 布局子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局 scrollView [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 布局 imgView [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // 已保证scrollView 的contentSize 随着 imgView 的size 变化, 但是 scrollView contentSize的高度仍未确定 }]; // 最后, 通过设置 scrollView 的底部与最后一个子控件imgView的底部相同,从而使得 scrollView 的高度与 图片相同 [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.imgView.mas_bottom); }]; } "},"知识库/笔记/iOS 知识点/UI/事件的传递链、响应链.html":{"url":"知识库/笔记/iOS 知识点/UI/事件的传递链、响应链.html","title":"事件的传递链、响应链","keywords":"","body":" 事件的产生和传递 如何找到最合适的控件来处理事件（hitTest） UITouch 在iOS 中不是任何对象都能处理事件，只有继承了 UIResponder 的对象才能接收并处理事件，我们称之为\"响应者对象\" UIApplication、UIViewController、UIView都继承自 UIResponder，因此它们都是响应者对象，都能够接收并处理事件 事件分类 触摸事件 加速剂事件 远程控制事件 UIResponder 内部提供以下方法处理事件 触摸事件 touchesBegan touchesMoved touchesEnded touchesCancelled 加速计事件 motionBegan motionEnded motionCancelled 远程控制事件 remoteControlReceivedWithEvent 事件的产生和传递 发生触摸事件后，系统会将该事件加入到一个由 UIApplication 管理的事件队列中 UIApplication 对象会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口 (keyWindow) 主窗口会在视图层次结构中 找到一个最合适的视图来处理触摸事件 ，但这仅仅是整个事件处理过程的第一步 找到合适的视图控件后，就会调用视图控件的touchesBegan等方法来做具体的事件处理 触摸事件的传递是从父控件传递到子控件 所以，如果父控件不能接收触摸事件，那么子控件就不能接收到触摸事件 一个View不接收触摸事件的三种情况 不接收用户交互 userInteractionEnabled = NO 隐藏 hidden = YES 透明 alpha = 0.0-0.01 UIImageView 的userInteractionEnabled默认为NO，所以UIImageView和它的子控件默认不能接收触摸事件 如何找到最合适的控件来处理事件（hitTest） 自己是否能接收触摸事件？否，事件传递到此结束 触摸点是否在自己身上？否，事件传递到此结束 从后往前遍历子控件，重复前面的两个步骤 如果没有符合条件的子控件，那么就自己最适合处理 当事件传递给一个控件的时候就会调用它的hitTest，目的是为了找最合适的view hitTest return nil，说明在自己的子控件中没有找到最合适的处理此次点击事件的view 用pointInside 判断点在不在(方法调用者)当前view的坐标系上 // 上面步骤的代码实现 @implementation JLView /// 找最合适的view /// point 是当前 view 的坐标系上的点 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // 1. 判断自己能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha = 0; i--) { // 获取子控件 UIView *childView = self.subviews[i]; // 转换坐标系 // 把自己的坐标系上的点转换成子控件坐标系上的点 CGPoint childPoint = [self convertPoint:point toView:childView]; UIView *fitView = [childView hitTest:childPoint withEvent:event]; // 如果找到更合适的来处理此次事件的subView，就将其返回 if (fitView) { return fitView; } } // 如果没有比自己更合适的view，将自己返回 return self; } UITouch 一个手指对应一个UITouch对象，保存跟手指相关的信息，比如触摸的位置、时间、jieduan "},"知识库/笔记/iOS 知识点/数据读取解析存储/数据读取、解析.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/数据读取、解析.html","title":"数据读取解析存储","keywords":"","body":" 数据读取、解析 基本数据类型的读取和存储 读取 存储 对象的存储和读取 归解档 [旧OC] 归解档[新 Swift] 注意： 数据读取、解析 基本数据类型的读取和存储 读取 文件位置 -> 数组 、字典、字符串 到数组 [NSArray arrayWithContentsOfURL:] [NSArray arrayWithContentsOfFile:] 到字典 [NSDictionary dictionaryWithContentsOfURL:] [NSDictionary dictionaryWithContentsOfFile: ] 到 字符串 [[NSString alloc] initWithData] 文件位置 -> data -> 数组、字典 文件位置 -> data [NSData dataWithContentsOfURL] [NSData dataWithContentsOfFile] data -> 数组 或 字典 json data 解析成 JSONObject, 即 数组 或 字典 NSArray *array = [NSJSONSerialization JSONObjectWithData: data]; NSDictionary *dict = [NSJSONSerialization JSONObjectWithData: data]; pList data 解析成 数组 或 字典 NSArray *array = [NSPropertyListSerialization propertyListWithData: data] NSDictionary *dict = [NSPropertyListSerialization propertyListWithData: data] 存储 直接写入文件 字典 写到 文件 [dict writeToURL]; [dict writeToFile]; 数组 写到 文件 [arr writeToURL]; [arr writeToFile]; 转为 data 后再 写入文件 注: 不管是 基本数据类型 还是 对象 ，都要先存到 字典 或 数组 中，最后再写入文件存到某个位置 转为 json data 字典[基本数据类型] NSData *data = [NSJSONSerialization dataWithJSONObject: dict]; 数组[基本类型数据] NSData *data = [NSJSONSerialization dataWithJSONObject: arr]; 转为 pList data NSData *data = [NSPropertyListSerialization dataWithPropertyList: dict] NSData *data = [NSPropertyListSerialization dataWithPropertyList: arr] 字符串 转为 data NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding] 将 data 写到文件 [data writeToURL]; [data writeToFile]; 对象的存储和读取 注: 不管是 基本数据类型 还是 对象 ，都要先存到 字典 或 数组 中，最后再写入文件存到某个位置 原理: 先将 自定义对象 转为 数据字典，再进行后续操作 归解档 [旧OC] 自定义对象类遵守 NSCoding 协议，实现两个可以将 对象 和 字典 互转的归解档方法，再用 NSKeyedArchiver 来和 data 互转 存储 【对象 -> data】 使对象类遵守NSCoding协议，实现如下将对象转化为数据字典 aCoder 的方法， encodeWithCoder:(NSCoder*)aCoder 直接归档写入文件并存储到位置 [NSKeyedArchiver archiveRootObject: toFile:] 或 自定义对象 -> data -> 写到文件并存储 将 自定义对象 或 自定义对象数组 归档 为 data NSData *data = [NSKeyedArchiver archivedDataWithRootObject:arr] 将 data 写入文件存储到相应位置 [data writeToURL]; [data writeToFile]; 读取 【data -> 对象】 使对象类遵守NSCoding协议，实现如下将数据字典aDecoder 转为 对象 的方法 initWithCoder:(NSCoder *)aDecoder 直接从存储位置解档成 元素为自定义对象的 数组或字典 NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithFile:] 或 存储位置 -> data -> 自定义对象数组或字典 用 存储位置 创建 data NSData data = [NSData dataWithContentsOfURL]; NSData data = [NSData dataWithContentsOfFile]; 用 data 解档生成 元素为自定义对象的 数组或字典 NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:data]; 归解档[新 Swift] 原理和 OC 旧方法一样，只不过协议换成了 Codable，一般情况下只要层层遵守Codable协议就可以成功归档解档了，如果不行，或者需要自定义归解档的属性，就实现下面两个方法。 类对象只要可以归解档了，也就可以用 JSONEncoder 和 JSONDecoder 操作了？ /// 此 对象 对应的 数据字典 的 `键` enum CodingKeys:String, CodingKey { case word case chinesesString = \"chineses\" case meaningsArray = \"meanings\" case dateCreated = \"creation_date\" case dateModified = \"modification_date\" case frequency } /// 解档方法 /// 将 数据字典 解档为 自定义对象 /// - Parameter decoder: 数据字典 required init(from decoder: Decoder) throws { super.init() let values = try decoder.container(keyedBy: CodingKeys.self) word = try values.decode(String.self, forKey: .word) meaningsArray = try values.decode([Meaning].self, forKey: .meaningsArray) dateCreated = try values.decode(Date.self, forKey: .dateCreated) dateModified = try values.decode(Date.self, forKey: .dateModified) frequency = try values.decode(Int.self, forKey: .frequency) } /// 归档方法 /// 将 自定义对象 归档为 数据字典 /// - Parameter encoder: 数据字典 func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(word, forKey: .word) try container.encode(chinesesString, forKey: .chinesesString) try container.encode(meaningsArray, forKey: .meaningsArray) try container.encode(dateCreated, forKey: .dateCreated) try container.encode(dateModified, forKey: .dateModified) try container.encode(frequency, forKey: .frequency) } 注意： [String : Any] 或 [Any]， 在将包含 Any 类型的数组或字典使用JSONEncoder转换为 JSON 二进制 Data 时，会报错，可使用如下方法： let data = try? JSONSerialization.data(withJSONObject: arr, options: [.prettyPrinted]) let url = URL.init(fileURLWithPath: \"/Users/joyawang/Desktop/demo.json\") try? data?.write(to: url) 如果数据是自定义对象(数据模型)，将对象转换为键值对为基本数据类型的字典，再将字典存入数组中 原理： 对象 -> 字典 -> 数组[字典] -> Data obj -> dict = [obj dictionaryWithValuesForKeys] -> [dict] -> Data "},"知识库/笔记/iOS 知识点/数据读取解析存储/数据存储.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/数据存储.html","title":"数据存储","keywords":"","body":" 数据存储: 将二进制数据Data存储到不同的位置 本地存储 网络存储 数据存储: 将二进制数据Data存储到不同的位置 可存储的位置介绍 存到本地磁盘 存储在本机磁盘的一个特定目录下，Sandbox 沙盒 (可在 Files 文件 App 中本机显示) 存到系统提供的用来存储用户偏好的文件，UserDefaults 用户偏好 存到 钥匙串，用 第三方框架 SAMKeyChain 存到自己生成的二进制数据文件，再写入到沙盒的 document 目录 存到本地数据库文件(本质是生成数据库文件，算法进行管理)，再存到沙盒的 document 目录 FMDB (SQLite) CoreData 【SkillKit】 Realm Firebase 存到网络服务器磁盘 iCloud 本地存储 沙盒目录简介及获取方法 Documents 简介 保存应用产生的文件或数据，如游戏进度、涂鸦软件的绘图 目录中的文件会自动保存到iCloud上？ 不哟啊保存从网络上下载的文件 iTunes会备份 路径获取方法 // OC NSHomeDirectory NSString *document = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; // Swift let docURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) Library / Cache 简介 保存临时文件，后续需要使用。如缓存图片、离线地图数据 系统不会自动清理此目录？ 程序员需提供清理此目录的功能？ iTunes不会备份 路径获取 - (instancetype)cachePath { // 获取当前path中文件的名字 NSString *fileName = [self lastPathComponent]; // 获取沙盒中document文件夹的路径 NSString *cache = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 拼接成当前文件在沙盒cache文件夹的路径 return [cache stringByAppendingPathComponent:fileName]; } Library / Preference 简介 用户偏好，存储用户的一些偏好操作 iTunes会备份 路径获取 UserDefaults ??? 存: [[NSUserDefaults standardUserDefaults] setValue: forKey:]; 取: [[NSUserDefaults standardUserDefaults] valueForKey:]; temp 简介 保存临时文件，后续不需要使用 tmp目录中的文件，系统会自动清理 系统磁盘空间不足，会自动清理 系统重启，会清理该文件 iTunes不备份 路径获取 // OC - (instancetype)tempPath { return [NSTemporaryDirectory() stringByAppendingPathComponent:[self lastPathComponent]]; } 沙盒文件在 Files App 中本机显示 如果往本地SandBox的Documents存了文件，但是在Files中不显示，不可见，那么在info.plist中添加如下两个key UIFileSharingEnabled LSSupportsOpeningDocumentsInPlace 网络存储 iCloud 目录获取 须判断，为空则没有登录苹果账户或没打开iCloud // iCloud入口文件夹URL FileManager.default.url(forUbiquityContainerIdentifier: nil) // iCloud中Documents文件夹URL: FileManager.default.url(forUbiquityContainerIdentifier: nil)?.appendingPathComponent(\"Documents\") 在 Files 文件 App 中 iCloud 显示 如果往iCloud的Documents存了文件，但是在Files中不显示，不可见，那么在info.plist中添加如下key NSUbiquitousContainers ​ iCloud.com.Joya-Wang.VocKit ​ ​ NSUbiquitousContainerIsDocumentScopePublic ​ ​ NSUbiquitousContainerName ​ VocKit ​ NSUbiquitousContainerSupportedFolderLevels ​ Any ​ 如果添加了上面的key后在Files中依然无法看见自己的app文件夹，改变下面的CFBundleVersion也就是内建版本号buildVersionNumber。（CFBundleShortVersionString是发布版本号releaseVersionNumber) CFBundleVersion ​ 1 CloudKit Container CloudKit 开启 default container: 以当前项目 bundle id 命名 四级目录 Container【VocKit Container】 Database 【PrivateDatabase】 Private 属于当前手机icloud账户的DB，该账户登录期间，数据提交到该DB里，且只有在该账户登录时，才能取到相关记录。切换icloud账户将无法获取到。 Shared 所有人都可以访问，但只限于同bundleID的 app。（由于container 的bundle ID限制） Public IOS10新推出的，用 CKShare 创建的记录，设定一定的权限 即可被遵守相同规则的 app访问到。 Zones 【Vocabularies】【Meanings】 Records 【Vocabulary】【Meaning】 使用 //获取container，可以用ID来指定 自定义的container，也可以使用默认的。 CKContainer *myContainer = [CKContainer defaultContainer]; //获取container里的 db。这里用的是public DB CKDatabase *publicDatabase = [myContainer publicCloudDatabase]; //recordID， name必须在这个DB里是唯一的。 CKRecordID *artworkRecordID = [[CKRecordID alloc] initWithRecordName:@\"119\"]; //创建一条新的record。recordType 类似于DB的表名。 CKRecord *artworkRecord = [[CKRecord alloc] initWithRecordType:@\"Artwork\" recordID:artworkRecordID]; //record的 这种key-value 存储方式；value支持的数据类型参考 CKRecord.h 的CKRecordValue协议 artworkRecord[@\"name\"] = @\"testName\"; //新建/更改记录 CKModifyRecordsOperation *modifyRecords= [[CKModifyRecordsOperation alloc] initWithRecordsToSave:@[artworkRecord] recordIDsToDelete:nil]; modifyRecords.savePolicy=CKRecordSaveAllKeys; modifyRecords.qualityOfService=NSQualityOfServiceUserInitiated; modifyRecords.modifyRecordsCompletionBlock= ^(NSArray * savedRecords, NSArray * deletedRecordIDs, NSError * operationError){ // the completion block code here NSLog(@\"\"); }; //获取记录 [publicDatabase fetchRecordWithID:artworkRecordID completionHandler:^(CKRecord * _Nullable record, NSError * _Nullable error) { NSLog(@\"\"); }]; "},"知识库/笔记/iOS 知识点/数据读取解析存储/NSFileManager 文件管理器.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/NSFileManager 文件管理器.html","title":"NSFileManager 文件管理器","keywords":"","body":"NSFileManager 文件管理器 【像Finder一样管理文件】 初始化 [NSFileManager defaultManager] 判断 判断指定文件或文件夹是否存在 fileExistsAtPath 判断指定文件夹是否可读取 isReadableFileAtPath 判断指定文件夹或文件是否可写入 isWriteableFileAtPath 判断指定文件夹或文件是否可删除 isDeleteableFileAtPath 获取信息 获取指定文件夹或文件的属性信息 attributesOfItemAtPath 获取指定路径下的所有文件和目录，所有子目录和文件 subpathsAtPath 获取指定路径的所有子目录和文件，不包括孙子辈 contentsOfDirectoryAtPath 文件 / 文件夹操作 在指定目录创建文件 createFileAtPath 在指定目录创建文件夹 createDirectoryAtPath 拷贝文件 copyItemAtPath toPath 移动文件(剪切文件，可用来重命名) moveItemAtPath toPath 删除文件(不倒废纸篓，直接删除，谨慎使用) removeItemAtPath "},"知识库/笔记/iOS 知识点/数据读取解析存储/CoreData_SQLite.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/CoreData_SQLite.html","title":"CoreData_SQLite","keywords":"","body":" CoreData 创建数据库和数据表 数据操作 CoreData SQLite 概念简介 表 一张表 table 用来存储一类对象，表的 column / 字段 / 属性 就是对象的属性 Person 表就存储 Person 类的所有对象 Teacher 表就存储所有 Teacher 类的对象 db 一个数据库 database，可存很多不同的表，即可以存储不同类的对象 Person 表和 Teacher 表 都存在 froshims.db 数据库中 CoreData 简介 存储数据，也就是要把一个个 OC 对象，比如 Student 对象，存储到数据库中 那么需要在数据库中创建一个存储这个对象类型的表，在 FMDB 中，通过语句创建，而在 CoreData 中，通过视图界面创建 Entity，每个 Entity 对应一张表，Entity 的 attributes 对应对象的属性。 创建了一个 Entity，如 Teacher以后，默认创建了这样一个 OC 类，虽然看不见，但你可以直接使用 Teacher 这个类创建对象，也可以在 Entity 的 Codegen 里面更改，将 Entity 的属性以 Extension 的形式添加给你自己后面手动创建的 Teacher 类。 CoreData 不能执行 SQL 语句，取而代之，操作的是对象，FMDB SQLite 可以直接 SQL 语句 Core Data iOS5之后才出现的一个框架 如果创建项目时选择 Use Core Data add some code to AppDelegate Create a .xcdatamodeld file 【Data Model】就像 数据库的 Storyboard Entities (which are like a class) Attributes (which is like a var) Relationships (a var that points to other Entities) 创建数据库和数据表 【创建数据库】 在创建项目的时候选择使用 CoreData，就会在 App Delegate 中创建 Container，也就是数据库，也可以自己参照这个代码创建 【创建数据表】打开 .xcdatamodeld 文件 增加 Entity 创建 Entity，也就是创建要在数据库中存储的 类，比如 Tweet 比如 Tweet、TweetUser 为 Entity，添加 attributes，也就是为 类 添加 属性/字段 比如，为 Tweet Entity 添加如下属性 created Date类型 identifier String 类型 text String类型 创建 relationShip 在此 Entity 的 Codegen 的地方选择要自动生成和此 Entity 对应的 OC 类，比如 Tweet，或者生成那个类的 Extension 如果选择了自动生成对应的 Tweet 类，则无法再手动创建 Tweet 类并方便的添加方法，所以建议自动生成 Tweet 的 Extension，Tweet 类自己手动创建 不管这两个选择哪一个，最后在创建对象的时候 Tweet 对象就自动拥有了 entity 中设置的属性 数据操作 获取 NSPersistentContainer 和 viewContext let persistentContainer = (UIApplication.shared.delegate as! AppDelegate).persistentContainer let context:NSManagedObjectContext = persistentContainer.viewContext 数据库操作 增 // 最基本的存储一条数据到 Coredata 的方式 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 创建 Entity // 必须先创建 Tweet 类，继承自 NSManagedObject，可在 Entity 那里用 Codegen 生成 // 通过实体描述，描述出实体对象【连接Coredata的 Tweet Entity 和 Swift 的 Tweet 类？】 let tweet:Tweet = NSEntityDescription.insertNewObject(forEntityName: \"Tweet\", into: context) tweet.text = \"我的第一条推文\" // 设置对象属性 // 3. 保存Entity到数据库【上面的更改只在内存中，除非保存起来】 try? context.save() ```swift // ** 方便的存储一条数据到 Coredata 的方式 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 创建 Entity，并设置属性 let tweet = Tweet(context: context) tweet.text = \"我的第一条推文\" tweet.date = Date() // 3. 保存 Entity 到数据库 try? context.save() ``` 删 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 删除 context.delete(tweet) 改 查 // 1. 创建 request 【获取哪类对象】 let request:NSFetchRequest = Tweet.fetchRequest() // 2.设置 request 的条件【可省略?】 // 2.1 设置查询条件 let searchString = \"foo\" let predicate = NSPredicate(format: \"text contains[c] %@\", searchString) // 2.2 设置结果排序方式 let sortDescriptor = NSSortDescriptor( key:\"screenName\", ascending: true, // 根据 screenName，升序 selector: #selector(NSString.localizedStandardCompare(_:)) // can skip this ) // 2.3 将条件设置给 request request.predicate = predicate request.sortDescriptors = [sortDescriptor] // 3. 获取结果 let thetweets = try? context.fetch(request) "},"知识库/笔记/iOS 知识点/数据读取解析存储/FMDB_SQLite.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/FMDB_SQLite.html","title":"FMDB_SQLite","keywords":"","body":" FMDB SQLite 使用方法 FMDB SQLite 详见 JL微博、数据存储-FMDB SQLite 概念简介 表 一张表 table 用来存储一类对象，表的 column / 字段 / 属性 就是对象的属性 Person 表就存储 Person 类的所有对象 Teacher 表就存储所有 Teacher 类的对象 db 一个数据库 database，可存很多不同的表，即可以存储不同类的对象 Person 表和 Teacher 表 都存在 froshims.db 数据库中 FMDB 和 CoreData 异同 存储数据，也就是要把一个个 OC 对象，比如 Student 对象，存储到数据库中 那么需要在数据库中创建一个存储这个对象类型的表，在 FMDB 中，通过语句创建，而在 CoreData 中，通过视图界面创建 Entity，每个 Entity 对应一张表，Entity 的 attributes 对应对象的属性。 创建了一个 Entity，如 Teacher以后，默认创建了这样一个 OC 类，虽然看不见，但你可以直接使用 Teacher 这个类创建对象，也可以在 Entity 的 Codegen 里面更改，将 Entity 的属性以 Extension 的形式添加给你自己后面手动创建的 Teacher 类。 CoreData 不能执行 SQL 语句，取而代之，操作的是对象，FMDB SQLite 可以直接 SQL 语句 简介 什么是FMDB？ 一个iOS中SQLite API的封装库 1.是对libsqlite3库的封装，使用起来简洁、高效，没有原来的一大堆晦涩难懂、影响开发效率的C语句，更加面向对象 2.非常的轻量化、灵活 3.对于多线程的并发操作进行了处理，是线程安全的（重要特性之一） 4.因为它是OC语言封装的，只能在ios开发的时候使用，所以在实现跨平台操作的时候存在局限性 iOS FMDB数据库详解教程 FMDB Github地址 大写只是为了区分代码命令和用户信息 iOS 中 ? 代表预编译指令的占位符 安装和导入 安装 cd到项目目录 pod init vim Podfile并添加pod 'FMDB' pod install 导入libsqlite3框架 import 使用方法 创建数据库 创建 froshims.db 数据库 终端 sqlite3 froshims.db 数据库文件默认存储位置为当前用户的家目录 // MARK: 创建数据库 /// 创建数据库 - (void) createDatabase { // 1. 获取数据库文件的路径 _docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@\"%@\", _docPath); // 设置数据库名称 NSString *filename = [_docPath stringByAppendingPathComponent:@\"student.sqlite\"]; // 2. 创建数据库 _db = [FMDatabase databaseWithPath:filename]; if ([_db open]) { NSLog(@\"打开数据库成功\"); } else { NSLog(@\"打开数据库失败\"); } } 创建数据表 创建一个名为 registrants，3 个 column (列)，分别为 id，name，dorm 的数据表 终端 CREATE TABLE 'registrants' ('id' integer, 'name' varchar(255), 'dorm' varchar(255)); // MARK: 创建表 /// 创建表 - (void) createTable { BOOL result = [_db executeUpdate:@\"CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);\"]; if (result) { NSLog(@\"创建表成功\"); } else { NSLog(@\"创建表失败\"); } } 【增】新增数据 向 registrants 表添加一条数据， id, name, dorm column 中的值分别填1, 'Brian', 'Pennypacker' 终端 INSERT INTO registrants (id, name, dorm) VALUES(1, 'Brian', 'Pennypacker'); // MARK: - 增 // 插入数据 - (void) addStudent { // 插入数据 NSString *name = [NSString stringWithFormat:@\"王子涵%@\", @(mark_student)]; int age = mark_student; NSString *sex = @\"男\"; mark_student ++; // 1. executaUpdate: ?为占位符 (后面参数必须是OC对象，; 代表语句结束) BOOL result = [_db executeUpdate:@\"INSERT INTO t_student (name, age, sex) VALUES (?,?,?)\", name, @(age), sex]; //2.executeUpdateWithForamat：不确定的参数用%@，%d等来占位 （参数为原始数据类型，执行语句不区分大小写） // BOOL result = [_db executeUpdateWithFormat:@\"insert into t_student (name,age, sex) values (%@,%i,%@)\",name,age,sex]; //3.参数是数组的使用方式 // BOOL result = [_db executeUpdate:@\"INSERT INTO t_student(name,age,sex) VALUES (?,?,?);\" withArgumentsInArray:@[name,@(age),sex]]; if (result) { NSLog(@\"插入成功\"); } else { NSLog(@\"插入失败\"); } } 【删】删除数据 删除 id 为 1 的那一行数据 终端 DELETE FROM registrants WHERE id = 1; // 删除数据 - (void)deleteStudent { // 1. 占位符用? (后面参数必须是OC对象)，需要将int包装成OC对象) int idNum = 11; // BOOL result = [_db executeUpdate:@\"delete from t_student where id = ?\", @(idNum)]; // 占位符用%@，%d等 BOOL result = [_db executeUpdateWithFormat:@\"delete from t_student where name = %@\", @\"王子涵0\"]; if (result) { NSLog(@\"删除成功\"); } else { NSLog(@\"删除失败\"); } } // 删除表 - (void) deleteTable { // 如果表格存在 则销毁 BOOL result = [_db executeUpdate:@\"drop table if exists t_student\"]; if (result) { NSLog(@\"删除表成功\"); } else { NSLog(@\"删除表失败\"); } } 【改】修改 / 更新 数据 更新 registrants 表，将 id 为 1 的那一行的 dorm 改为 Canaday 终端 UPDATE registrants SET dorm = 'Canaday' WHERE id = 1; // MARK: - 改 // 修改数据 - (void) modifyStudent { // 修改学生名字 NSString *newname = @\"李浩宇\"; NSString *oldname = @\"王子涵2\"; BOOL result = [_db executeUpdateWithFormat:@\"update t_student set name = %@ where name = %@\", newname, oldname]; if (result) { NSLog(@\"修改成功\"); } else { NSLog(@\"修改失败\"); } } 【查】读取数据 读取所有数据 选择显示 registrants 这个表中的所有数据 终端 SELECT * FROM registrants; 按条件读取数据 选择显示 registrants 这个表中 dorm 是 China 的所有数据 SELECT * FROM registrants WHERE dorm = 'China'; 选择显示 registrants 这个表中 dorm 为 Africa 的所有数据的 name SELECT name FROM registrants WHERE dorm = 'Africa'; // MARK: - 查 // 查询 - (void) search { // 查询整个表 // FMResultSet *resultSet = [_db executeQuery:@\"select * from t_student\"]; // 根据条件查询 FMResultSet *resultSet = [_db executeQuery:@\"select * from t_student where id "},"知识库/笔记/iOS 知识点/数据读取解析存储/XML 的 存储 和 解析.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/XML 的 存储 和 解析.html","title":"XML 的 存储 和 解析","keywords":"","body":"XML 的 存储 和 解析 数据数组和字典与 XML Data互转 SAX的方式解析: 简介 SAX: simple API for XML 特点: iOS上解析，速度快，内存占用小，只读 SAX的解析步骤:【具体见网络通信的Day02】 加载xml数据【获取网络中的xml data】 创建NSXMLParser对象parser 设置parser的delegate 在NSXMLParserDelegate协议方法中解析XML data a. 开始解析XML文档【didStartDocument】 b. 找开始节点(包括节点的属性)【didStartElement】 c. 找节点之间的内容【foundCharacters】 d. 找结束节点【didEndElement】 e. 完成XML文档解析【parserDidEndDocument】 注意 使用KVC为对象属性赋值注意: KVC赋值的过程就是将value的地址赋值给key，即对象的属性指针指向value，所以在从网络中获取数据转模型时，模型类的属性最好设置为copy，这样在赋值的时候会复制一份value，把新value的地址赋值给key。在setValue过程中不会做类型转换，直接把value地址赋值给属性指针。这也是为什么NSNumber类型的属性，用string类型的value也可以赋值的原因。 DOM 的方式解析 简介 DOM : Document Object Model 文档对象模型(文档树模型) 把整个xml文件当成文档对象来处理，所有信息都在这个文档对象中。 特点: mac上的解析方式，iOS无法直接使用，解析过程中内存占用大，读写 一次性把xml全部加载到内存，内存消耗大 之前的SAX方式只能读取XML，DOM可以修改，添加、删除、修改节点 iOS默认不支持DOM解析(不支持NSXML这个类) 在iOS解析DOM需要使用第三方框架 GData/KissXML(XMPP中使用此框架) 适合读写比较小的XML文件 GData 解析的步骤【详见网络通信Day03，DOM解析】 将GDataXMLNode.h和m拖进项目 在build setting中搜索'Header Search Paths'，添加/usr/include/libxml2 在build setting中搜索'Other Linker Flags'，添加-lxml2 获取xml data 使用data创建document(GDataXMLDocument)对象 获取根元素(节点)document.rootElement rootElement的所有children就是一个个video对象，遍历并video对象 rootElement每个child是一个video对象，child的children是video的子标签(就是video的属性)，使用KVC赋值 rootElement每个child是一个video对象，child的attributes是video的属性(就是video的属性)，使用KVC赋值 "},"知识库/笔记/iOS 知识点/数据读取解析存储/NSCache 缓存.html":{"url":"知识库/笔记/iOS 知识点/数据读取解析存储/NSCache 缓存.html","title":"NSCache 缓存","keywords":"","body":"NSCache 缓存 - (NSCache *)cache { if(!_cache) { _cache = [[NSCache alloc] init]; _cache.countLimit = 5; _cache.delegate = self; } return _cache; } - (void)cache:(NSCache *)cache willEvictObject:(id)obj { NSLog(@\"从缓存中移除%@\", obj); } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 往缓存中存储数据 for (int i = 1; i "},"知识库/笔记/iOS 知识点/内存/内存中的五大区域.html":{"url":"知识库/笔记/iOS 知识点/内存/内存中的五大区域.html","title":"内存管理","keywords":"","body":"内存管理 内存中的五大区域 Stack 栈 Store all the information about function call executions, to store all the local variables 作用：存储局部变量(结构体变量存储于此) 回收：当局部变量的作用域被执行完毕后，此局部变量就会被系统立即回收； 特点： 声明变量时，字节空间由高地址向低地址分配； 空间相对较小，但访问效率较高 Heap 堆 / Free Store We can request memory from the heap during runtime, and that's what we do when we use malloc or new operator. Fixed in size decided at compile time, which means they don't grow while the application is running. 作用：存储OC类对象，程序员手动申请(calloc, malloc等函数) 回收：MRC下 手动回收, ARC 下自动回收 特点： 每次申请的字节地址都是从0开始，且每次地址不一定挨着，但每次申请的指定字节空间是挨在一起的、连续的 空间相对较大，但访问效率相对栈较低 BSS 段 作用：存储未初始化的全局变量、静态变量 回收：一旦初始化，转存至数据段 Static / Global 数据段 / 常量区 Store the global variables that live for the entire lifetime of the program of the application. 作用：存储已经初始化的全局变量、静态变量和常量数据 回收：直到程序结束才被回收 特点：以字符指针形式存在常量区的字符串数据不能改 Code(Text) 代码段 Store all the instructions needs to be executed; 作用：存储代码(C语言的函数、结构体类型声明代码、OC类代码[以Class对象形式存储]) 回收：程序结束回收 C 程序中使用 堆内存 C functions to use heap memory malloc returns a void pointer that gives us the address of the first byte in this block, the block of memory that is allocates. So, using malloc you kind of say that hey, give me a block of with these many bytes. calloc advance malloc. initial to 0 realloc change the size of the block of the memory. free 程序运行过程中 栈内存 的变化 At any time during the execution of the program, the function at the top of the stack is executing and rest is kind of paused waiting for the function above to return something and then is will resume execution. 堆内存 和 栈内存 的区别和各自的作用？ If the allocation of variables and functions in stack exceeds 1MB(assumption), our program will crash. Further the allocation and deallocation of memory onto the stack happens by a set rule, when a function is called, it is pushed onto the stack on top of the stack, when it is finished, it is popped and removed from the stack. It is not possible to manipulate the scope of a variable if it is on the stack. Another limitation is that, if we want to declare a large data type like an array as local valuable, we need to know the size of the array at compile time only. If we have a scenario like we have to decide how large the array will be based on some parameter during runtime then it is a problem with stack. For all these problems, like allocating large chunks of memory or keeping variable in the memory till the time we want, we have heap. Heap is also called dynamic memory and using the heap is referred to as dynamic memory allocation. So, as you see, in terms of the scope of the variable, anything allocated on the heap is not automatically deallocated when the function completes like on the stack. And, it does not need to live for the whole life time of the application like a global valuable. We can control when to free anything on the heap, when to deallocate anything on the heap. "},"知识库/笔记/iOS 知识点/内存/内存管理.html":{"url":"知识库/笔记/iOS 知识点/内存/内存管理.html","title":"内存管理","keywords":"","body":"内存管理 内存的作用 存储数据 如何将数据存储到内存中 当数据不再被使用时，占用的内存空间如何被释放 内存管理的范围 主要指的是 程序员手动申请的存放 对象 的 Heap 堆区的管理 栈、BSS段、数据段、代码段中的空间回收由系统自动管理，不需要人工干预 在iOS开发中，并没有JAVA或C#中的垃圾回收机制(运行时)，但是所有 OC 对象内部都有一个 retainCount，即引用计数器，其他对象每引用一次此对象，此对象的引用计数器加1，而每次引用完毕后，此对象的引用计数器减1，这样，当引用计数器为0时，就代表此对象不被使用了，系统就会释放 free 这个对象。 引用 refrence 当一个对象 A 的某个属性为另一个 B 对象时，这个属性是个指针类型的变量，它就保存了 B 对象在堆内存中的地址，这样就就叫做 A 引用 B 只要有 1 个对象 引用着 B，那么 B 对象就不能轻易释放，否则会出现 野指针 的问题导致程序崩溃 MRC (手动引用计数) 引用计数器: 每个对象都有1个属性，叫做 retainCount，占据 8 个字节，类型是 unsigned long 记录当前的对象被多少人使用 默认情况下，创建1个对象出来，它的引用计数器是1 当对象的引用计数器为 0 的时候，系统就会立即回收这个对象，并调用对象的 dealloc 方法 MRC 内存管理关键字 retain 在声明对象 A 的属性时，如果此属性的类型为 B OC对象，则需要使用 retain 属性修饰符，即当A的这个属性被赋值 B 对象时，B 的 retainCount，即引用计数器会加1，表示 A 引用 B，或者 A 在使用 B release 创建一个新对象后，引用计数器默认为1，所以在使用此对象后需手动 release 当 A 对象销毁时，即 A 不再使用 B 对象了，那么 A 对象必须在自己的 dealloc 方法中，向 B 发送一条 release 消息，B 的 retainCount，即引用计数器会减 1 内存管理原则 有对象的创建，就要匹配 1 个 release retain 的次数 和 release 的次数要匹配 体现在刚创建了对象，就立马匹配一个向它发送 release 谁用谁 retain，谁不用谁 release 体现在声明OC对象类型的属性时 retain 修饰符，和 dealloc 中向该属性发送 release 只有多一人使用时才 retain，少 1 人使用时才 release /// Seller 类 @interface Seller : Person /* > 货物属性的类型是 productForSale，是个 OC 对象，当此属性被赋值该对象时，会向它发送一条 retain 消息 代表该 Seller 对象 引用 此 Goods 对象 > 根据 MRC 内存管理原则，谁用谁 retain，谁不用谁 release，必须在此 Seller 类 的 dealloc 方法中向 productForSale 发送 release 代表当 Seller 对象销毁时，就结束对 Goods 对象的引用，productForSale 对象引用计数器减 1 */ @property(nonatomic, retain) Goods *productForSale; @end - (void)dealloc { [_productForSale release]; [super dealloc]; } 在 MRC 下，重写 dealloc 方法的规范 必须调用父类的 dealloc 方法，并且放在最后调用 因为子类中有父类的属性，而父类属性的 release 是放在父类的 dealloc 方法中的 为了能够释放所有的对象，必须要调用父类的 dealloc 方法 ARC (自动引用计数) 编译的时候，系统会在合适的地方插入 retain 和 release 没有任何强指针指向一个对象的时候，这个对象就会被立即回收 ARC 很好，但是最怕两个对象互相引用，这样它俩的引用计数器都不为0，所以都无法被系统释放 如果一个对象没有任何强类型的指针指向它，即便有 weak 类型的指针指向它，也会被自动释放， 表象: 只要没有强指针指向这个对象，它就会被释放 本质: 对象的引用计数器为 0 时，自动释放 weak 表示这个属性指向的对象被当前对象弱引用，即底层声明此属性时，不用 retain 关键字，即此属性被赋值时，不会向用来赋值的对象发送 retain 消息，它的引用计数器不会加 1 strong 强引用，底层有 retain 关键字，即此属性被赋值时，向用来赋值的对象发送 retain 消息，它的引用计数器会加 1 unowned ARC 和 MRC 的转换 将整个项目设为MRC Target - Build Settings - All 搜索 \"ARC\", 在 Apple Clang - Language - Objective-C 中 将 Objective-C Automatic Reference Counting 从 Yes 改为 No 将特定类设为MRC(告诉编译器，将来编译这个类时用MRC编译)禁用arc Build Phases - Compile Source - 特定类 - Compiler Flags - \"fno-objc-arc\" 将 MRC 转为 ARC Edit - Convert - To Objective-C ARC "},"知识库/笔记/iOS 知识点/内存/内存泄漏.html":{"url":"知识库/笔记/iOS 知识点/内存/内存泄漏.html","title":"内存泄漏","keywords":"","body":"内存泄漏 什么叫内存泄漏？ 指对象没有被回收，该回收的时候没有被回收，一直驻留在内存中知道程序结束 单个对象发生内存泄漏的原因 有对象的创建，没有匹配的 release retain 与 release 不匹配 在不恰当的时候，指针赋值为 nil 在方法中不当使用 retain 如何做到单个对象被正确释放 有对象的创建就要有对象的 release 有多少个 retain 就要有多少个 release 不要轻易为 1 个指针赋值为 nil，除非指针是 1 个野指针 在方法中不要轻易的为参数 retain 多个对象的内存泄漏 当 1 个对象的属性是另外 1 个对象的时候，如果对这个属性的 set 封装还是像我们基础班那样直接赋值，就会出现野指针的问题 set 方法的内存管理 在 MRC 的模式下，如果属性的类型是 OC 对象类型的，这个属性的 setter 方法应该如何写？ /// _dog 属性的 setter 方法 /// @param dog 用来赋值的 dog 对象 - (void)setDog:(Dog *)dog { // 当赋值的对象和就对象是同一对象时，什么也不做 if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值 { // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性 // 1. 就对象不再使用，向旧对象发送一条 release 消息 [_dog release]; // 2. 使用新对象，向新对象发送一条 retain 消息 _dog = [dog retain]; } } 循环 retain 当两个对象相互关联时 人对象中有 1 个车 车对象中有 1 个人 如果这两个 @property 都使用 retain，就会出现泄漏 解决方案: 1 端 retain，1 端 assign，使用 assign 的那端不再需要在 dealloc 中 release 了 "},"知识库/笔记/iOS 知识点/内存/@property.html":{"url":"知识库/笔记/iOS 知识点/内存/@property.html","title":"@property","keywords":"","body":"@property @property 的作用 @property int age; 生成一个私有的，int 类型的属性 _age；是声明在 @implementation 的大括弧中 生成 getter、setter 的声明 生成 getter、setter 的实现 setter 的实现: 将传进来的值不做任何操作直接赋值给属性 @property 可以带参数，不同的参数有不同的效果 与多线程相关 atomic: 默认的 nonatomic: 选择 nonatomic，因为效率高 【MRC下使用】和生成的 set 方法相关的参数 retain 生成的 set 方法就是 标准的 MRC 内存管理代码，不再是直接赋值了 而是先判断新旧对象是否为同一个对象，如果不是，release 旧的，retain 新的。 retain 只是生成的 set 方法是标准的 MRC 内存管理代码，不会自动的在 dealloc 中 release，所以我们还要在 dealloc 方法中手动的 release 属性指向的对象 /// 标准的 MRC 内存管理代码 /// _dog 属性的 setter 方法 /// @param dog 用来赋值的 dog 对象 - (void)setDog:(Dog *)dog { // 当赋值的对象和就对象是同一对象时，什么也不做 if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值 { // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性 // 1. 就对象不再使用，向旧对象发送一条 release 消息 [_dog release]; // 2. 使用新对象，向新对象发送一条 retain 消息 _dog = [dog retain]; } } // retain 不会生成这里的代码，需要手动 release dog - (void)dealloc { // 在此 Person 对象销毁的时候，向持有的 name 和 dog 对象分别发送 release // 让 引用计数器 减 1 [_name release]; [_dog release]; [super dealloc]; } assign 默认值，生成的 set 方法中不做其他任何操作，直接赋值 如果属性的类型是 OC 对象类型的，使用 retain 如果属性的类型是 非OC 对象类型的，使用 assign 【ARC下使用】strong 、weak 都是应用在 属性的类型 是 OC 对象的时候 大部分时候，都用 strong 只有当出现循环引用的时候，一边用 strong，一边用 weak 和生成的属性 只读、读写 有关的参数 readwrite: 默认值， getter setter 同时生成 readonly: 只生成 getter 修改生成 getter、setter 方法的名字 一般情况下别改，只在 1 个地方 当属性的类型是 BOOL 类型的时候，就更改 getter 的名字以 is 开头 "},"知识库/笔记/iOS 知识点/内存/野指针和僵尸对象.html":{"url":"知识库/笔记/iOS 知识点/内存/野指针和僵尸对象.html","title":"野指针和僵尸对象","keywords":"","body":"野指针和僵尸对象 对象回收的本质 内存回收的本质 申请1个变量，实际上就是向系统申请了指定字节数的内存空间，这些空间系统就不会再分配给别人了 当变量被回收的时候，代表变量占用的字节空间从此以后系统可以分配给别人使用了 但那个字节空间存储的数据还在那里 对象回收的本质 所谓的对象回收，指的是对象占用的空间可以分配给别人 当这个对象占用的空间没有分配给别人前，对象的数据还在 野指针 C 语言中的野指针 定义了一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，指向一块随机的内存空间，这个指针叫做野指针 OC 中的野指针 指针变量指向的对象已经被回收了，这样的指针叫野指针 僵尸对象 一个已经被释放的对象，但是它所占用的空间还没被系统分配给别人，这样的对象叫僵尸对象 开启僵尸对象功能，将会使僵尸对象内存空间不能被访问，直接报错 Edit Scheme - Run - Diagnostics - Enable Zombie Objects 使用野指针访问僵尸对象会报错，如何避免僵尸对象错误？ 当一个指针成为野指针后，将它设置为 nil 当一个指针的值为 nil 后，通过这个指针去调用对象方法时，包括使用点语法时，不会报错 只是没有任何反应 但是通过 -> 直接访问属性就会报错 无法复活一个僵尸对象 开启僵尸对象检测 通过野指针访问僵尸对象，不管僵尸对象的空间有没有分配给别人，都会报错 如何避免使用僵尸对象 当指针为野指针的时候，将其赋值为 nil "},"知识库/笔记/iOS 知识点/函数指针、Block、Closure.html":{"url":"知识库/笔记/iOS 知识点/函数指针、Block、Closure.html","title":"Block / Closure / 函数指针","keywords":"","body":"函数指针、Block、Closure的使用 函数指针 函数的声明 返回值类型 函数名称([参数列表]) { ​ 写上那段需要被重用的代码； ​ 叫做函数体 } 指向函数的指针 声明 返回值类型 (*指针名) ([参数列表]); void (*pFunction) (); 表示声明了1个指向函数的指针，名字叫做pFunction。 这个指针只能指向没有返回值，并且没有参数的函数。 int (*pFun) (int num1, int num2); 表示声明了1个指向函数的指针，名字叫做pFun. 这个指针只能指向返回值为int类型，并且有两个整型的参数的函数。 初始化 取到符合指针条件的函数的地址 函数的名称就代表函数的地址 将地址赋值给指针变量 直接将符合条件的函数的名称赋值给这个指针。 使用指针间接调用指针指向的函数 void (*pFunc) () = test; // pFunc指针就指向了test函数 pFunc(); (*pFunc)(); Block (OC) OC中 方法 的声明 -(void) demo:(NSString *)name { function body; } OC 中声明 block 类型的 变量 返回值类型 (^block名称)(参数); void (^demo)(); void (^finishedBlock)(UIImage *image); OC 中声明 block 类型的 属性 // Block类型的属性：当网络任务完成时的回调block @property (nonatomic, copy) void (^finishedBlock)(UIImage *image); OC 中声明 block 类型的 函数参数 // 接收block参数的类方法 + (instancetype) operationWithURLString:(NSString *)urlString andFinishedBlock:(void (^)(UIImage *image)) finishedBlock; OC 中 block 的初始化 // 在Xcode中输入inlineblock就会出现 void (^demo)() = ^(参数) { NSLog(@\"快快快\"); }; [self setDemo:^{ NSLog(@\"快快快\"); }]; OC 中 block 的调用 demo(); Closure (Swift) Swift 中 函数/方法 的声明 func demo(_ name: Int) -> Void { 代码 } Swift 中声明 closure 类型的变量 /// 记录显示 VC 的闭包 var competionBlock:((_ clsName:String?)->())? (参数)->(返回值类型) Swift 中声明 closure 类型的函数参数 func tokenRequest(method:JLHTTPMethod = .GET, URLString:String, parameters:[String:Any]?, name:String? = nil, data:Data? = nil, completion: @escaping (_ json:Any?, _ isSuccess:Bool)->()){ } class func loadStatus(since_id:Int64 = 0, max_id:Int64 = 0, completion: @escaping (_ list:[[String:Any]]?, _ isSuccess:Bool)->()){ } Swift 中 closure 的初始化 // 完整写法 alphaAnim.completionBlock = {(anim, isSuccess)->() in // 需要执行回调 print(\"完成回调展现控制器\") self.competionBlock?(sender.clsName) } // 简写 alphaAnim.completionBlock = {_, _ in // 需要执行回调 print(\"完成回调展现控制器\") self.competionBlock?(sender.clsName) } "},"知识库/笔记/iOS 知识点/多线程/多线程.html":{"url":"知识库/笔记/iOS 知识点/多线程/多线程.html","title":"多线程、Runloop、自动释放池","keywords":"","body":"多线程 存在的意义 在主线程(UI线程)上执行耗时任务会造成卡顿，比如网络通信、循环等 屏幕两个控件接收用户点击，一个控件点击后会执行耗时操作，这时再点击另外一个就不起作用，界面卡死了(阻塞)。 解决办法：将耗时操作放到另外一个线程去执行 概念 进程 Process 指在系统中正在运行的一个应用程序 每个进程之间是独立的，每个进程均运行在其专用的受保护的内存空间内 通过\"活动监视器\"可以插卡Mac系统中所开启的进程 线程 Thread 1个进程由多个线程组成(1个进程只要要有1个线程) 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行 主线程 一个程序运行后，默认会开启一个线程，成为”主线程“或”UI线程“，一般用来刷新UI界面，处理UI事件(比如：点击、滚动、拖拽等事件) 主线程的runloop默认开启，保证程序不退出 子线程 除了主线程都是子线程，子线程的runloop默认不开启 多线程 Multi - Thread 一个进程可以开启多个线程，多个线程可以”同时“执行不同的任务 多线程可以解决程序阻塞的问题 多线程可以提高程序的执行效率 队列 Queue 将一些耗时的任务全部添加到队列中，CPU从队列中取出任务执行 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. 串行队列 Serial Queue 这种队列中的任务一个一个的按顺序执行 并行队列 Concurrent Queue 这种队列中的任务可以好几个同时开始执行 同步 sync CPU执行当前线程的代码时，遇到Sync会等待，Sync后的代码块执行完毕再执行下段代码 异步 async CPU执行当前线程的代码时，遇到Async会直接跳过其中的代码块直接执行下段代码【此段代码另开线程执行去了】 多线程原理 CPU快速在多个线程之间切换执行 CPU调度线程的时间足够快，就造成了多线程的“同时”执行 线程执行完毕会自动销毁 多线程优缺点 优点 能适当提高程序的执行效率 能适当提高资源的利用率(cpu, 内存) 线程上的任务执行完成后，线程会自动销毁 缺点 开启线程需要占用一定的内存空间(默认情况下，每一个线程都占512KB) 如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，cpu在调用线程上的开销就越大 程序设计更加复杂，比如线程间的通信、多线程的数据共享 线程间通信 从子线程回到主线程 比如: 当图片在子线程上异步下载完成后回归到主线程上更新UI 多线程访问共享资源的问题【线程安全】 共享资源 1块资源可能会被多个线程共享，也就是多个线程可能访问同一资源 比如多线程访问同一个对象、同一个变量、同一个文件 问题 当多个线程访问同一资源时，很容易引发数据错乱和数据安全问题 互斥锁 线程同步：一个线程一个线程的执行 使用 @synchronized(锁对象) {需要锁定的代码(有对共享变量或文件的读写操作)} 特点 能有效防止因多线程抢夺资源造成的数据安全(正确)问题 但会影响程序的执行效率，因为在锁住的时候，其他线程在等待，削弱了多线程的作用，所以这个锁锁的代码越少越好 原理 每一个对象(NSObject)内部都有一个锁(变量)，当有线程要进入synchronized到代码块中会先检查对象的锁是打开还是关闭状态，如果锁是打开状态(1), 如果是线程执行到代码块内部 会先上锁(0)。 如果锁被关闭，再有线程要执行代码块就先等待，直到锁打开才可以进入。 线程执行到synchronized i 检查上锁状态 如果是开锁状态(1)转到ii 如果上锁(0)转到v ii 上锁(0) iii 执行代码块 iv 执行完毕 开锁(1) v 线程等待(就绪状态) 加锁后程序执行的效率比不加锁的时候要低，因为线程要等待锁，但是锁保证了多个线程同时操作全局变量的安全性 自旋锁 原子属性 属性的修饰符 nonatomic 非原子属性 atomic 原子属性(线程安全)，针对多线程设计的，默认值 保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值) atomic 本身就有一把锁(自旋锁) nonatomic和atomic对比 atomic：线程安全，需要消耗大量的资源 nonatomic：非线程安全，适合内存小的移动设备 iOS开发建议 所有属性都声明为nonatomic 尽量避免多线程抢夺同一资源 尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 自旋锁无法解决卖票的问题，因为读写还是分开的 互斥锁和自旋锁的区别 互斥锁 如果发现其他线程正在执行锁定代码，线程会进入休眠(就绪状态)，等其他线程时间片到打开锁后，线程会被唤醒(执行) 自旋锁 如果发现有其他线程正在锁定代码，线程会用死循环的方式，一直等待锁定的代码执行完成，自旋锁更适合执行不耗时的代码 线程安全 线程同时操作是不安全的，多个线程同时操作一个全局变量 线程安全：在多个线程进行读写操作时，仍然能够保证数据的正确 主线程(UI线程)保证线程安全 几乎所有UIKit提供的类都是线程不安全的，所有更新UI的操作都在主线程上执行 所有包含Mutable的类都是线程不安全的 多线程和网络通信的关系 多线程是为了减少卡顿，而卡顿是由于在主线程上执行了耗时任务造成的，将耗时任务另外开子线程线程去执行就会减少卡顿，而网络通信就是耗时任务，所以，在网络通信任务一般都会开子线程执行。 "},"知识库/笔记/iOS 知识点/多线程/pthread.html":{"url":"知识库/笔记/iOS 知识点/多线程/pthread.html","title":"pthread","keywords":"","body":"pthread 简介 C语言 一套通用的多线程API 适用于Unix\\Linux\\Windows等系统 跨平台\\可移植 线程生命周期程序员管理 使用难度大 创建线程的函数 pthread_create(&pthread, NULL, runATask, (__bridge void *)(name)); 参数1：线程编号变量的地址 参数2：线程的属性变量的地址 参数3：要创建的线程中要执行的函数(我们要做的任务就在这里)。这是个函数signature: void () (void*) 这个函数signature分解: 返回值类型void，函数名( _Nonnull) 和参数类型(void* _Nullable) int 是指向int类型变量的指针，void 是指向任何类型变量的指针，有点类似OC中的id 参数4: 要执行的函数的参数 返回值 int 0是成功， 非0是失败(可以是其他任何数，用来表示失败的原因) "},"知识库/笔记/iOS 知识点/多线程/NSThread.html":{"url":"知识库/笔记/iOS 知识点/多线程/NSThread.html","title":"NSThread","keywords":"","body":"NSThread 简介 OC语言 使用更加面向对象 简单易用，可直接操作线程对象 线程生命周期程序员管理 线程的状态 新建 就绪 运行 阻塞 死亡 线程的属性和方法 线程名称name 设置线程名称可以当线程执行的方法内部出现异常的时候，记录异常和当前线程 线程优先级threadPriority 线程的优先级，并不能保证谁先执行完 内核调度算法在决定该运行哪个线程时，会把线程的优先级作为考量因素，较高优先级的线程会比较低优先级的线程具有更多的运行机会。较高优先级不保证你的线程具体执行时间，只是相比较低优先级的线程，它更有可能被调度器选择执行而已。 isMainThread 使用方法 // 线程状态之 - 创建 NSThread *thr = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; // 线程状态之 - 就绪(进入可调度线程池，CPU会来给它几毫秒的执行时间) [thr start]; "},"知识库/笔记/iOS 知识点/多线程/GCD.html":{"url":"知识库/笔记/iOS 知识点/多线程/GCD.html","title":"GCD","keywords":"","body":"GCD 简介 C语言 旨在替代NSThread等线程技术 充分利用设备的多核 线程生命周期自动管理 什么是 GCD 全称是Grand Central Dispatch 纯C语言，提供了非常多强大的函数 GCD 优势 GCD是苹果公司为多核的并行运算提出的解决方案 GCD会自动利用更多的CPU内核(比如双核、四核) GCD会自动管理线程的生命周期(创建线程、调度任务、销毁线程) 程序员只需告诉GCD想要执行什么任务，不需要编写任何线程管理代码 GCD 两个核心概念 任务 Operation：要执行的耗时操作，比如打开网页、循环等 队列 Queue：用来存放任务 GCD 使用的两个步骤 创建任务：确定要做的事情 将任务添加到队列中，就自动开始执行了 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. GCD中执行任务的2个函数 同步方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block) 同步，在当前线程中执行任务，不开新线程 异步方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block) 异步，在新的线程中执行任务，会开新线程(只有开多于1个线程才能异步执行) GCD队列的2大类型 并发队列(Concurrent Dispatch Queue) 作用 可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务) 并发功能只有在异步(dispatch_async)函数下才有效 全局队列 本质就是并发队列 全局队列和并发队列的区别 全局队列一直存在，并发队列任务执行完会销毁 并发队列有名称，可以跟踪错误，全局队列没有 在ARC中不需要考虑释放内存，因为不允许调用dispatch_release(q). 在MRC中需要手动释放内存，并发队列是create创建出来的，在MRC中见到create就要release，全局队列不需要release(只有一个)。 一般使用全局队列 全局队列的参数 第一个: 服务质量(线程的优先级) 第二个: future use 串行队列(Serial Dispatch Queue) 作用 让任务一个接一个执行(一个完成后再执行下一个) 主队列 是个特殊的串行队列 在async函数中【异步执行】 不开线程(特殊之处，与一般串行队列不同)，同步执行 主队列特点: 如果主线程正在执行代码暂时不调度任务，等主线程执行结束后再执行任务 又叫全局串行队列 在sync函数中【同步执行】 程序执行不出来(死锁) 死锁的原因: 当程序执行到下面sync函数这段代码的时候 主队列：如果主线程正在执行代码，就不调度任务 同步执行：如果第一个任务没有执行，就继续等待第一个任务执行完成，再执行下一个任务此时互相等待，程序就无法往下执行(死锁) 注意: 虽然主队列也是串行队列，但它执行异步任务时不开新线程，即做dipatch_async函数的参数时, 只是等主线程当前正在执行的任务结束后再执行主队列的任务 队列 和 同异步执行的组合 sync函数 + 串行队列 特点: 不开新线程(就在当前线程)，队列中任务一个一个按顺序执行 sync函数 + 并行队列 特点: 不开线程(只在当前线程)，队列中任务一个一个按顺序执行(因为只有一个线程，无法异步) async函数 + 串行队列 特点: 新开一个线程，队列中任务一个一个按顺序执行 注意: 虽然主队列也是串行队列，但它执行异步任务时不开新线程，只是等主线程当前正在执行的任务结束后再执行主队列的任务 async函数 + 并行队列 特点: 新开多个线程，无序执行 使用方法 选择一个用来存放任务的合适的队列 使用dispatch_async或dispatch_sync函数将任务block添加到队列并开始执行 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. // OC - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // // 创建队列 // dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // // 创建任务 // dispatch_block_t task = ^ { // NSLog(@\"%@\", [NSThread currentThread]); // }; // // 将任务添加到队列 // dispatch_async(queue, task); // 简易用法 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"%@\", [NSThread currentThread]); }); } // Swift // 模拟从网络异步加载视图配置信息 JSON，并存储到 沙盒中 DispatchQueue.global().async { let url = Bundle.main.url(forResource: \"main.json\", withExtension: nil) let data = try! Data(contentsOf: url!) let docPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] let docUrl = URL(fileURLWithPath: docPath) let fileURL = docUrl.appendingPathComponent(\"main.json\") print(fileURL.absoluteString) try? data.write(to: fileURL) } 理解方式 当 CPU 开始执行某线程上的代码时: 执行到async函数代码块时，会\"直接跳过\"函数参数Queue中的任务(代码块)[其实是开了另外的线程去执行Queue中的任务]，直接执行后面的代码。 执行到sync函数代码块时，当前线程会等待函数参数Queue中所有任务(代码块)执行完毕，才继续执行后面的代码 而Queue中的所有任务(代码块)，会根据Queue种类不同有不同的执行方式: serial串行执行: 所有任务一个一个按顺序执行 concurrent并发执行: 几个任务同时开始执行，高效率省时间，但是没有顺序 同时使用同步和异步保证任务执行顺序 // 模拟app store购买的过程 // 验证密码 - 扣费 - 下载应用 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 因为这三个环节都是通过网络，会是耗时操作，所以不能同步执行，不然会导致卡死 // // 这里是异步，所以肯定会开一个线程执行里面这三个添加任务的代码 dispatch_async(dispatch_get_global_queue(0,0), ^{ // 这里是同步(不开新线程)，所以在当前线程按顺序执行(不管什么队列) dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"1. 验证密码: %@\", [NSThread currentThread]); }); // 这里是同步(不开新线程)，所以在当前线程按顺序执行(不管什么队列) dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"2. 扣费: %@\", [NSThread currentThread]); }); // 这里是异步(开新线程执行，也可能会线程重用)，但是只有这一个任务了，前面两个任务都完成了，所以这最后一个任务无所谓按顺序与否 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"3. 下载应用: %@\", [NSThread currentThread]); }); }); } barrier阻塞 主要用于在多个异步操作完成后，统一对非线程安全的对象进行更新 适合于大规模的I/O操作 当访问数据库或文件的时候，更新数据的时候不能和其他更新或读取的操作在同一时间执行，可以使用调度组，不过有点复杂。 可以使用dispatch_barrier_async解决 延迟执行 // OC NSLog(@\"三秒后打印我爱你\"); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"我爱你\"); }); // Swift // 为了防止还没滚到顶部，就已经开始刷新数据了 DispatchQueue.main.asyncAfter(deadline: .now() + 1) { tvc.loadData() // 刷新新微博后，取消 tabbar 和 APP 红点 self.tabBar.items?[0].badgeValue = nil UIApplication.shared.applicationIconBadgeNumber = 0 } 一次执行 /* 原理是在常量区设置了一个变量，执行一次后设个值，以后每次过来检查如果是这个值就不执行 */ for (int i = 0; i 调度组监听所有任务完成通知 要异步(多个线程)下载三首歌，三首歌全部下载完成后通知用户，就可以使用dispatch_group【但并不能保证下载完成的先后顺序】 // Swift /* 1) loadImage 是 SDWebImage 的核心方法 2) 图像下载完成后，会自动保存在沙盒中，文件路径是 URL 的 md5 3) 如果沙盒中已经存在缓存的图像，后续使用 SD 通过 URL 加载图像，都会加载本地沙盒的图像 4) 不会发起网络请求，同时，回调方法，同样会调用！ 5) 方法还是同样的方法，调用还是同样的调用，不过内部不会再次发起网络请求！ ***注意*** 如果缓存的图像累计很大，要找后台要接口！ */ /// 缓存只有一张图像的微博的图像 /// - Parameter list: 本次下载的视图模型数组 private func cacheSingleImage(list:[JLStatusViewModel], finished: @escaping (_ isSuccess:Bool, _ shouldRefresh:Bool)->()) { // 记录所有单张图片缓存的内存大小 var cacheSize = 0 // 创建调度组 let group = DispatchGroup() // 遍历此次获取的微博数组 list.forEach{(vm) in // 找到只有 1 张图片的，进行下载缓存 if vm.picURLS?.count == 1, let urlStr = vm.picURLS?.first?.thumbnail_pic { // `入组` 将要执行图片下载任务 group.enter() // 用 SD 下载此图片并自动缓存 SDWebImageManager.shared.loadImage(with: URL(string: urlStr), options: [], context: nil, progress: nil) { (image, data, nil, _, _, _) in cacheSize += data?.count ?? 0 // 更新单个图片的尺寸 if let image = image { vm.updateSingleImageSize(with: image) } // `出组` 此图片任务完成， group.leave() } } } // 监听调度组任务完成情况 group.notify(queue: .main) { print(\"此次所有单张图片缓存完毕，大小为: \\(cacheSize / 1024)kb\") // 完成回调 finished(true, true) } } "},"知识库/笔记/iOS 知识点/多线程/NSOperation.html":{"url":"知识库/笔记/iOS 知识点/多线程/NSOperation.html","title":"NSOperation","keywords":"","body":" NSOperation NSOperation VS GCD NSOperation 其实就是要往队列里添加的耗时任务 简介 OC语言 基于GCD(底层是GCD) 比GCD多了一些更简单实用的功能 使用更加面向对象 线程生命周期自动管理 特点 NSOperation是一个抽象类 不能直接使用(方法只有声明没有实现) 用来约束子类都具有共同的属性和方法 NSOperation的子类 NSInvocationOperation 创建NSInvocationOperation对象 调用start方法开始执行操作 默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行，只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作。 NSBlockOperation 创建NSBlockOperation对象 通过addExecutionBlock:方法添加更多操作 只要NSBlockOperation封装的操作数>1，就会异步执行操作 自定义operation 即通过创建NSOperation的子类，可以定制一些功能，需要重写main方法，添加自动释放池等 目的: 封装如 下载图片 这样的耗时操作 自定义Operation，模拟下载图片 创建HMDownloaderOperation类，继承自NSOperation 重写自定义Operation的main方法 重写- (void)main方法，在里面实现想执行的任务 自己创建自动释放池(因为如果是异步操作，无法访问主线程的自动释放池) 经常通过-(BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 在controller中调用start方法，或者添加到队列。main方法会被调用 NSOperationQueue 队列 存放并执行操作的地方 使用步骤 先将需要执行的操作封装到一个 NSOperation 对象中 然后将 NSOperation 对象添加到 NSOperationQueue 中 系统会自动将 NSOperationQueue 中的 NSOperation 取出来执行 将取出来的 NSOperation 封装的操作放到一条新线程中执行 队列中操作的执行的过程 把操作添加到队列[self.queue addOperationWithBlock]; 去线程池取空闲的线程，如果没有就创建新线程 把操作交给从线程池中取出的线程执行 执行完成后，把线程再放回线程池中 重复2,3,4直到所有操作都执行完 线程间通信 从子线程回到主线程 比如: 当图片在子线程上异步下载完成后回归到主线程上更新UI 主队列 添加到主队列的操作，最终都执行在主线程上 当前队列 获取当前操作的队列 [NSOperationQueue currentQueue]; 最大并发数 什么是最大并发数？ 最多同时执行的任务数 比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 maxConcurrentOperationCount setMaxtConcurrentOperationCount 队列的暂停、取消、恢复 取消队列的所有操作 cancelAllOperations; 也可以调用NSOperation的cancel方法取消单个操作 暂停和恢复队列 setSuspended // YES代表暂停队列，NO代表恢复队列执行 isSuspended 操作的优先级 和 监听操作完成 不设置优先级的话，可以明显看出开了两个线程切换执行op1和op2 可以设置操作(任务)的优先级(服务质量),但并不能保证高优先级的任务执行过程中，低优先级的任务不执行 op1.qualityOfService = NSQualityOfServiceUserInteractive; 可以设置监听某个任务完成后回调某个方法 [op1 setCompletionBlock:^{ NSLog(@\"-----------------op1 finished--------------\"); }]; 操作依赖 (保证任务执行顺序) NSOperation之间可以设置依赖来保证执行顺序 下载、解压和升级完成分别在不同的线程上执行，用add dependency来确保执行顺序 下载和解压操作在子线程，升级完成在主线程执行，依然可以添加依赖。 NSOperation VS GCD GCD iOS4.0推出，主要针对多核cpu做了优化，是C语言的技术 GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数 GCD提供了一些NSOperation不具备的功能 一次性执行 延迟执行 调度组 NSOperation NSOperation是iOS2.0推出的，iOS4之后重写了NSOperation 将操作NSOperation(异步的任务)添加到队列(并发队列)，就会执行 NSOperation中提供的方便的操作 最大并发数 队列的暂定/继续(暂停的是没有执行的任务) 取消所有的操作 执行操作之间的依赖关系(GCD中用同步就可以实现) "},"知识库/笔记/iOS 知识点/多线程/Runloop 消息循环.html":{"url":"知识库/笔记/iOS 知识点/多线程/Runloop 消息循环.html","title":"Runloop 消息循环","keywords":"","body":"Runloop 消息循环 简介 消息循环属于线程，主线程的消息循环默认开启着，里面在等待着屏幕上的用户输入事件。 相当于给当前的代码这里插入一个while死循环而已，然后while里面可以运行代码。while循环体内的代码运行在当前线程的消息循环上，而外面的代码运行在当前线程上(非消息循环上)。 作用 保证程序不退出 接收和处理用户的事件【主线程的消息循环(while死循环)在程序加载完毕就一直在等待处理用户的输入事件】 原理 就是一个死循环 在每次循环中，一直卡在等待用户输入信息的位置(用户触摸屏幕) 当用户点击屏幕(产生事件)，就会有相应的处理事件的方法被调用 这个方法执行完毕后，这次消息循环完毕，又重新开始下一次消息循环 注意【消息循环模式会变化】 注意： 因为runloop在不同的情况下有不同的模式，比如当屏幕上的scrollView被拖动时，主线程的runloop就会由defaultMode模式变为UITrackingRunLoopMode，但是这两个模式都属于commonModes。如果timer源被添加在runloop的defaultMode，那它的方法在trackingMode就不会被执行，所以可以将它添加在runloop的commonModes来解决问题。 自动释放池 存在意义 / 作用 如果一个循环创建了大量的临时对象 你可以在循环内部使用自动释放池在下次循环开始前处理掉那些对象。这样可以减少程序的最大内存使用量。 如果你创建了一个子线程。 你必须在子线程开始执行前立即创建自动释放池，否则你的程序会发生内存泄漏。 自动释放池 标记为autorelease的对象，会被添加到最近一次创建的自动释放池中 当自动释放池被销毁或耗尽时，会向自动释放池中的所有对象发送release消息 自动释放池是什么时候创建的？又是什么时候销毁的？ 每一次主线程的消息循环开始的时候会先创建自动释放池 消息循环结束前，会释放自动释放池 自动释放池被销毁或耗尽时会向池中所有对象发送release消息，释放所有autorelease的对象 使用NSThread做多线程开发时，需要在线程调度方法中手动添加自动释放池 "},"知识库/笔记/iOS 知识点/网络/网络通信.html":{"url":"知识库/笔记/iOS 知识点/网络/网络通信.html","title":"网络","keywords":"","body":" 网络通信 网络通信的过程 - 理论 网络通信的过程 - 实践 遵守 HTTP 协议的网络通信 网络通信 详见 【网络新闻 App】、【网络通信】 网络的实际用途 登录验证 验证服务器上的用户名和密码，登录 发送HTTP请求，使用GET方法，将用户名和密码拼在url中 发送HTTP请求，使用POST方法，将用户名和密码拼在请求体中 获取 data 二进制数据 (html, json, plist, xml等) 上传文件 上传图片、视频等 发送HTTP请求，使用POST方法，将要上传的文件拼在请求体中，需要服务器端php文件支持 发送HTTP请求，通过session，使用PUT方法，不需要php支持，需要配置服务器webDav服务 上传单个文件 上传多个文件 暂停 继续 取消 断点续传 进度显示 下载文件 下载图片、视频等 概念 客户端: 应用 C/S(Client/Server ) B/S(Browser/Server) 服务器: 为客户端提供服务、数据、资源的机器 局域网服务器 外网服务器 本地测试服务器 服务器软件 Apache Nginx 请求：客户端向服务器索取数据 响应：服务器对客户端的请求做出反应，一般是返回给客户端数据 网络通信的过程 - 理论 【理论】网络通信的过程 网络模型 OSI 和 TCP/IP 存在的意义 数据传输时，数据流流经的每一段，也就是数据从网络一端传到另一端要经过的步骤 数据传输的流程 Joya微信打字发送hello到YL手机的微信 微信(应用层)给这段字加上http协议的字段->传输层给这段字加上加上微信的端口信息【TCP(UDP)协议的字段】->网络层给这段字加上Joya手机的IP地址信息[IP协议的字段等]->网络接入层再添加一些信息?就进入网线传递了->到YL所在的网络中后经过相反的拆信息的步骤显示在YL手机的微信上。 OSI模型(Open System Interconnection Model) Application Layer 应用层 Presentation Layer 表示层 Session Layer 会话层 Transport Layer 传输层 四层交换机、四层路由器 Network Layer 网络层 路由器、三层交换机 Datalink Layer 数据连接层 网桥、以太网交换机、网卡 Physical Layer 物理层 中继器、集线器、双绞线 TCP/IP 模型 应用层: 对应OSI的前三层，为用户提供所需的服务如FTP, Telnet, DNS,SMTP,HTTP等。浏览器应用对应http协议，文件传输软件对应ftp协议等。 传输层: 负责为要发送的数据加入始发程序的端口号或者按照接收到的数据的端口号在主机上寻找对应的指定的应用程序 为应用层提供端到端的通信功能，保证了数据包的传输顺序及数据完整性。 端到端，即端口到端口，也就是一个主机上的应用到另一个主机上的应用 两个主要传输协议：TCP和UDP TCP(传输控制协议) 可靠的、通过“三次握手”来连接的数据传输服务，一对一 UDP(用户数据报协议) 不保证可靠、无连接的数据传输服务，广播 网络层 负责为要发送的数据加入自己主机的和要发送到的主机的IP地址信息，或者接收网络上属于自己主机IP地址的信息数据 解决主机到主机的通信问题。它所保护的协议涉及数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。 该层有3个主要协议：IP网际协议、互联网组管理协议(IGMP)和互联网控制报文协议(ICMP)。 网络接入层 （网卡层面）对应数据链路层和物理层 负责监视数据在主机和网络之间的交换 网络通信的过程 - 实践 Socket 通信 介绍 位于应用层和传输层之间，应用程序构造数据，用户输入hello，应用层的软件把数据传给socket，socket把数据封装传输给传输层、网络层等。 Socket又称”套接字“，应用程序通过”套接字“向网络发送请求或向网络做出应答 网络通信其实就是Socket之间的通信 数据在两个Socket之间通过IO传输数据 Socket是纯C语言的，是跨平台的 HTTP协议时基于Socket的，HTTP协议的底层使用的就是Socket 作用 从这里开始传输数据，socket封装应用层App传入的用户要发送的数据，再将其传输给传输层、网络层直到网络通信的另一端(服务器) 通信过程 创建Socket 使用Socket()函数 连接到服务器 使用connect()函数 发送数据给服务器 使用send()函数 从服务器接收数据 使用recv()函数 关闭连接 使用close()函数 遵守 HTTP 协议的网络通信 请求 request 向服务器发送的数据 请求头、请求体 HTTP 请求 HTTP Request，即要发送给服务器的数据，遵守HTTP协议固定格式的数据 HTTP 请求方法 GET GET一般是获取服务器上的数据，可向服务器传递少量数据 优点 GET速度相对较快 GET方式是通过URL传递数据，效率高 缺点 请求的数据在URL上，相对不安全 login.php?username=zs&pwd=123456 GET请求的结果能够被浏览器缓存 URL 中的参数 a. login.php负责处理登录过程的服务器脚本 b. ?后面跟要传到服务器上的参数(http协议的一部分) c. 参数以 键=值 的形式传递 d. 如果有多个参数使用&连接 http://127.0.0.1/php/login.php?username=admin&password=123 e. 参数中如果有中文和空格创建URL会失败, 需要使用%转义，进行URL编码 // 获取网络服务器上JSON数据 NSString *username = @\"张三\"; NSString *password = @\"zhan\"; NSString *urlString = [NSString stringWithFormat:@\"http://127.0.0.1/php/login.php?username=%@&password=%@\",username, password]; // 如果url字符串中有汉字或空格，要对url字符串中?后面的空格或者汉字做百分号转义 urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL *url = [NSURL URLWithString:urlString]; POST POST速度相对GET较慢 传递大量数据时使用，比如上传文件使用post POST一般是往服务器提交数据，并获取服务器返回的结果 POST方式是通过请求体传输数据，效率低 POST请求的数据用户看不到，并且不能被浏览器缓存相对安全，传递隐私数据时使用 POST请求头比GET请求头中多的东西 Content-Length: 25 // 发送给服务器数据的大小 Cache-Control: max-age=0 // 永不缓存数据 Content-Type: application/x-www-form-urlencoded // 请求头中的Content-Type // 告诉服务器，发给服务器的数据格式和url中传参的格式是一样的 key=value&k1=v1 HEAD 不获取响应体，只获取响应头 一般在下载之前先获取文件的大小 PUT PUT 上传 配置Apache服务器WebDav功能 put直接以文件的方式写入 post需要服务器端脚本支持 DELETE OPTIONS TRACE CONNECT PATCH 请求体中各项的含义 请求体: ------WebKitFormBoundaryqwY1zO88PZll2khX Content-Disposition: form-data; name=\"userfile\"; filename=\"pic03.jpg\" Content-Type: image/jpeg 二进制数据(要上传的文件) ------WebKitFormBoundaryqwY1zO88PZll2khX-- 含义: 分隔符 ------WebKitFormBoundaryqwY1zO88PZll2khX name 表单的name属性值 filename 传递给服务器的文件名 Content-Type 告诉服务器传递的文件类型 text/plain image/jpeg image/jpg image/png application/octet-stream等 二进制数据 要上传文件的NSData 响应 response 即服务器返回的数据 HTTP 响应 HTTP Response 即从服务器接收的数据，遵守HTTP协议固定格式的数据 响应的构成 状态行Status Line 响应头Headers 响应体Content 状态码 200 正常 401 没有授权 HTTPS 发送请求之前先挑战服务器(进行https的协商) https的协商 信任服务器返回的证书(公钥) 客户端产生随机秘钥 公钥对随机秘钥进行对称加密(rsa) 把公钥加密后的随机秘钥发送给服务器 使用随机秘钥加密数据和服务器交互 // https的证书认证交换秘钥加密信息等，这个方法实现后，可正常接收https的网页信息 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler { NSLog(@\"收到服务器挑战\"); // 判断认证方式(是用户名密码还是证书认证) if (challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust) { // 设置信任服务器的证书 NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(0,credential); } } Charles抓包监视HTTP请求和响应内容 压缩和解压 SSZipArchive【如果走完所有步骤还是无法解压，查看被加压的文件权限】 一台服务器的不同端口可以处理不同的网络请求 192.168.31.254 此地址的服务器可以处理以下不同的网络请求 http://192.168.31.254:5000/ 此服务器上处于 5000 端口的程序处理遵守 http 协议的网络请求(发送的字符串数据是http协议格式) ftp://192.168.31.254:21/ 21 端口的程序处理遵守ftp协议的网络请求(发送的字符串数据是按照ftp协议格式组织的) smb://192.168.31.254:445/ 445 端口的程序处理遵守smb协议的网络请求(发送的字符串数据是按照smb协议格式编制的) afp://192.168.31.254:548 548 端口的程序处理符合afp协议的网络请求(发送的字符串数据是按照afp协议格式编制的) "},"知识库/笔记/iOS 知识点/网络/服务器软件.html":{"url":"知识库/笔记/iOS 知识点/网络/服务器软件.html","title":"服务器软件","keywords":"","body":"服务器软件配置 Apache Nginx "},"知识库/笔记/iOS 知识点/网络/加密和解密.html":{"url":"知识库/笔记/iOS 知识点/网络/加密和解密.html","title":"加密和解密","keywords":"","body":"加密和解密 作用 网络传输信息过程中可能会被窃取，所以需要加密 网络应用程序的数据安全 a. 网络上不允许传输用户隐私数据的\"明文\"; b. 在本地不允许保存用户隐私数据的\"明文\"; base 64 编码 可以将任意的二进制数据编码成字符串，在网络传输 在终端使用 base64 编码解码 在终端演示 base64 编码 base64 xx.png -o abc.txt 编码文件 echo -n \"Man\" | base64 编码字符串 在终端演示 base64 解码 base64 abc.txt -o xx.png -D 解码文件 echo -n \"TWFu\" | base64 -D 解码字符串 base64编码的原理 编码后的数据又a-z A-Z 0-9 + / = 表示 把自个字符转换成二进制取出前6位查表 不够6位的时候补0，如果是8位，则补4个0，编码后连接两个== 如果最后是4位，补2个0，编码后连接一个= 编码之后文件会变大，是源文件的4/3——12/8 6/4——3/2 加密算法 对称算法 特点: 加密和解密都使用相同的秘钥 速度快，适合对大数据加密 DES, 3DES, AES 非对称算法 特点: 加密和解密的秘钥不同 用公钥加密，用私钥解密 用私钥加密，用公钥解密 算法公开，可逆的加密算法 速度慢，适合对小数据加密 RSA 散列算法 不可逆算法 MD5, SHA1, SHA256, SHA512 MD5 算法简介 作用 对任意的数据源计算，生成固定长度的字符串。32个字符 一般用来加密密码 计算文件的md5值，用户可以验证从网络上下载的文件是否在下载的过程中被修改了 终端使用 md5 md5 -s \"admin\" MD5 破解 破解MD5，暴力破解(md5不可逆) 百度-在线破解md-5 防止暴力破解 加盐 原密码+一个复杂的字符串，防止用户输入的密码过于简单 HMAC 原密码+一个字符串 进行混合再 md5计算 把计算的结果+原密码 再进行md5计算 md5+时间，每次生成的md5值不一样 一个字符串key md5计算 把原密码和之前生成的md5值再进行hmac加密 从服务器后去当前时间 到分钟 的字符串 第二步产生的hmac值+时间 和第一步产生的md5值进行hmac加密 钥匙串 详见 网络【Day03 - NSURLConnection模拟登陆v3完整版】 通过系统提供的钥匙串功能可以在本地保存密码，系统使用 AES 的方式对密码加密 查看Safari中保存的密码 使用第三方框架SSKeychain[iOS10以后用SAMKeychain]把密码保存到钥匙串和获取钥匙串中的密码 第三方框架: SAMKeyChain 获取钥匙串中的所有用户 [SSKeychain allAccounts] 把密码保存到钥匙串中 service可以用bundleID 从钥匙串中获取密码 "},"知识库/笔记/iOS 知识点/网络/使用Socket进行网络通信.html":{"url":"知识库/笔记/iOS 知识点/网络/使用Socket进行网络通信.html","title":"使用Socket进行网络通信","keywords":"","body":" Socket通信 Socket 是什么? Socket的通信过程 短连接 长连接 请求 响应 使用 GCDAsyncSocket 第三方库进行网络通信 Socket通信 Socket 是什么? A软件(自己的App)和B软件(Terminal)之间通信 A使用一个Socket监听本机的一个特定端口，B使用一个Socket通过IP地址找到A所在的主机，再通过端口号找到A的Socket(连接头)，因为A在通过自己的Socket监听此端口，然后开始AB之间的通信即数据传输。 通过IP地址和端口号找到对应的应用，搭一个桥梁，进行数据传输，相当于一个管道 一根管子连接两个油箱，Socket相当于油箱口连接头 在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 Socket的通信过程 创建Socket 连接到服务器 发送数据给服务器 从服务器接收数据 关闭连接 HTTP 协议 HTTP协议要求，请求结束后要关闭连接，节省服务器资源 短连接 http/1.0 : 接收到服务器响应以后，立即断开连接，下次再要从服务器请求数据时，再进行三次握手，建立连接。但节省服务器资源 长连接 http/1.1 : 接收到服务器响应后，不断开连接，下次从服务器请求数据时，直接发送请求，不需要进行三次握手。一直消耗服务器资源。【当服务器响应结束后，连接会等待非常短的时间，如果这个时间内没有新的请求，就断开连接】 比如打开百度的网页，要显示网页，一次性会发送很多个请求，获取文字、图片及视频等，这些请求会在一次长连接中完成。 请求 A软件向B软件发送数据就是请求 A向B发送的数据是一大串，HTTP协议要求把这一大串按照协议规则分割为请求头和请求体 请求头 在请求头中配置一些信息，如请求方法GET还是POST、服务器主机(Host)地址或者域名信息等。 User-Agent: 可以配置请求什么设备的网页 Connection: keep-alive 或者 close 可以配置长连接或者短连接 请求体 可以在请求体传输数据 响应 B软件向回应A软件的请求就是响应 B向A发送的数据是一大串，HTTP协议要求把这一大串按照协议规则分割为响应头和响应体 响应头 响应头中有B的地址、状态码等信息 server: GitHub.com status: 304 响应体 响应体中才是传输的数据，比如一个html网页的字符串格式编码的二进制data，json 字符串格式编码的二进制data，plist 、xml等格式编码的二进制数据。AFN默认会把响应体序列化为 JSON 字符串，可以通过更改响应体序列化器为其他格式来接收其他编码格式的响应体，比如，如果响应体是 htmlString格式的，则需要把响应体序列化器更改为AFHTTPResponseSerializer, 才可以正确的解析出响应体的信息。 使用 GCDAsyncSocket 第三方库进行网络通信 代码见 Mac服务器 Socket是纯C语言的 GCDAsyncSocket是对Socket的封装的OC语言的一个第三方库 服务器端有两个Socket，一个负责监听(宿管大妈)，一个负责通信 初始化一个Socket对象作为服务器A一端的Socket(连接头)，用它绑定一个端口号，然后监听此端口号 /// 创建服务器连接头Socket lazy var server:GCDAsyncSocket = GCDAsyncSocket(delegate: self, delegateQueue: .main) server.accept(onPort: UInt16(portNumber.intValue)) // 绑定并监听一个端口号 /// 绑定并监听一个端口号 /// - Parameter sender: 监听按钮 @IBAction func listeningPort(_ sender: Any) { // 使用 socket 绑定并监听端口 do { try server.accept(onPort: UInt16(portNumber.intValue)) } catch { print(\"监听端口\\(portNumber.intValue)出错:\\(error)\") } // Socket连接之后就开始读取数据 readData() } func readData() { timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(readingData), userInfo: nil, repeats: true) // 将定时器添加到当前运行循环中 RunLoop.current.add(timer!, forMode: .common) } /// 从所有客户端Socket中读取数据 @objc func readingData() { for newSocket in clientSocketsArray { newSocket.readData(withTimeout: -1, tag: 0) // 调用此方法才会调用 didRead data代理方法 } } 如果有新来的客户端，比如B的Socket访问我们正在监听的端口号，就会调用下面代理方法 func socket(_ sock: GCDAsyncSocket, didAcceptNewSocket newSocket: GCDAsyncSocket) 通过此代理方法获取到访问我们监听的端口号的B软件的Socket(连接头)并持有，以便后面进行通信，否则会被释放 /// 当接收到新 socket 通信时 /// - Parameters: /// - sock: 当前 socket【服务器】 /// - newSocket: 新来的客户端 socket func socket(_ sock: GCDAsyncSocket, didAcceptNewSocket newSocket: GCDAsyncSocket) { print(\"newSocket: \\(newSocket)\") print(\"ip地址: \\(newSocket.connectedHost ?? \"\")\") print(\"端口号:\\(newSocket.connectedPort)\") print(\"连接时间: \\(Date())\") print(\"断开时间:\\(\"\")\") // 保存正在访问的客户端的Socket clientSocketsArray.append(newSocket) // 当第一次连接时，读取一次数据 newSocket.readData(withTimeout: -1, tag: 0) } 服务器A接收客户端B消息 调用客户端B的Socket的 readData(withTimeout:-1, tag:0) 就会读取客户端发来的数据，通过代理方法 socket(_ sock: GCDAsyncSocket, didRead data: Data, withTag tag: Int)来接收数据 /// 通过代理接收数据【客户端Socket的readData被调用时会被调用】 /// - Parameters: /// - sock: 客户端的Socket /// - data: 客户端发送过来的数据 /// - tag: func socket(_ sock: GCDAsyncSocket, didRead data: Data, withTag tag: Int) { let message = String.init(data: data, encoding: .utf8) print(\"客户端发来的贺电: \\(message ?? \"\")\") sock.write(message?.data(using: .utf8), withTimeout: -1, tag: 0) } 服务器A向客户端B发送消息 当服务器的Socket创建连接之后，也就是绑定并监听端口之后，初始化一个定时器，一直调用保存下来的，连接上我们监听的端口的所有Socket的readData，然后在代理方法中接收数据。 由A给B发送消息，则找到B的Socket，调用它的readData方法 "},"知识库/笔记/iOS 知识点/网络/NSURLSession.html":{"url":"知识库/笔记/iOS 知识点/网络/NSURLSession.html","title":"NSURLSession","keywords":"","body":"NSURLSession 简介 之前发送网络请求的过程 URL -- URLRequest -- URLConnection iOS7以后 -- NSURLSession 用于替代NSURLConnection 支持后台运行的网络任务 暂停、停止、重启网络任务，不再需要自己封装NSOperation 下载、断点续传、异步下载 上传、异步上传 获取下载、上传的进度 DataTask 要拿网页HTML数据、JSON、XML数据时使用 【默认挂起，须resume】 UploadTask 要上传文件时使用 默认挂起，须resume 配置Apache服务器WebDav功能 演示 HTTP 的Method，PUT GET DELETE PUT 上传 put直接以文件的方式写入 post需要服务器端脚本支持 通过session发送put请求上传文件 如果直接上传返回状态码401 --没有授权 因为WebDav设置了基本身份验证，所以请求的时候得携带验证的字符串 自己上传或删除一个文件，用charles监视请求 请求头有意向Authorization: Basic YWRtaW46MTIzNDU2 YWRtaW46MTIzNDU2是base64编码的账号和密码 通过base64解码还原admin:123456 常用的请求头 post时候的Content-Type、Range、User-Agent、Authorization DownloadTask 要下载文件时使用 启动任务--执行的过程是异步的 默认挂起，须resume 回调获取文件数据 downloadDelegate获取文件下载进度和实现断点续传，不能使用sharedSession【delegate会出现循环引用】 会出现的问题 狂点暂停，再继续会闪退 暂停，关闭程序重新开始，继续会闪退 多次点击继续会重复从原来的地方继续下载，所以每点击一次就清空一下resumData 在界面上放个scrollView，拖动的时候下载任务不会停止 因为下载任务是异步执行的(即使把下载任务添加到主队列中) 当发生合适的事件后，通知代理对象 所有代理方法都是在主线程上异步执行的(任务添加到主队列的时候) 拖动scrollView的时候下载不会停止 内存暴涨的解决办法 NSFileHandle 在文件存储的路径，实现下一点，往那个路径存一点的功能 还能实现一点一点读的功能？可以解决数组全部加载到内存的问题？ // 为了防止把下载的数据全部加载到内存中，造成内存暴涨闪退，用fileHandle实现下一点往内磁盘存一点，不占用内存 - (void) saveData:(NSData *)data { // 创建保存文件的路径 NSString *filePath = @\"/Users/joyawang/Desktop/v.mp4\"; // NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:filePath]; if (handle == nil) { // 如果此路径还没有文件，先创建文件 [data writeToFile:filePath atomically:YES]; } else { // 开始处理文件 // handle offset指针默认指向文件的头部，而我们要往文件的尾部写入数据，所以，先将指针指向尾部 [handle seekToEndOfFile]; // 写入数据 [handle writeData:data]; // 关闭处理文件 [handle closeFile]; } } NSOutputStream NSStream 流 抽象类 -(void)open; -(void)close; NSOutputStream 输入流 在内存和硬盘之间创建一个管道，运送一些字节 把字节通过流写入文件 [write buffer maxLength]; 步骤 接收到响应头开始创建流并打开 接收到数据开始写文件 下载结束或下载出错，关闭流 问题 如果文件已存在，再次下载的时候会追加文件[导致文件比原来大] 在文件下载之前，先判断有文件，如果有则删除重新下载？ NSURLSessionConfiguration 在一个地方配置请求头的信息，所有任务都使用此请求头 作用 可以设置请求头(Content-Type Range User-Agent Authorization等) 可以设置最大连接数 可以设置超时时长，缓存策略 类构造方法 defaultSessionConfiguration 会使用磁盘缓存，账户信息存储到钥匙链，如果有cookie会携带cookie ephemeralSessionConfiguration 没有磁盘缓存，不存储账户信息，不携带cookie 数据存储在内存，速度快，如果要存储到磁盘须自己写 backgroundSessionConfigurationWithIdentifier 在一个单独的进程上下载 app进入后台或终止之后，依然可以继续下载 属性 HTTPAdditionalHeaders 添加请求头 requestCachePolicy 缓存策略 timeoutIntervalForRequest 请求的超时时长 allowsCellularAccess 运行蜂窝网络访问 HTTPMaximumConnectionPerHost 主机的最大连接数 NSURLResponse MIMEType 返回的文件的类型Content-Type ExpectedContentLength 文件的预期大小(实际大小) suggestedFilename 建议保存的文件的名字 "},"知识库/笔记/iOS 知识点/网络/AFNetworking.html":{"url":"知识库/笔记/iOS 知识点/网络/AFNetworking.html","title":"AFNetworking","keywords":"","body":"AFNetworking AFURLSessionManager AFHTTPSessionManager GET登录 POST登录 下载 返回存储文件的路径URL 获取进度：对progress的fractionCompleted进行KVO 断点续传 上传 当从网络获取数据时，显示菊花 [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 设置缓存文件夹名称和缓存大小 // 设置缓存 /* 内存缓存: 5M 磁盘缓存: 10M 缓存文件夹名称: joyaImages */ NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:1024*1024*5 diskCapacity:1024*1024*10 diskPath:@\"joyaImages\"]; [NSURLCache setSharedURLCache:cache]; "},"知识库/笔记/iOS 知识点/网络/URL 及其构成详解.html":{"url":"知识库/笔记/iOS 知识点/网络/URL 及其构成详解.html","title":"URL 及其构成详解","keywords":"","body":" URL 及其构成详解 组成部分2: 主机(服务器)IP地址或域名 组成部分3: 端口号 组成部分4: 路径 URL 及其构成详解 URL 组成格式 网络协议://主机IP地址或域名:端口号/路径 网络协议：不同的协议代表不同的资源获取方式 主机地址：主机的唯一标识(ip地址、域名) 路径: 此 url 要访问的资源在主机中的具体位置 组成部分1: 网络协议 存在意义 回忆socket，最原始的网络通信就是通过socket发送和接收二进制数据，在发送和接收时数据的编制遵循一定的规则，才可以正常通信，而不同的规则就是网络协议，比如http协议要求，发送的数据叫做请求，请求有请求头和请求体，请求头中不同field代表不同的含义，这样发送和接收时都遵守这个协议，数据就可发送成功，还有用于其他网络传输的协议。 http 发送的字符串数据是按照 HTTP 协议格式编制的，网络间传输网页(声音、视频、文字等)的URL协议，超文本传输协议 (默认端口80，需要有个处理http请求的软件如apache监听服务器电脑的80端口)超文本传输协议，网页(声音、视频、文字等)传输 http://192.168.31.254:5000/ http://www.baidu.com:80/ http:// www.itheima.com:80/images/xx00.png ftp 网络间传输文件的协议 ftp://192.168.31.254:21 FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。 smb 发送的字符串数据是按照smb协议格式编制的 Server Message Block SMB，网络间文件共享的协议，默认端口139、445等 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。 smb://192.168.31.254:139 afp Apple Filing Protocol （AFP）是一种网络协议，为Mac计算机提供文件服务，苹果的网络间文件传输协议 afp://192.168.31.254:548 file 可以访问的Mac本地的文件路径的URL file:///Users/joyawang/Desktop/qq空间/244092911 smtp 发送邮件的协议 pop3 接收邮件的协议 tel:// 电话通信协议 sms:// 短信通信协议 组成部分2: 主机(服务器)IP地址或域名 IP 地址 IPV4 IP 地址第 4 版 x.x.x.x 表示互联网中的一个地址 每个x可以是从0到255的任意一个数(256个)，而要表示这个范围的数需要8位二进制数，有4个这样的数，所以需要32位二进制数，而32位二进制数可以表示(2^32)42.95亿个ip地址(256256256*256) IPV6 IP 地址第 6 版 用128位二进制表示一个ip地址，所以可以有(2^128)2的128次方个IP地址 常见 IP 地址: 192.168.1.1 127.0.0.1 回环地址(本机地址) 255.255.255.255 广播 0.0.0.0 any 私有Private IP address: home router, business router 10. 192.168. 172.16. 举例 协议://主机ip地址或域名:端口号/路径 http://www.baidu.com/index.html http:// www.itheima.com:80/images/xx00.png smb://192.168.31.254 从finder去Joyacloud的URL https://joyacloud.cn8.quickconnect.cn/ 从浏览器去JoyaCloud的域名URL http://192.168.31.254:5000/ 从浏览器去JoyaCloud的本地ip地址URL afp://192.168.1.2 file:///Users/joyawang/Desktop/qq空间/244092911 可以访问的Mac本地的文件路径的URL /Users/joyawang/Desktop/qq空间/244092911 Mac本地的文件路径 域名 IP地址不好记，域名好记，但是在访问某域名时需要域名解析服务器将域名解析为对应的IP地址 www.baidu.com 和 182.61.200.6 访问的是同一台服务器，一个是域名，一个是 ip 地址 其它概念 Subnet Mask子网掩码 255.255.255.255 和IP地址一起使用可以确定另一个电脑是否和你在同一网络 which is used to decide whether or not some other computers on the same network as you Gateway/Router 网关/路由器 192.168.31.1 ISP Internet Service Provider 网络服务提供商 DHCP Server 动态IP地址分配服务器 DNS Server 域名解析服务器 免费DNS服务器 谷歌：8.8.8.8 国内：014.014.014.014 WAN口 Wide area network interface 广域网接口 主要用于连接外部网络，如ADSL、DDN、以太网等各种接入线路。 宽带路由器的【路由】功能就是体现在WAN口IP地址和LAN口IP地址之间的数据路由上，我们通常根据网络运营商提供的接入方式来设置WAN口的网络参数，通常有静态IP地址、动态IP地址或PPOE等方式，它与网络运营商的接入设备处于同一个【外部】网络中。 LAN口 Local Area Network Interface 局域网接口 用来连接家庭内部网络，主要与家庭中的交换机、集线器或PC相连。 LAN口的IP地址则设置为本地局域网内的IP地址，通常是我们自己可以在宽带路由器上自行设定的IP地址，LAN口下所连接的计算机组成一个【本地局域网】，路由器的LAN口IP地址是这个网络的网关。 hosts 域名本地解析 相当于本地域名服务器 操作系统中的hosts文件则是有着类似“本地DNS服务器”的作用，而且比网络上的DNS具有更高的优先级。如果你在hosts里面配置了某个域名和IP的对应关系，比如127.0.0.1 -> localhost，那么当你在本机访问localhost时，系统首先会从hosts里面解析出127.0.0.1这个IP，而不会再去查询网络上的DNS服务器。hosts文件仅对本机生效，对其他电脑和网站本身不会造成任何影响 Windows 系统 Hosts 文件路径：C:\\Windows\\System32\\drivers\\etc\\hosts； Mac 系统 hosts 文件路径：/etc/hosts； Linux 系统的 hosts 文件一般也是在：/etc/hosts； Android 系统的 hosts 文件路径：/system/etc/hosts (需要Root权限修改)； 组成部分3: 端口号 介绍 连接到某个服务器后，要根据URL协议类型选择服务器上不同的处理数据的程序，如处理http协议的apache软件一般是服务器的80端口。如果没有安装web服务器软件的话，80端口一般是空闲的。 服务器上会有不同的程序处理不同的网络请求，端口号就是每个程序的身份标识。(是逻辑地址意味着不是物理的，不是物质上实际存在的) HTTP默认的端口80：即向一个服务器发送一个HTTP网络请求时，这个网络请求到了服务器后，直接调用服务器上监听80端口的方法，也就是运行那个程序。 FTP协议默认的端口21 pop3 接收邮件的协议110 smtp 发送邮件的协议25 端口的分类 公认端口(Well Know Ports) 这类端口也常称为“常用端口”。这类端口的端口号从0-1024，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。比如:http默认80，ftp默认21 注册端口(Registered Ports) 端口号从1025到49151.分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了的公认端口的常用程序。 动态或私有端口(Dynamic or Private Ports) 从49152到65535.之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配 例如192.168.31.254这个服务器地址，不同的协议类型会导致访问时访问不同的端口号 http://192.168.31.254:5000/ 192.168.31.254这个地址上的服务器，遵守http协议的web请求会被5000端口的程序处理 smb://192.168.31.254 192.168.31.254这个地址上的服务器，遵守smb协议的请求会被端口的程序处理 组成部分4: 路径 /Users/joyawang/Desktop/qq空间/244092911 Mac本地的文件路径 "},"知识库/笔记/iOS 知识点/网络/URL 类.html":{"url":"知识库/笔记/iOS 知识点/网络/URL 类.html","title":"URL 类","keywords":"","body":"iOS 中的 URL 类 meituan:///showP1:P2:P3:P4:/大西瓜/红牛/小樱桃/小肥羊 属性 scheme 协议头 meituan host 主机头 nil 如果没有 /// pathComponents 返回数组 URL 中所有路径的数组 show：P1:P2:P3:P4: 大西瓜 红牛 小樱桃 小肥羊 query 查询字符串 URL 中 ? 后面所有的内容 "},"知识库/笔记/iOS 知识点/网络/WKWebView.html":{"url":"知识库/笔记/iOS 知识点/网络/WKWebView.html","title":"WKWebView","keywords":"","body":"WKWebView webView/WKWebView【详见Practices中的webView & HTML & JavaScript】 WKWebView的使用详解 实例应用 Practices中的webView & HTML & JavaScript 彩票设置界面 跳转到网页的指定位置 JL微博_JLOAuthViewController 自动填充用户名密码功能 webView 的用途 可加载本地doc、pdf、mp4、html等文件 使用 自动检测网页中的电话、邮件地址、链接 // 在创建webView时，用configuration设置【WKWebView】 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; config.dataDetectorTypes = WKDataDetectorTypeAll; WKWebView *wv = [[WKWebView alloc] initWithFrame:UIScreen.mainScreen.bounds configuration:config]; // 【webView，已废弃】 dataDetectorTypes = UIDataDetectorTypeAll iOS APP 与 HTML 交互 iOS 的控件执行 JavaScript 代码控制 Html5 页面的变化 WKWebView 在用 先设置WKWebView的navigationDelegate 在代理方法didFinishNavigation中调用 [webView evaluateJavaScript:code completionHandler:nil]; webView 已废弃 先设置webView的代理，在代理方法webViewDidFinishLoad里面调用下面方法 [webView stringByEvaluatingJavaScriptFromString:] webView 加载的 html5 页面上的控件执行 iOS 的方法 WKWebView 在用 将JavaScript中要调用的OC方法名先注册到wkWebView.configuration.userContentController中【只写一个方法名即可】 [wv.configuration.userContentController addScriptMessageHandler:self name:@\"showAlert\"]; 遵守WKScriptMessageHandler协议，在协议方法userContentController didReceiveScriptMessage中拦截已注册的方法名并进行本地处理【在这里实现JS要调用的方法】 在此页面销毁时，移除注册的方法，否则会造成内存泄漏[wv.configuration.userContentController removeScriptMessageHandlerForName:@\"showAlert\"] 在HTML5的JavaScript中使用window.webkit.messageHandlers.showAlert.postMessage(\"我是来自HTML网页里JavaScript中的消息\");调用注册的方法 showAlert为注册的方法名 postMessage中为传递给该方法的参数 webView 已废弃 先在html中创建一个超链接 调用OC的方法 source:/// 自定义协议 showMessage:方法名、方法参数 helloword 参数 在webView的代理方法中 从request获取协议信息、方法名、参数 request.URL.scheme协议信息 request.URL.pathComponents[1] 方法名 request.URL.pathComponents[2] 参数 通过方法名创建SEL 判断respondsToSelector后，使用performSelector执行这个SEL对象 delegate 方法 WKNavigationDelegate 页面开始加载时调用 didStartProvisionalNavigation 当内容开始返回时调用 didCommitNavigation 页面加载完成之后调用 didFinishNavigation 页面加载失败时调用 didFailProvisionalNavigation 接收到服务器跳转请求之后调用 didReceiveServerRedirectForProvisionalNavigation 在收到响应后，决定是否跳转 decidePolicyForNavigationResponse 在发送请求之前，决定是否跳转 decidePolicyForNavigationAction WKUIDelegate "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 原理 和 方法的调用.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 原理 和 方法的调用.html","title":"Runtime 运行时原理及应用","keywords":"","body":" 运行时原理和方法的调用 OC中对象方法和类方法的调用过程 运行时原理和方法的调用 OC中对象方法和类方法的调用过程 对象方法的调用过程 比如，[p1 run]; 调用都是 [receiver selector]; 的形式，本质就是让对象在运行时发送消息的过程。 编译阶段: [receiver selector]; 方法调用被编译器转换为下面的 C 函数: objc_msgSend(receiver, selector) (不带参数) objc_msgSend(receiver, selector, org1, org2,...) （带参数） 运行时阶段: 消息接受者receiver寻找对应的selector。 通过receiver的isa指针找到receiver的Class(类)；isa意思是is a，如jim对象is a Person类。 在Class(类)的cache(方法缓存)的散列表中寻找对应的IMP(Implementation方法实现，IMP是一个指向C函数的指针)； 通过给出的 SEL(方法名) 去找到对应的函数Implementation，即找到该方法名对应的 IMP 函数指针，再通过此指针找到那个函数实现并调用。 如果在cache中没有找到对应的IMP的话，就继续在Class的method list中找对应的selector，如果找到，填充到cache中，并返回selector； 如果在Class中没有找到这个selector，就继续在它的superClass(父类)中寻找； 一旦找到对应的selector，直接执行它所在method结构体中对应的方法实现IMP指针指向的函数？。 若找不到对应的selector，消息被转发或者临时向receiver添加这个selector对应的实现方法，否则会发生崩溃。 类方法的调用过程 和对象方法调用差不多，流程如下： 通过类对象 isa 指针 找到所属的 Meta Class（元类）； 在 Meta Class（元类） 的 method list（方法列表） 中找到对应的 selector; 执行对应的 selector。 "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 的应用.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时 的应用.html","title":"运行时 的应用","keywords":"","body":"Runtime 运行时 利用 运行时 机制的 KVC KVO 获取属性列表、成员变量列表和方法列表 反射机制 注册监听通知 监听点击事件 代理模式？ 注册监听通知 实例应用 QQ聊天 特点 一对多，可以有多个监听者监听事件，只要有注册的监听者，在注销监听之前，都可以接收到通知！ 发生事件时，将通知发送给通知中心，通知中心再广播通知！，效率相对代理较低 如果层次嵌套太深，可以使用通知传值 使用 // 发布通知 NotificationCenter.default.post(name:Notification.Name.init(rawValue:JLUserShouldLoginNotification), object: \"bad token\") // 注册监听通知 NotificationCenter.default.addObserver(self, selector: #selector(userLogin), name: NSNotification.Name(rawValue: JLUserShouldLoginNotification), object: nil) // 移除通知，防止内存泄漏 NotificationCenter.default.removeObserver(self) 代理模式 特点 一对一，只能有一个监听者监听事件，最后一个设置的代理对象有效！ 发生事件时，直接让代理执行协议方法，效率更高 直接反向传值 如果层次嵌套太深，不利于传值，可以使用通知传值 监听点击事件 btn.addTarget(self, action: #selector(buttonTapped(_:)), for: .touchUpInside) "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVC 和 构造函数.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVC 和 构造函数.html","title":"运行时应用 - KVC 和 构造函数","keywords":"","body":"KVC 构造函数 即字典转模型 KVC 字典转模型 Key - Value - Coding 字典转模型，用字典给对象属性赋值 setValueForKey setValuesForKeys(_keyedValues: dict) dictionaryWithValuesForKeys KVC是利用OC的运行时 使用KVC创建构造函数注意点： 用KVC字典转模型方式创建构造函数时，必须直接或间接继承自NSObject，否则没有setValueForKey等KVC方法 想要用 KVC 赋值的属性，必须在前面使用@objc显式标记(Swift4.0以后)，否则无法成功【或在类名前用@objcMembers标记】 定义模型属性时 如果是对象，通常都是可选的 ( Optional ) 在需要的时候才创建，不需要就不创建，节省内存空间 避免写构造函数，可以简化代码 如果是基本数据类型，不能设置成可选的，而且要设置初始值，否则 KVC 会崩溃 如Int 是一个基本数据类型的结构体，OC 中没有相应的类，只有基本数据类型int，而基本数据类型没有可选一说，一旦设置成可选，KVC就找不到这个key了 如果需要使用 KVC 设置数值，属性(或方法)不能是私有 private 的，否则KVC会崩溃【可以使用@objc private】 在OC中，可以在私有扩展中\"藏\"属性，但是在运行时依然可以获取到 而Swift中，一旦将属性设置为 private ，运行时无法获取到此key，所以 KVC 无法使用 如果子类没有重写父类的 KVC 方法init(dict:) ，调用的时候，会直接调用父类的方法，setValues时，会给子类的属性一并赋值 如果字典中的key比对象的属性多，调用setValueforUndefinedKey并且函数体中不写任何实现，来保证在设置undefinedKey时不崩溃。 // KVC的基本实现 // 因为KVC是OC的东西，所以类必须是NSObject的子类才能使用KVC class Teacher:NSObject { @objc var name:String? // 可空、可选属性【因为在Swift中是结构体，对应OC是NSString对象】 @objc var age:Int = 0 // Int 是一个基本数据类型的结构体，OC 中没有相应的类，只有基本数据类型int，而基本数据类型没有可选一说，一旦设置成可选，KVC就找不到这个key了 init(dict:[String:Any]) { // 在调用self的KVC方法之前，必须保证本类和父类都已初始化 //【先将父类初始化，本类因为只有一个可选属性，可初始化为空，所以相当于本类自动初始化了】 super.init() setValuesForKeys(dict) } // 重写父类的方法 override func setValue(_ value: Any?, forUndefinedKey key: String) { // 没有调用 super，将父类的代码完全覆盖，保证碰见undefined key的时候不会崩溃 } } "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVO.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVO.html","title":"运行时应用 - KVO","keywords":"","body":"KVO 监听 NSObject 子类 属性变化 Key - Value - Observer 监听对象属性变化 addObserver(forKeyPath: ) 注册监听者，监听对象的 属性 变化 // KVO 监听父视图的 contentOffset scrollView?.addObserver(self, forKeyPath: \"contentOffset\", options: .new, context: nil) // 所有 KVO 方法会统一调用此方法 func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) // 移除监听者，防止内存泄漏 superview?.removeObserver(self, forKeyPath: \"contentOffset\") "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - YYModel.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - YYModel.html","title":"运行时应用 - YYModel","keywords":"","body":"YYModel JSON Object 和 Json Data JSON Object Dictionary 类型 Array 类型 JSON Data Data 类型 其它 转到 模型 字典 -> 模型 model.yy_modelSet(with:[:]) JSONObject -> 模型 model.yy_modelSet(withJSON:Any) 字典数组 转到 模型数组 NSArray.yy_modelArray(with: JLEmoticonPackage.self, json: array) as? [JLEmoticonPackage] 模型 转到 其它 模型 -> 字典 model.yy_modelToJSONObject() 模型 -> JSON data model.yy_modelToJSONData() 用字典键值对给模型设置属性 ​ model.yy_modelSet(with:Dict) "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 命名空间和反射机制.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 命名空间和反射机制.html","title":"运行时应用 - 命名空间和反射机制","keywords":"","body":" 命名空间 & 反射机制 命名空间 反射机制 在 OC 中如何利用反射机制 命名空间 & 反射机制 命名空间 Swift 中有命名空间 在同一个命名空间下，全局共享 第三方框架使用 Swift 如果直接拖拽到项目中，从属于一个命名空间，很可能有冲突！ 尽量使用 cocoapods 管理第三方框架 反射机制 反射机制 的概念 对于任意一个类，都能够知道这个类的所有属性和方法 对于任意一个对象，都能够调用它的任意一个方法和属性 这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制 Swift 中 NSClassFromString (反射机制) 的写法 反射最重要的目的，就是为了解耦！ 搜索 反射机制和工厂方法！ 提示：第一印象会发现一个简单的功能，写的很复杂 但是，封装的很好，而且弹性很大 在 OC 中如何利用反射机制 利用 NSClassFromString 方法来使用字符串获得类 利用 isMemberOfClass: 判断是否是一个类 利用 isKindOfClass 判断是否是一个类或者它的子类 利用 conformsToProtocol 判断对象是否遵守某个协议，即实现了此协议的方法实现 利用 respondsToSelector 判断是否实现了某一个方法【判断代理是否实现某方法】 利用 performSelector 或者 objc_msgSend 间接调用方法【webView 和 JavaScript 互相调用方法时使用】 Swift中使用反射机制 NSClassFromString ，字符串动态创建类对象 // 根据字符串动态创建类对象 // 本可以从info.plist中使用CFBundleName键取的，但是如果名字中有空格或-等，会被替换，所以用下面方法拿命名空间 // 获取该项目中任意一个类的类名【命名空间.类名】 let nameComponents = (NSStringFromClass(type(of: self)) as String).split(separator: \".\") // 获取该项目的命名空间【好像只有带横线的能创建成功】 guard let nameSpace = nameComponents.first else { return } // 构造创建类的字符串 let cls_name = nameSpace + \".\" + \"ViewController\" // 根据类名字符串创建类 guard let cls = NSClassFromString(cls_name) as? ViewController.Type else { return } // 创建类对象 let vc = cls.init() 修改命名空间、产品名 "},"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 获取成员变量列表、属性列表、方法列表.html":{"url":"知识库/笔记/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 获取成员变量列表、属性列表、方法列表.html","title":"运行时应用 - 获取成员变量列表、属性列表、方法列表","keywords":"","body":"利用运行时获取属性列表和方法列表 用 KVC 字典转模型方式创建构造函数时，必须直接或间接继承自 NSObject，否则没有 setValueForKey 等KVC方法 在 swift4.0 以后要使用 runtime 获取的属性和方法必须显式标记 objc 才可以用 runtime 获取 如果只是获取属性列表的话【懒加载和计算属性都可获取的到】，不需要继承自 NSObject，只需标记@objc或@objcMembers即可 使用类方法获取属性列表时，在class_copyPropertyList(self, &cCount)中，第一个参数必须传入self，不能用object_getClass(self)，否则无法获取 与之相反，用对象方法获取属性列表时，第一个参数只能传入object_getClass(self) @objcMembers 加在类声明前面，那么它、它的子类、扩展里的属性和方法都会隐式的加上 @objc @objc 在属性或方法前加@objc，表示暴露给OC的运行时，在运行时可以用KVC给此属性赋值，也可获取到此属性或方法名 如果在扩展（extension）前加上 @objc，那么该扩展里的属性和方法都会隐式的加上 @objc。 @nonobjc 在属性前加@nonobjc，KVC无法赋值，运行时无法获取到属性或方法列表 如果在扩展（extension）前加上 @nonobjc，那么该扩展里的属性和方法都不会隐式的加上 @objc。 // Swift import Foundation @objcMembers class Person { // 存储属性，类型可在OC中用NSString对象代表，可以被初始化为nil var name:String? // 存储属性，类型不能在OC中用对象代表，不能被初始化为nil，必须设置初始值 @nonobjc var age:Int = 0 // 懒加载属性 lazy var scores = { return 80 + 6 }() // 计算属性 var money:Int { get { return 200 + 300 } } // 计算属性？ var interests:String = { return \"爱好\" }() // 存储属性，closure类型 var finishedCallBack:((_ result:[String])->())? // 类方法利用运行时获取属性列表【懒加载和计算属性都可获取的到】 // 类方法获取属性列表 // class_copyPropertyList(self, &cCount)与对象方法不同 class func propertyList()->[String] { var count:UInt32 = 0 // 用来存储属性的数量, C的类型 // 1. 获取到元素类型为objc_property_t的属性数组 let list = class_copyPropertyList(self, &count) print(\"使用类方法获取属性数量为:\\(count)\") // 2. 遍历数组获取属性名字列表 var propertyNames = [String]() // 用来保存属性名 for i in 0.. 每8位为一组 -> 8位为 1 byte(字节) -> Char占1字节 -> C语言字符串 let c_p_ame = property_getName(prop_t) // 将C字符串转为Swift字符串 let propName = String(cString: c_p_ame) // 添加到属性名数组 propertyNames.append(propName) } // 释放 C 语言对象 free(list) return propertyNames } // 类方法获取方法列表 // class_copyMethodList(self, &cCount)与对象方法不同 class func methodList()->[String] { var count:UInt32 = 0 // 用来存储方法的数量, C的类型 // 1. 获取到元素类型为SEL的数组 let list = class_copyMethodList(self, &count) print(\"使用类方法获取方法数量为:\\(count)\") // 2. 遍历数组获取方法名列表数组 var methodNames = [String]() // 用来保存方法名 // 遍历SEL数组获取方法名 for i in 0..[String] { var count:UInt32 = 0 // 用来存储方法的数量, C的类型 // 1. 获取到元素类型为ivar的属性数组 let list = class_copyIvarList(self, &count) print(\"使用类方法获取成员变量数量为:\\(count)\") // 2. 遍历数组获取成员变量名 var ivarNames = [String]()// 用来保存成员变量名字 for i in 0.. "},"知识库/笔记/iOS 知识点/绘图、动画/CoreGraphics 核心绘图.html":{"url":"知识库/笔记/iOS 知识点/绘图、动画/CoreGraphics 核心绘图.html","title":"绘图和动画","keywords":"","body":" CoreGraphics 核心绘图 Quartz2D UIBezierPath 在 UIView 的 drawRect 中进行绘图 CGRect CoreGraphics 核心绘图 Quartz2D 二维绘图引擎，包含在 CoreGraphics 中 绘制步骤 以下绘制代码写在 UIView 的 drawRect 中 获取 图形上下文 对象 CGContextRef 相当于草稿纸 ，是layer类型的，和当前view的大小相同 不同的上下文决定着不同的输出目标 主要包含以下信息 绘图路径 (各种各样的图形) 绘图状态 (颜色、线宽、样式、旋转、缩放、平移、图片裁剪区域等) 输出目标 绘制到什么地方去？ UIView、图片、pdf文件、Bitmap或者显示器的窗口上、打印机等 向 图形上下文 对象中添加 路径 渲染 (把 图形上下文 中的图形绘制到对应的设备上) 绘制图形 线条 三角形 矩形 圆 弧 绘制文字 绘制、生成图片 (图像) 读取、生成 PDF 截图、裁剪图片 自定义 UI 控件 通过继承 UIView，重写 drawRect 方法实现在控件上绘制各种内容 通过继承 UIView 实现自定义的 UIImageView 实现自定义的 下载进度条 控件 幸运转盘控件 实际应用 画板涂鸦 手势解锁 将矩形头像裁剪为圆形 报表 折线图 饼状图 柱状图 数据类型和函数基本都以 CG 作为前缀 ​ CGContextRef ​ CGPathRef ​ CGContextStrokePath(ctx) UIBezierPath 矩形 +bezierPathWithRect 圆角矩形 +bezierPathWithRoundedRect: radius: 椭圆 +bezierPathWithOvalInRect 圆弧 +bezierPathWithArcCenter 把笔头提到某坐标 -moveToPoint 从笔头处向某坐标处添加一条线 -addLineToPoint 设置线宽-setLineWidth 设置连接处的样式 -setLineJoinStyle 设置头尾的样式 -setLineCapStyle UIColor对象setStroke、setFill、set(同时设置描边和填充颜色)设置颜色 描边 -stroke 填充 -fill 使用奇偶填充规则 -useEvenOddRule 在 UIView 的 drawRect 中进行绘图 绘图代码为什么要写在drawRect当中 因为在这个方法中可以获取到正确的上下文 rect 参数的含义 当前View的bounds drawRect 什么时候调用 这个方法是系统调用，不能手动调用！！！ (1)当此view第一次显示的时候调用 (2)当此view进行重绘redraw的时候会调用(理解成tableView的刷新) 如何重绘 理解成tableView的刷新，当绘图的path中的坐标或其他数据改变时，如果不刷新重新显示的话，view显示的还是原来的绘图 (1)调用某个需要重绘的view对象的setNeedsDisplay。 (2)调用某个需要重绘的view对象的setNeedsDisplayInRect rect:参数表示需要重绘的区域 为什么不能手动调用drawRect 因为手动调用时可能获取不到正确的上下文，画也是白画。 如果需要重新画一些东西的话，调用setNeedsDisplay，系统会自动在适当的时候调用drawRect CGRect offsetBy 偏移后返回一个 Rect insetBy 向内收缩后返回一个 Rect "},"知识库/笔记/iOS 知识点/绘图、动画/动画相关.html":{"url":"知识库/笔记/iOS 知识点/绘图、动画/动画相关.html","title":"动画相关","keywords":"","body":"CALayer 图层、形变、核心动画、物理仿真 动画 UIView.animate 属性动画？ UIIMageView 序列帧动画 layer的Transform 形变 核心动画 CAAnimation pop 框架 UIView.animate 属性动画？ UIIMageView 序列帧动画 layer的Transform 形变 位置移动 变大、变小 旋转 iOS 系统中 UIView 封装的旋转动画 - 默认顺时针旋转 - 就近原则，往某个位置旋转的时候，那边弧度小就从哪边转 - 要想实现同方向旋转，需要调整一个 非常小的数字(近) - 如果想实现 360 旋转，需要核心动画 CABaseAnimation 核心动画 CAAnimation 步骤 创建动画对象 (做什么动画) 基本动画 CABasicAnimation (实例应用: JL微博_JLVisitorView) 透明度渐变 自旋转 关键帧动画 CAKeyframeAnimation 比如，走一个特定的路径 绕圆旋转 动画到某些指定的值 组动画 (将各种动画叠加使用) CAAnimationGroup 转场动画 CATransition 设置动画对象属性 (怎么做动画) keyPath 要做动画的属性 fromValue 从哪个值开始 toValue 到哪个值 byValue 在自身 value 的基础上加多少 不希望回到原来位置 anim.fillMode = kCAFillModeForwards; anim.removedOnCompletion = NO duration 每次动画持续时长 repeatCount 重复次数 添加动画到视图的 layer (对谁做动画) pop 框架 和 核心动画 使用方法差不多 实例应用: JL微博中 JLComposeTypeView 显示撰写微博按钮时 使用方法 // 创建动画 let anim:POPSpringAnimation = POPSpringAnimation(propertyNamed: kPOPLayerPositionY) // 设置动画属性 anim.fromValue = btn.center.y anim.toValue = btn.center.y + 400 // 设置动画时间，最后一个 btn 的启动时间最早 anim.beginTime = CACurrentMediaTime() + CFTimeInterval(v.subviews.count - i) * 0.025 // 添加动画 // propertyName 用的 layer 动画就往layer上加，否则往 view 上加 btn.layer.pop_add(anim, forKey: nil) "},"知识库/笔记/iOS 知识点/绘图、动画/UIDynamic 物理仿真.html":{"url":"知识库/笔记/iOS 知识点/绘图、动画/UIDynamic 物理仿真.html","title":"UIDynamic 物理仿真","keywords":"","body":"UIDynamic 物理仿真 动画者 UIDynamicAnimator 重力行为 UIGravityBehavior 碰撞行为 UICollisionBehavior 甩行为 UISnapBehavior 附着行为 UIAttachmentBehavior 推行为 UIPushBehavior 动力学元素自身属性 弹性 elasticity 密度 density 摩擦力 friction resistance "},"知识库/笔记/iOS 知识点/性能优化/性能优化.html":{"url":"知识库/笔记/iOS 知识点/性能优化/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 如何做出圆角，不用 CornerRadius ？ "},"知识库/笔记/编程语言学习/编程语言学习.html":{"url":"知识库/笔记/编程语言学习/编程语言学习.html","title":"编程语言学习","keywords":"","body":" 编程语言学习 基础语法 数据处理 内存中如何存储数据 基本数据类型 字符串 集合类型 变量和常量 可选项 表达式 流程控制 循环控制 高级? 函数 / 方法 指针 函数指针 / Block / Closure 结构体 枚举 面向对象 内存管理 数据类型与变量 可用来声明变量的数据类型: 数据类型与变量的使用 文件权限控制 编程语言学习 基础语法 数据处理 内存中如何存储数据 基本数据类型 字符串 集合类型 数组 字典 集合 变量和常量 声明 初始化 / 赋值 值输出 作用域 可选项 表达式 算术运算符和算术表达式 复合赋值运算符、自增自减运算、逗号表达式、比较表达式、三元表达式 流程控制 逻辑运算符及其优先级 if 结构 循环控制 switch-case 语法 while 循环 do-while 循环 break, continue, goto 关键字 for 循环 高级? 函数 / 方法 意义 函数声明 函数实现 函数调用 参数 参数的本质 形参 实参 返回值 执行步骤 不同数据类型作为函数参数和返回值时的传值方式 基本数据类型(int, char, float, double) 数组 结构体【个人创建的数据类型】 指针【存储变量所在的内存空间的地址】 函数指针 结构体指针 指针 变量的值和地址 指针类型变量的声明、初始化和使用 野指针、NULL 指针类型与函数 函数指针 / Block / Closure 声明变量 与函数 做函数的参数 做函数的返回值 初始化 / 赋值 调用 结构体 结构体概述 用结构体创建新数据类型 结构体存在的意义 新数据类型(使用结构体创建)的变量的初始化、默认值 新数据类型(使用结构体创建)之间的相互赋值 新数据类型(使用结构体创建)与数组 新数据类型(使用结构体创建)与指针 新数据类型(使用结构体创建)嵌套 新数据类型(使用结构体创建)与函数 typedef 定义新数据类型 枚举 面向对象 类 成员属性 方法 对象 对象的创建 对象的使用 对象的存储 对象的消息机制 构造和析构函数 构造函数 (创建对象的方法) 重载构造函数 (initWith) 重写构造函数 (override) KVC 构造函数 (用dict创建对象) 便利构造函数 (条件判断是否创建对象) 析构函数 封装 将相同功能的代码抽取并封装为方法、对象等 继承 子类继承父类的属性和方法 多态 同一方法名，不同具体实现 内存管理 数据类型与变量 任何数据类型都会用来与变量打交道 可用来声明变量的数据类型: 基本数据类型和基本数据类型组合的新数据类型 int, char, float, double pointer newDataType(使用结构体 struct 和 typedef 创建的、使用 enum 和 typedef 创建的) array, dictionary 数据类型与变量的使用 变量的声明 比如声明int类型的变量、指针类型的变量、struct Person 类型的变量 变量的默认值、初始化 / 赋值 变量与容器(数组、字典) 变量与指针 变量与函数 文件权限控制 "},"知识库/笔记/编程语言学习/C 语言/C 语言知识点.html":{"url":"知识库/笔记/编程语言学习/C 语言/C 语言知识点.html","title":"C 语言","keywords":"","body":" C 语言知识点 Day01 开发前奏 Day02 IDE和基本数据类型 Day03 表达式 Day04 流程控制结构 Day05 循环控制结构 Day06 循环控制结构 Day07 函数 Day08 进制 Day09 数组 Day10 字符串 Day11 指针 Day12 指针 Day13 结构体与枚举 Day14 预处理指令 C 语言知识点 Day01 开发前奏 操作系统 应用软件和操作系统 移动开发 OS X、Dock栏、任务栏、OS X系统的目录结构、移动磁盘的读写和操作 C语言介绍 终端使用 开发C程序的步骤 Day02 IDE和基本数据类型 数据处理 内存中如何存储数据 变量的声明、赋值、输出printf 基本数据类型: int, char, float, double Day03 表达式 输入scanf、 算术运算符和算术表达式、 复合赋值运算符、 自增自减运算、 逗号表达式、 比较表达式 Day04 流程控制结构 逻辑运算符和其优先级、 if结构、 变量作用域、 三元表达式 Day05 循环控制结构 switch-case语法、 程序调试、 while循环、 break、 continue Day06 循环控制结构 do-while循环、 for循环 Day07 函数 函数意义使用函数来实现代码的重用、 函数声明、 实现、 调用、 参数的本质、形参、实参、【基本数据类型、数组、结构体、函数作为函数参数时不同传递】 执行步骤、 返回值、 goto、break、continue补充。 Day08 进制 预处理指令概述、 文件包含指令、 相对路径和绝对路径、 多文件开发、 二、八、十、十六进制、 内存构造和变量占用的字节数、 原码、反码、补码、按位与、或、取反、异或、左移、右移、 深入变量、 int修饰符、有符号和无符号、 char变量深入 Day09 数组 格式控制符总结、 垃圾值、 数组概述、 声明、 存储、 元素本质、取值、遍历、长度、元素默认值和初始化、在内存中的存储形式、地址、 长度计算、 【必须掌握的算法：找最大值、找最小值、求累加和、求平均值、判断数组包含某元素、找某元素第一次出现的下标、产生不重复的随机数、选择排序、冒泡排序！、二分查找法】、 数组作为函数参数是地址传递 Day10 字符串 数组函数模块、 二维数组声明、 存值、取值、遍历、行列数、初始化、 在内存中的存储、 与函数(作为参数、返回值)、 字符数组、 从控制台接受字符串数据、 字符串长度计算、 字符串相关函数 Day11 指针 变量的值和地址、 指针变量声明、初始化、使用、 野指针、NULL、 多个指针指向同一变量、 指针与函数、指针类型、多级指针、指针与整数的加减法、 指针与数组、使用指针遍历数组、数组作为函数参数的本质、数组使用中括号下标的本质、指针变量的加减法、存储指针的数组、 指针之间的减法和比较运算 Day12 指针 字符串数据的两种存储方式、 内存中的五大区域、 字符串的恒定性、字符串数组、 字符串数组排序、 fputs输出字符串、fgets输入字符串、 const修饰基本数据类型、数组、指针、 malloc、calloc与realloc函数 Day13 结构体与枚举 指针与函数、 指向函数的指针、 结构体概述、 用结构体创建新数据类型、 结构体存在的意义、 结构体变量初始化、默认值、 结构体类型的作用域、 结构体变量之间的相互赋值、结构体数组、指针、结构体嵌套、结构体与函数、枚举的简单使用、typedef类型定义 Day14 预处理指令 文件包含指令、 宏定义、 带参数和无参数的宏、 条件编译指令、 static和extern "},"知识库/笔记/编程语言学习/Objective-C 语言/OC 知识点.html":{"url":"知识库/笔记/编程语言学习/Objective-C 语言/OC 知识点.html","title":"Objective-C 语言","keywords":"","body":" Ojective-C 语言 OC 概述 OC 中的面向对象 OC 中面向对象特性 OC 中分类、协议、类扩展、委托模型 Block 复制 (深浅拷贝) 单例 内存管理 Foundation 框架介绍 文件操作 对象归档 KVC / KVO Ojective-C 语言 OC 概述 OC 介绍及发展背景 OC 对比 C 语言的差异化 OC - HelloWorld OC 中的面向对象 类的基本概念 方法、成员属性 对象的基本概念 对象的声明、使用、存储细节 对象的消息机制 OC 中面向对象特性 封装 继承 多态 OC 中分类、协议、类扩展、委托模型 分类 / 类目 Category 协议 Protocol 类扩展 / 延展 Extension 委托模型 Delegate (代理模式) Block blocks 基本概念 blocks 声明 blocks 使用 blocks 作为方法的参数 blocks 作回调 block 作用域 复制 (深浅拷贝) 单例 copy 和 mutableCopy 单例模式 内存管理 ARC 和 非 ARC 的区别 手动内存管理 手动释放池介绍 点语法内存管理 Foundation 框架介绍 NSString / NSMutableString NSArray / NSMutableArray NSDictionary / NSMutableDictionary NSData NSSet / NSMutableSet NSPoint / NSRange / NSRect NSNumber / NSValue / NSNull 文件操作 NSFileManager NSFileHandle 应用程序沙盒及使用 对象归档 NSKeyedArchiver / NSKeyedUnarchiver NSCoder KVC / KVO NSKeyValueCoding Key-Value Observing "},"知识库/笔记/编程语言学习/Swift 语言/":{"url":"知识库/笔记/编程语言学习/Swift 语言/","title":"Swift 语言","keywords":"","body":" Swift 和 OC 语言 Swift 简介 Swift 快速体验 Swift 基础语法 Swift 函数和闭包 函数 闭包 Swift 面向对象 构造和析构函数 懒加载 计算型属性 重写 setter 方法 命名空间和反射机制 获取成员变量、属性和方法列表 Swift 和 OC 语言 Swift 简介 Swift 快速体验 Playground 第一个应用程序 Swift 基础语法 变量和常量 可选项 控制流 循环 字符串 集合 错误处理 Swift 函数和闭包 函数 函数的定义 闭包 闭包的定义 声明变量【闭包类型】 做函数的参数【闭包类型】 做函数的返回值【闭包类型】 尾随闭包 闭包的循环引用和解除 Swift 面向对象 构造和析构函数 构造函数基础 重载和重写构造函数 KVC 构造函数[运行时] 便利构造函数 析构函数 懒加载 计算型属性 重写 setter 方法 命名空间和反射机制 获取成员变量、属性和方法列表 "},"知识库/笔记/编程语言学习/PHP/PHP.html":{"url":"知识库/笔记/编程语言学习/PHP/PHP.html","title":"PHP","keywords":"","body":"服务器端php搭建 登录 login.php 1, 'userName' => $userName, 'userImage' => $accessType ); // 将数据字典使用JSON编码 echo json_encode($result); } else { // 将查询结果绑定到数据字典 $result = array( 'userId' => -1, 'userName' => $userName, 'userImage' => $accessType ); // 将数据字典使用JSON编码 echo json_encode($result); } return true; } } header('Content-Type:application/json;charset=utf-8'); $itcast = new itcastUsers; $itcast->userLogin(); ?> login.html post请求 GET请求 POST请求 上传文件 upload.php ```php // 打印出上传的文件的信息 print_r($_FILES); // 创建一个空数组(字典?)来存储最终要返回的响应 $response = array(); // 获取服务器的根目录，拼接存储上传的文件的路径 $target_path = $_SERVER['DOCUMENT_ROOT'].\"/upload/files/\";//接收文件目录 // 在上传的路径上拼接文件名 $target_path = $target_path . basename( $_FILES['userfile']['name']); // 将文件从暂存目录移动到接收文件目录 // $_FILES是个字典 // $_FILES['userfile']是上传的文件的信息数组 // $_FILES['userfile']['tmp_name']是文件信息数组中文件的暂存路径(包括文件临时名称) if(move_uploaded_file($_FILES['userfile']['tmp_name'], $target_path)) { // 如果上传成功，往响应字典中存储成功信息 $response ['success'] = \"The file \". basename( $_FILES['userfile']['name']). \" has been uploaded\"; } else{ // 如果上传失败，存储失败信息 $response ['error'] = \"There was an error uploading the file, please try again!\". $_FILES['userfile']['error']; } // 返回响应json格式 echo json_encode($response); ?> ``` upload.html 文件上传测试 文件上传 请选择要上传的文件: "},"知识库/笔记/编程语言学习/JavaScript/JavaScript.html":{"url":"知识库/笔记/编程语言学习/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript 介绍 JavaScript是一门广泛用于浏览器客户端的脚本语言 由Netspace公司设计，当时跟Sun公司合作，所以名字起的像Java 一般简称JS 常见用途 HTML DOM操作(节点操作，比如添加、修改、删除节点) 给HTML网页增加动态功能，比如动画 事件处理：比如监听鼠标点击、鼠标滑动、键盘输入 语法 声明变量 var num = 5; 循环 for (var i = 0; i 打印到控制台 console.log() 声明方法 function() { } 获取HTML文档中的控件 document.getElementById(\"textField1\"); document.getElementsByTagName(\"input\"); 返回数组 判断 viewDidLoad window.onload = function() {当html的所有view全都加载完毕后执行的代码} 跳转到文档中的某个位置 document.location.href = '#id号'; "},"知识库/笔记/编程语言学习/HTML & CSS/HTML.html":{"url":"知识库/笔记/编程语言学习/HTML & CSS/HTML.html","title":"HTML","keywords":"","body":"HTML 详见Practice中的【HTML练习】 可在菜鸟教程学习https://www.runoob.com/ WebStorm IDE破解 http://www.mamicode.com/info-detail-2912162.html WebStorm无法打开解决 https://www.javatang.com/archives/2017/10/09/32061820.html HTML简介 什么是HTML Hyper Text Markup Language, 超文本标记语言 其实就是文本，由浏览器负责将它解析成具体的网页内容 比如，浏览器会将左边的HTML代码转换为右边的网页内容 HTML和XML的区别 html的标签是预定义好的 xml的标签是自己定义的 html目的是用来展示数据 xml目的是用来存储或通过网络传输数据 HTML演示 主要理解表单的作用：让用户提交数据 HTML 组成 跟XML类似，HTML由N个标签(节点、元素、标记)组成 HTML语法非常松散，目前的最新版是5.0，也就是HTML5 常见标签 标题: h1, h2, h3, h4, h5... 段落: p 换行: br 容器: div, span (用来容纳其他标签) 表格: \\ table row table head table data相当于cell列表: ul 无序列表 ol 有序列表 li 每项 图片: img 【images/01.jpg这种路径是相对于当前html所在路径的相对路径】 表单: input【textField、UIButton等获取用户输入的控件】 链接: a 百度 【超链接】 空格:   注释 一条横线 "},"知识库/笔记/编程语言学习/HTML & CSS/CSS.html":{"url":"知识库/笔记/编程语言学习/HTML & CSS/CSS.html","title":"CSS","keywords":"","body":"CSS 【详见Practice中的HTML练习】 简介 CSS的全称是Cascading Style Sheets，层叠样式表 用来控制HTML标签的样式，在美化网页中起到非常重要的作用 CSS的编写格式是键值对形式的 color: red; background-color: blue; font-size: 20px; CSS有3种形式 行内样式：直接在tag的属性处用style设置 页内样式: 创建一个style class，在tag属性处应用 外部样式: 在外部的css文件中声明style class，链接这个文件到此html，在tag属性处应用那些class 选择器 作用 选择对应的标签，为其添加样式 分类 标签选择器 div { color:red; } 类选择器 .cls { color:blue; } id选择器 #hi { color:orange; } 并列选择器 div, .cls { color: red; }【所有div和所有cls类都用这个样式】“或” 复合选择器 div .cls { color:red; }【是div且cls类的才用这个样式】\"且\" 后代选择器 div p {color: red;} 直接后代选择器 div > p {color: red;} 布局介绍 【见practices中的布局介绍】 "},"知识库/笔记/CocoaPods/CocoaPods.html":{"url":"知识库/笔记/CocoaPods/CocoaPods.html","title":"CocoaPods","keywords":"","body":" CocoaPods 用CocoaPods做iOS程序的依赖管理 安装 管理第三方框架 卸载 CocoaPods 用CocoaPods做iOS程序的依赖管理 用CocoaPods做iOS程序的依赖管理 唐巧的博客 安装 先安装ruby运行环境 查看当前 Ruby 源地址 gem source -l 添加 ruby 源 gem sources -a https://gems.ruby-china.com 两个源 https://rubygems.org/ https://gems.ruby-china.com 设置源 sudo gem sources -a https://ruby.taobao.org 删除源 sudo gem sources -r https://rubygems.org/ 删除ruby源 gem sources --remove http://gems.ruby-china.org/ 查看 ruby 版本 ruby -v 升级gem sudo gem update --system 安装CocoaPod sudo gem install cocoapods pod setup sudo gem install -n /usr/local/bin cocoapods 更新 cocoapods sudo gem update cocoapods 查看最新的 cocoapods 版本 gem search cocoapods 查看当前 Cocoapods 的版本pod --version 查看当前项目所安装的所有 Pods 的版本 cat Podfile.lock 管理第三方框架 CocoaPods使用 搜索 pod search SDWebImage 搜索pod search afnetworking --simple 切换到项目的根目录 echo \"pod 'SDWebImage'\" > Podfile 【会把pod 'SDWebImage'添加到pod文件中】 安装 pod install 升级 pod update 删除某框架 从 podfile 中删除，然后 pod install? pod deintegrate 更新pod pod install 同步其他团队成员的修改时，请使用pod install。 注意，pod outdated和pod update都会更新spec仓库，但是pod install不会，所以对于经常使用的pod库，建议经常pod outdated关注更新情况。 pod outdated需要更新依赖库时，先使用pod outdated查看有哪些库有更新，再使用pod update PODNAME有目的的更新指定库 pod update PODNAME 将某个pod库更新到最新版本时 pod update更新所有(Podfile中标明的)pods 效果1：等价于对所有pod库执行一遍pod update PODNAME。 效果2：若有pod库的版本发生变更，则会更新Podfile.lock文件记录当前本地库的状态。 不推荐的原因是所有库只要有新版本，都会发生更新，有可能导致整个工程变得不稳定；另外，由于每个团队成员执行该命令的时间不一样，一旦中间有某个依赖库发布了新版本，这将导致团队内不同成员获得的pod库代码并不相同。 卸载 完全卸载 CocoaPods，删除其主库后重新安装【已测试，很强大，会重新下载主库，一定要使用代理】 rm -rf ~/.cocoapods sudo gem install cocoapods git config --global http.https://github.com.proxy [socks5://127.0.0.1:1080](socks5://127.0.0.1:1080)在终端为 github 设置代理 卸载Cocoapods 【感觉没起什么作用】 sudo gem uninstall cocoapods 更新cocoapods的主库 pod repo update 对主库进行操作，没有尝试成功！ pod repo remove master 如果没有master, 创建 repos 的 master, 并拉取 cd ~/.cocoapods/repos/master git pull git clone --depth=1 https://github.com/CocoaPods/Specs.git "},"知识库/笔记/CocoaPods/pod install, pod update, podfile, podfile.lock.html":{"url":"知识库/笔记/CocoaPods/pod install, pod update, podfile, podfile.lock.html","title":"pod install, pod update, podfile, podfile.lock","keywords":"","body":" pod install, pod update, podfile, podfile.lock, 版本号控制 一、pod install VS pod update 1 pod install 的使用场景： 2 pod update 的使用场景： 3 正确的使用方法 二、对于版本号的控制 pod install, pod update, podfile, podfile.lock, 版本号控制 一、pod install VS pod update 1 pod install 的使用场景： 1.1 新创建工程，第一次引入pod库时。 效果1：此时会按照Podfile中给出的约束条件下载所需要的pod库，获得符合约束条件的最新版本。 效果2：将创建Podfile.lock文件，记录当前使用的所有pod库和版本。 效果3：同时也会创建Pods.xcodeproj和.xcworkspace，不过这不是主要功能。 1.2 修改了Podfile文件，添加或删除了所依赖的pod库时。 效果1：建议此时一定要使用pod install获取新的pod库或删除不要的pod库，若使用pod update其他库也会受到影响。 效果2：Podfile.lock会做相应的修改，记录当前使用的所有pod库和版本。 效果3：对于Podfile.lock中已有记录的其他pod库不会发生任何变化，不去检查是否有更新版本，即使有新的可用版本也不会更新。 1.3 新人加入团队，拉取了主工程之后要获取pod库时。 效果1：按照Podfile文件中的依赖关系获取pod库。 效果2：在满足Podfile文件的情况下，直接获取Podfile.lock中记录的pod库的对应版本，并不去检查是否有更新版本。因此，即使有新的可用版本也会仅获取Podfile.lock中的版本。 1.4 团队合作中，不同开发者之间要同步对pod库的依赖时。 效果1：有人改变依赖关系，修改了Podfile文件时，情况与见场景2相同。 效果2：Podfile文件未变化，但是有人执行了pod update导致Podfile.lock文件发生修改时，pod install会同步获取Podfile.lock中指定的pod库版本，而不是最新的版本。 效果3：如果Podfile与Podfile.lock的记述相冲突，如指定了低于Podfile.lock中记录的版本，会以Podfile为准，并在获取完成后更新Podfile.lock文件。 2 pod update 的使用场景： 2.1 需要将某个pod库更新到最新版本时，使用pod update PODNAME 效果1：检查指定pod库的最新版本，若最新版本满足Podfile中的约束，则更新到最新版本。 效果2：若最新版本不满足Podfile中的约束，则更新到满足约束的最高版本。 效果3：pod update命令不会检查Podfile.lock文件，即使其中有记录也是无效的。 效果4：若Podfile文件已发生变更，pod update命令也会将本地pod库更新为符合Podfile文件的版本（不建议这么做，因为非指定PODNAME的pod库也可能被改动，此处仅写明有此效果而已）。 效果5：若有pod库的版本发生变更，指定pod库版本变化、其他pod库由于Podfile的改动而发生变化、甚至因为Podfile的改动而被移除，都会更新Podfile.lock文件记录当前本地库的状态。 效果6：由于要检查pod库的新版本，会先拉取所有源的podspec文件，第一次做这件事将是个超级费时的操作。 2.2 超级懒人爱做，而官网极其不推荐的做法，直接使用pod update 效果1：等价于对所有pod库执行一遍pod update PODNAME。 效果2：若有pod库的版本发生变更，则会更新Podfile.lock文件记录当前本地库的状态。 不推荐的原因是所有库只要有新版本，都会发生更新，有可能导致整个工程变得不稳定；另外，由于每个团队成员执行该命令的时间不一样，一旦中间有某个依赖库发布了新版本，这将导致团队内不同成员获得的pod库代码并不相同。 3 正确的使用方法 根据这两个命令的功能差异，以及CocoaPods官网的建议，我总结它们的正确用法是： 第一次获取pod库时，应使用pod install。 需要更新依赖库时，先使用pod outdated查看有哪些库有更新，再使用pod update PODNAME有目的的更新指定库。 提交代码时，请注意一定同时提交Podfile.lock文件，以便其他人能同步到与你相同的pod库版本。 同步其他团队成员的修改时，请使用pod install。 注意，pod outdated和pod update都会更新spec仓库，但是pod install不会，所以对于经常使用的pod库，建议经常pod outdated关注更新情况。 官网提到的：为什么直接在Podfile文件中指定版本的方法不够用？ 原因是你所依赖的库可能还依赖于其他的库。 如果指定pod A的版本（如在Podfile中指定pod 'A', '1.0.0'），但是pod A依赖于pod A2（通过在A.podspec中的dependency 'A2', '~> 3.0'声明）。在这种情况下，Podfile的确会强制所有用户使用pod A的1.0.0版本，但是，用户1可能会使用A2的3.4版本，而在这之后A2有新版发布，若无Podfile.lock的帮助，用户2无论使用pod install还是pod update都不可避免的会使用A2的3.5版本。 一般情况下pod A对pod A2依赖关系你是不可见的，或者并不由你维护的。所以，直接在Podfile文件中指定版本的方法并不能保证所有用户都使用相同版本的pod库。 除非你的工程所依赖的所有pod库在对其他库进行依赖时也都采用指定版本的方法，而这只有在所有pod库都由你来维护时才能够得到保证。 二、对于版本号的控制 pod ‘AFNetworking’ //不指定依赖库版本，表示每次都获取最新版本 pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本 pod ‘AFNetworking’, ‘> 2.0’ //使用高于2.0的版本 pod ‘AFNetworking’, ‘>= 2.0’ //使用大于或等于2.0的版本 pod ‘AFNetworking’, ‘ 0.1.2’ //使用大于等于0.1.2但小于0.2的版本 pod ‘AFNetworking’, ‘~>0.1’ //使用大于等于0.1但小于1.0的版本 pod ‘AFNetworking’, ‘~>0’ //高于0的版本，写这个限制与什么都不写是同样效果，皆表示使用最新版本 作者：彭磊PL 链接：https://www.jianshu.com/p/118bbfba5c23 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 "},"知识库/笔记/CocoaPods/Cocoapods 发布框架.html":{"url":"知识库/笔记/CocoaPods/Cocoapods 发布框架.html","title":"Cocoapods 发布框架","keywords":"","body":" Cocoapods 发布框架 发布框架 Cocoapods 发布框架 发布框架 注册 pod trunk register xxx@gmail.com \"我的名字\" 查询 pod 注册信息 pod trunk me 生成 spec 文件 pod spec create https://github.com/liufan321/FFFirst 编辑 podspec 文件 验证 spec 文件 pod spec lint pod spec lint --verbose 推送 pod trunk push "},"知识库/笔记/Gitbook/Gitbook.html":{"url":"知识库/笔记/Gitbook/Gitbook.html","title":"GItbook","keywords":"","body":"Gitbook 在电脑上创建一个存储 Book 的文件夹 初始化项目 gitbook init 生成 \"README.md\" 和 \"SUMMARY.md\" 两个基本文件 README.md SUMMARY.md 总目录框架 可以在里面搭建好目录后，再 gitbook init, 会生成没有的的文件夹和文件 在md文件中创作 在本地服务器上查看电子书预览 gitbook serve 首先调用 gitbook build编译书籍，完成以后会打开一个 web 服务器，监听本地 4000 端口，在浏览器中输入http://localhost:4000，即可打开电子书。 生成电子书 gitbook build 该命令会在当前文件夹中生成_book文件夹，里面是 html 版本的电子书 插件 expandable-chapters 配置目录折叠功能如下 chapter-fold 导航目录折叠 page-toc-button 悬浮目录 貌似没起作用 back-to-top-button 回到顶部 lightbox 单击查看图片 custom-favicon 修改标题栏图标 splitter 侧边栏宽度可调节 tbfed-pagefooter 页面添加页脚 search-pro 高级搜索（支持中文） page-treeview 生成页内目录 必须用不同的标题字体才可以，挺有用 删除版权信息 大约43行，在generateContent方法定义中，该方法的返回值 return renderContent ? `${copyRight + renderContent}` : ''; // 改成： return renderContent; 在 node_modules 中全部删除 在 book.json 配置好 最后重新 gitbook install 即可 "},"知识库/笔记/Gitbook/Github Pages.html":{"url":"知识库/笔记/Gitbook/Github Pages.html","title":"Github Pages","keywords":"","body":"Github Pages Github Pages 功能介绍 首先，必须在 Github 创建一个 joyawang.github.io 为名的仓库(Repository)【只能创建一个?】用来当做Github Pages https://joyawang.github.io/ 的主页 在此仓库的设置界面找到 Github Pages 选项， 就可以设置主页的网页内容来源了，默认从此仓库的 master 分支加载 index.html 文件 从现在开始，Github 任何一个仓库都可以在 https://joyawang.github.io/ 上托管页面 在 Github 创建一个 ThinkTank 仓库，在设置界面找到 Github Pages，将来源选为 master 分支的 /docs 文件夹【也可选其他方式】 这样，https://joyawang.github.io/ThinkTank 就会从 ThinkTank 仓库 master 分支的 docs 文件夹加载 index.html 文件。 所以，只要将你生成的书的 html 文件实时上传到 ThinkTank 仓库 master 分支的 docs 文件夹，你就可以从 https://joyawang.github.io/ThinkTank 访问你的书内容了 GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 第一种方式 在生成静态网页时，将保存的目录指定为 ./docs【gitbook build会替换原来的_book文件夹，所以每次生成到./docs文件夹，让gitpages从那加载】 $ gitbook build ./ ./docs 然后 git add . 并且 git commit 提交 最后推送到 GitHub 仓库，更新 master 上的 /docs 文件夹中的内容 $ git push origin master 第二种方式 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。【gitbook build会替换原来的_book文件夹，所以每次上传的时候，也用最新的_books文件夹完全覆盖gh-pages】 $ git subtree push --prefix=_book origin gh-pages "},"知识库/笔记/Unix & Linux & Mac/终端命令 Unix_Linux 命令.html":{"url":"知识库/笔记/Unix & Linux & Mac/终端命令 Unix_Linux 命令.html","title":"终端命令 Unix_Linux 命令.md","keywords":"","body":" 终端命令 Unix / Linux Command 编辑 终止、退出 查看IP 清屏 目录/文件夹 目录快捷键 查看目录和切换目录 查看目录下的文件和文件夹 新建、删除、复制文件夹和文件 文件权限查看、更改 创建用户组、用户 终端命令 Unix / Linux Command 提权 sudo super user do 编辑 终端 control + u 删除一行命令 终止、退出 暂停终端当前运行的进程 Control z 强制退出终端 Command q 强制退出系统当前运行的某程序 killall WeChat 退出 man 手册 q 终止终端当前运行的进程 Control c cancel the running process 查看IP 查看 IP 地址 ifconfig en0 wifi地址; en1 ethernet 查看局域网所有设备 arp -a 查看本机与某 IP 地址的机器是否连通 ping 查看本机到目的地 IP 之间经过多少路由器 traceroute www.baidu.com 清屏 Control l(L) Command k 语音朗读 say hi 反射、重复、回声: echo \"求知若渴，虚心若愚\" 目录/文件夹 目录快捷键 根目录 / root directory 当前工作目录 . 当前工作目录的根目录 ./ 比如 ./a.out 就是当前文件夹中的 a.out 文件 家目录、当前用户的根目录 ~ 家目录的根目录 ~/ 查看目录和切换目录 查看当前在哪个目录 pwd print working directory 切换到某个目录cd /Users/joyawang/Desktop 切换到上一级文件夹 cd .. 切换到家目录 cd 切换到根目录 cd / 查看目录下的文件和文件夹 查看当前文件夹下所有文件和文件夹 ls List 查看当前文件夹下所有文件和文件夹(包含隐藏文件) ls -a 查看(详细)当前文件夹下所有文件和文件夹以及权限 ls -l 查看(详细)当前文件夹下所有文件和文件夹(包含隐藏文件)以及权限 ls -al 新建、删除、复制文件夹和文件 新建文件夹(在当前目录) mkdir newdirectoryname 删除文件夹 rmdir directoryname 新建文件 touch 删除文件 rm a.txt 复制文件 cp ~/Desktop/MyFile.rtf ~/Documents 复制文件 cp -R froshims0 froshims1 within same working directory, copy froshims0 directory and paste and rename to froshims1 within same directory 复制文件夹及其中所有内容 cp -R ~/Desktop/MyFolder /Documents 查看文件内容 cat a.txt 查看文件内容(分页) more a.txt (f,b) Forward下 一页和backword上一页 比较两个文件 diff Compares two files line by line (assumes text). 文件权限查看、更改 更改文件权限 chmod change file modes or Access Control Lists 更改文件 所有者 和 所有组 chown change file owner and group sudo chown -R acme:acme /usr/local/etc/certfiles chown 更改文件的所有者 -R 处理指定目录以及其子目录下的所有文件 acme 新的文件所有者ID :acme 新的文件所有者的所属组(group) /usr/local/etc/certfiles 要更改的文件 更改文件 属组 chgrp -- change group 创建用户组、用户 创建用户组 sudo groupadd certusers certusers 申请到证书后将证书所有权交给此用户组 允许此组内用户访问证书 创建用户 trojan sudo useradd -r -M -G certusers trojan -r 系统用户 -M 无需登录 无需家目录 -G certusers 加入群组 acme sudo useradd -r -m -G certusers acme -r 系统用户 -m 需要家目录 未设置密码，不能登录，只能通过其他已经登录的用户切换过去 需要读写证书文件，添加到用户组 certusers -G certusers -g 　指定用户所属的群组。 -G 　指定用户所属的附加群组。 -m 　自动建立用户的登入目录。 -M 　不要自动建立用户的登入目录。 -n 　取消建立以用户名称为名的群组． -r 　建立系统帐号。 在终端运行的程序 Git, Cocoa Pods, Trojan, Nginx, apache, Home brew, Vim "},"知识库/笔记/Unix & Linux & Mac/Unix_Linux 文件基本属性.html":{"url":"知识库/笔记/Unix & Linux & Mac/Unix_Linux 文件基本属性.html","title":"Unix_Linux 文件基本属性","keywords":"","body":"更改文件属主 chown 更改文件属组 chgrp 更改文件 9 个属性 chmod 某个用户对这个文件的权限的修改 chmod u=rwx,g=rx,o=r test1 即将 test1 文件权限修改为 -rwxr-xr-- u user g group o others "},"知识库/笔记/Vim.html":{"url":"知识库/笔记/Vim.html","title":"Vim","keywords":"","body":" Vim pacvim 游戏 Vim 打开文件 sudo vim httpd-dav.conf 搜索 / :/ 别管光标位置，直接输入命令行:/httpd-dav.conf （因为现在并非编辑状态，\"/\"代表搜索的意思），然后回车，光标自动跳到那个位置 将光标移动到行首 0 将光标移动到行尾 $ 进入编辑状态 i： 退出编辑状态 esc 方向 左 h 下 j 上 k 右 l 退出 必须按 Esc，处于非编辑状态后，输入下面的指令才会起作用 保存并退出 :wq 不保存退出 :qa q pacvim 游戏 pacvim [LEVEL_NUMBER] [MODE] 上述代码中的 LEVELNumber 取值范围为 0 - 9，数字越大，难度越高。 Mode 可选 N 或 H，N 表示 Normal ，正常难度；H 则表示 Hard ，困难。 pacvim 8 n "}}