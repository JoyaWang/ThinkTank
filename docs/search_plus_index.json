{"知识库/计算机通用/IDE编辑器/Vim.html":{"url":"知识库/计算机通用/IDE编辑器/Vim.html","title":"Vim 命令","keywords":"","body":" Vim 一般模式 编辑模式 命令行模式 Vim 一般模式 光标移动： h j k l w 光标移动到下个单词开头 b 光标移动到上个单词开头 e 光标移动到下个单词结尾 $ 光标移动到行尾 0 光标移动到行首 Ctrl + f 下一页 ctrl + b 上一页 u 表示undo，回退、撤销上一步操作 ctrl+r 表示redo，恢复上一步被撤销的操作 编辑模式 i 进入编辑模式 esc 退出编辑模式 命令行模式 在一般模式下，按:进入 :/ 搜索 别管光标位置，直接输入命令行:/httpd-dav.conf （因为现在并非编辑状态，\"/\"代表搜索的意思），然后回车，光标自动跳到那个位置 :set nu 显示行号 :wq 保存并退出 :qa 不保存退出 q 直接退出 "},"知识库/计算机通用/操作系统/Linux命令.html":{"url":"知识库/计算机通用/操作系统/Linux命令.html","title":"Linux 命令","keywords":"","body":" Linux命令/Terminal/终端命令 chmod 更改文件权限 chown 更改文件 所有者 和 所有组 chgrp 更改文件属组 查看程序的pid等信息 Linux命令/Terminal/终端命令 The Linux Command Line 英文 The Linux Command Line 中文 # 光标移动 Ctrl + a 光标移动到行首（Ahead of line），相当于通常的Home键 Ctrl + e 光标移动到行尾（End of line） Option + ← 光标单词间移动（向左） Option + → 光标单词向右移动 # 删除 Ctrl + h 退格删除一个字符，相当于通常的Backspace键 Ctrl + u 删除光标之前到行首的字符 Ctrl + k 删除光标到行尾的字符 Ctrl + w 删除从光标位置前到当前所处单词（Word）的开头 Ctrl + c 取消(cancel)当前行输入的命令，相当于Ctrl + Break Ctrl + l 清屏，相当于执行clear命令 Ctrl + p 调出命令历史中的前一条（Previous）命令，相当于通常的上箭头 Ctrl + n 调出命令历史中的下一条（Next）命令，相当于通常的上箭头 Ctrl + y 粘贴最后一次被删除的单词 Ctrl + r 显示：号提示，根据用户输入查找相关历史命令（reverse-i-search） netstat -aptn 命令行，查看所有开启的端口号 lsof -i:端口号 命令行，以80为例 ctrl + u 删除光标到行首之间的命令 ctrl + c 终止终端当前运行的进程 cancel the running process ctrl + z 暂停终端当前运行的进程 ctrl + l(L) 清屏 cmd + k 清屏 killall WeChat 关闭/杀死程序 kill -9 79513 关闭/杀死程序 su joyawangchina 切换用户 passwd joyawangchina 设置密码 cat a.txt 查看文件内容 more a.txt 查看文件内容(分页) (f,b) Forward下 一页和backword上一页 diff xxx xxx 比较两个文件Compares two files line by line (assumes text) cat /proc/cpuinfo 查看linux系统的CPU型号、类型以及大小 cat /proc/meminfo 查看linux系统内存大小的详细信息，可以查看总内存，剩余内存、可使用内存等信息 / 根目录root directory . 当前工作目录 ./ 当前工作目录的根目录, 比如 ./a.out 就是当前文件夹中的 a.out 文件 ~ 当前用户的根目录,家目录 ~/ 家目录的根目录 pwd 查看当前在哪个目录 print working directory cd 切换到某个目录 cd .. 切换到上一级文件夹 cd ~ 切换到家目录 cd / 切换到根目录 ls 查看当前文件夹下所有文件和文件夹 List ls -a查看当前文件夹下所有文件和文件夹(包含隐藏文件) ls -l 查看(详细)当前文件夹下所有文件和文件夹以及权限 ls -al 查看(详细)当前文件夹下所有文件和文件夹(包含隐藏文件)以及权限 mkdir xxx 新建文件夹(在当前目录) rmdir xxx 删除空文件夹 rm -rf xxx 删除文件夹(非空也可以) touch xxx 新建文件 rm xxx 删除文件 cp xxx xxx 复制文件 cp -R froshims0 froshims1复制文件 within same working directory, copy froshims0 directory and paste and rename to froshims1 within same directory cp -R xxx xxx 复制文件夹及其中所有内容 ifconfig 查看 IP 地址 en0 wifi地址; en1 ethernet arp -a 查看局域网所有设备 ping 查看本机与某 IP 地址的机器是否连通 traceroute www.baidu.com 查看本机到目的地 IP 之间经过多少路由器 创建用户组 certusers sudo groupadd certusers 申请到证书后将证书所有权交给此用户组，允许此组内用户访问证书 创建用户 trojan sudo useradd -r -M -G certusers trojan -r 代表系统用户 -M 无需登录 没有-m，不需要家目录 -G certusers 将此用户加入用户组 certusers 创建用户 acme sudo useradd -r -m -G certusers acme -r 代表系统用户 -m 需要家目录 未设置密码，不能登录，只能通过其他已经登录的用户切换过去 -G certusers 添加到用户组 certusers，将用于此组所具有的权限，比如读写证书文件 -g 　指定用户所属的群组 -G 　指定用户所属的附加群组 -m 自动建立用户的登入目录 M 不要自动建立用户的登入目录 -n 取消建立以用户名称为名的群组 -r 建立系统帐号 chmod 更改文件权限 change file modes or Access Control Lists 更改文件 9 个属性 chmod chmod u=rwx,g=rx,o=r test1 即将 test1 文件权限修改为 -rwxr-xr-- u user g group o others chmod +x ./Desktop/test.sh给test.h文件添加可执行权限 语法：chmod abc file 引用地址:https://blog.csdn.net/my_wade/article/details/47066905 其中a,b,c各为一个数字，a表示User，b表示Group，c表示Others的权限。 r=4，w=2，x=1 若要rwx（可读、可写、可执行）属性，则4+2+1=7 若要rw-（可读、可写、不可执行）属性，则4+2=6 若要r-w（可读、不可写、可执行）属性，则4+1=5 范例： chmod a=rwx file 和 chmod 777 file 效果相同 chmod ug=rwx,o=x file 和 chmod 771 file 效果相同 若用chmod 4755 filename可使此程式具有root的权限 chown 更改文件 所有者 和 所有组 change file owner and group sudo chown -R acme:acme /usr/local/etc/certfiles chown 更改文件的所有者 -R 处理指定目录以及其子目录下的所有文件 acme 新的文件所有者ID :acme 新的文件所有者的所属组(group) /usr/local/etc/certfiles 要更改的文件 chgrp 更改文件属组 change group 查看程序的pid等信息 ps -ef | grep trojan 出现 501 81262 79513 0 4:40PM ttys000 0:00.01 grep trojan -e and -f are options to the ps command, and pipes take the output of one command and pass it as the input to another. Here is a full breakdown of this command: ps - list processes -e - show all processes, not just those belonging to the user -f - show processes in full format (more detailed than default) command 1 | command 2 - pass output of command 1 as input to command 2 grep find lines containing a pattern. grep (global search regular expression(RE) and print out the line,全面搜索正则bai表达式du并把行打zhi印出来)是一种强大的文本dao搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 processname - the pattern for grep to search for in the output of ps -ef So altogether ps -ef | grep processname means: look for lines containing processname in a detailed overview/snapshot of all current processes, and display those lines "},"知识库/计算机通用/编程语言学习/Shell/Shell基本使用.html":{"url":"知识库/计算机通用/编程语言学习/Shell/Shell基本使用.html","title":"Shell","keywords":"","body":" Shell 编写脚本文件 运行 Shell 脚本有两种方法： Shell 变量 定义变量 使用变量 只读变量 删除变量 变量类型 Shell字符串 数组 注释 多行注释 向shell脚本传递参数 运算符 流程控制 if else for 循环 while 语句 无限循环 until 循环 case 跳出循环 函数 搜索 Shell 编写脚本文件 #!/bin/sh，它同样也可以改为 #!/bin/bash。 #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 #!/bin/bash echo \"Hello World !\" echo 命令用于向窗口输出文本。 运行 Shell 脚本有两种方法： 1、作为可执行程序 将上面的代码保存为 test.sh，并 cd 到相应目录： chmod +x ./test.sh #使脚本具有执行权限 ./test.sh #执行脚本 注意，一定要写成 ./test.sh，而不是 test.sh，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。 2、作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： /bin/sh test.sh /bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 Shell 变量 定义变量 your_name=\"runoob.com\" 使用变量 your_name=\"qinjx\" echo $your_name echo ${your_name} 只读变量 #!/bin/bash myUrl=\"https://www.google.com\" readonly myUrl myUrl=\"https://www.runoob.com\" 删除变量 unset variable_name 变量类型 运行shell时，会同时存在三种变量： 1) 局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。 2) 环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。 3) shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行 Shell字符串 # 声明变量 str='Hello' # 声明变量 your_name='Lebron' # 拼接字符串并输出 echo \"${str}, ${your_name}, nice to see you here!\" #获取字符串长度 string=\"abcd\" echo \"string字符串的长度为:${#string}\" #提取字符串 str0=\"ThinkTank is a greate site\" echo ${str0:1:4} #打印出字符串1-4位的文字 #查找字符串 貌似有问题 echo `expr index \"$str0\" io` 数组 #!/bin/bash # 定义数组 array_name=(\"Joya\" \"Alice\" \"JoeyZoey\" \"YY\") # 读取数组 name1=${array_name[0]} echo \"第一个名字是: ${name1}\" # 用@或*获取数组中的所有元素 echo \"所有名字是: ${array_name[@]}\" # 获取数组长度 length0=${#array_name[@]} echo \"array_name数组元素数量为${length0}\" # 或者 length1=${#array_name[*]} echo \"array_name数组元素数量为${length1}\" # 取得数组单个元素的长度 length2=${#array_name[2]} echo \"数组中第三个元素的长度为${length2}\" 注释 以 # 开头的行就是注释，会被解释器忽略。 通过每一行加一个 # 号设置多行注释，像这样： #-------------------------------------------- # 这是一个注释 # author：菜鸟教程 # site：www.runoob.com # slogan：学的不仅是技术，更是梦想！ #-------------------------------------------- ##### 用户配置区 开始 ##### # # # 这里可以添加脚本描述信息 # # ##### 用户配置区 结束 ##### 如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？ 每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。 多行注释 多行注释还可以使用以下格式： : EOF 也可以使用其他符号: : 向shell脚本传递参数 创建名为 接收参数的脚本.sh 的脚本文件 #!/bin/sh echo \"shell传递参数实例\" echo \"执行的文件名为 $0\"; echo \"接收到的第1个参数为: $1\"; echo \"接收到的第2个参数为: $2\"; echo \"接收到的第3个参数为: $3\"; 执行脚本文件并传参 /bin/sh 接收参数的脚本.sh Joya is Here 运算符 #! /bin/bash echo \"--------------算术运算----------------\" # 加法计算 val=`expr 2 + 2` echo \"两数之和为: ${val}\" # 算术运算 a=10 b=20 # 加法 val0=`expr $a + $b` echo \"a + b 等于 $val\" # 减法 val1=`expr $a - $b` echo \"a - b 等于 $val1\" # 乘法 val2=`expr $a \\* $b` echo \"a * b 等于 $val2\" # 除法 val3=`expr $b / $a` echo \"b / a 等于 $val3\" # 取余 val4=`expr $b % $a` echo \"b 取余 a 等于$val4\" echo \"--------------条件判断----------------\" # 条件判断 if [ $a == $b ] then echo \"a 等于 b\" fi if [ $a != $b ] then echo \"a 不等于 b\" fi echo \"--------------关系运算符----------------\" # 关系运算符 # 等于 equal if [ $a -eq $b ] then echo \"$a -eq $b : a 等于 b\" else echo \"$a -eq $b: a 不等于 b\" fi # 不等于 not equal if [ $a -ne $b ] then echo \"$a -ne $b: a 不等于 b\" else echo \"$a -ne $b: a 等于 b\" fi # 大于 greater than if [ $a -gt $b ] then echo \"$a -gt $b: a 大于 b\" else echo \"$a -gt $b: a 不大于 b\" fi # 小于 less than if [ $a -lt $b ] then echo \"$a -lt $b: a 小于 b\" else echo \"$a -lt $b: a 不小于 b\" fi # 大于等于 greaterThanOrEqualTo if [ $a -ge $b ] then echo \"$a -ge $b: a 大于或等于 b\" else echo \"$a -ge $b: a 小于 b\" fi # 小于等于 lessThanOrEqualTo if [ $a -le $b ] then echo \"$a -le $b: a 小于或等于 b\" else echo \"$a -le $b: a 大于 b\" fi echo \"--------------逻辑运算：且、或----------------\" # 逻辑运算符 且、或 if [[ $a -lt 100 && $b -gt 100 ]] then echo \"$a 小于100并且$b 大于100\" else echo \"$a 不小于100或$b 不大于100\" fi if [[ $a -lt 100 || $b -gt 100 ]] then echo \"$a 小于100或者$b 大于100\" else echo \"$a 不小于100且$b 不大于100\" fi echo \"--------------字符串判断----------------\" # 声明两个字符串变量 c=\"abc\" d=\"efg\" if [ $c = $d ] then echo \"$c = $d : c 等于 d\" else echo \"$c = $d : c 不等于 d\" fi if [ $c != $d ] then echo \"$c != $d : c 不等于 d\" else echo \"$c != $d : c 等于 d\" fi if [ -z $c ] then echo \"-z $c : 字符串长度为 0\" else echo \"-z $c : 字符串长度不为 0\" fi if [ -n \"$c\" ] then echo \"-n $c : 字符串长度不为 0\" else echo \"-n $c : 字符串长度为 0\" fi if [ $c ] then echo \"$c : 字符串不为空\" else echo \"$c : 字符串为空\" fi echo \"--------------文件测试运算符----------------\" file=\"/Users/joyawang/Desktop/Shell Scripts/test.sh\" if [[ -r ${file} ]] then echo \"文件可读\" else echo \"文件不可读\" fi if [ -w \"$file\" ] then echo \"文件可写\" else echo \"文件不可写\" fi if [[ -x $file ]] then echo \"文件可执行\" else echo \"文件不可执行\" fi if [[ -f $file ]] then echo \"文件为普通文件\" else echo \"文件为特殊文件\" fi if [ -d \"$file\" ] then echo \"文件是个目录\" else echo \"文件不是目录\" fi if [ -s \"$file\" ] then echo \"文件不为空\" else echo \"文件为空\" fi if [ -e \"$file\" ] then echo \"文件存在\" else echo \"文件不存在\" fi 流程控制 if else for 循环 while 语句 无限循环 until 循环 case 跳出循环 break命令 continue case ... esac 函数 #! /bin/bash # 普通函数 demoFunc() { echo \"这是我的第一个 shell 函数\" } echo \"---开始执行函数---\" demoFunc echo \"---函数执行完毕---\" # 带return返回值的函数 funcWithReturn() { echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"第一个数字: \" read aNum # 从控制台读取用户输入 echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum 和 $anotherNum !\" return $(($aNum+$anotherNum)) } funcWithReturn # 调用函数 echo \"输入的两个数字之和为: $? !\" # 函数返回值在调用该函数后通过 $? 来获得 # 带参数的函数 funcWithParam() { echo \"第一个参数为 $1 !\" echo \"第二个参数为 $2 !\" echo \"第10个参数为 $10 !\" echo \"第10个参数为 ${10} !\" echo \"第11个参数为 ${11} !\" echo \"参数总数有 $# 个！\" echo \"作为一个字符串输出所有参数 $* !\" } funcWithParam 1 2 3 4 5 6 7 8 9 34 23 # 调用函数，传入参数 搜索 寻找特定文件夹下以.a结尾的文件 find /Users/joyawang/Library/Developer/Xcode/DerivedData/Build/Products/Debug-iphoneos -name \"*.a\" 在/home目录下查找以.txt结尾的文件名 find /home -name \"*.txt\" 同上，但忽略大小写 find /home -iname \"*.txt\" ```shell !/bin/bash 打印目录下所有文件夹和文件名称recursive function echo_name(){ for file in ls $1 do echo $1\"/\"$file if [ -d $1\"/\"$file ] then echo_name $1\"/\"$file fi done } 调用函数并传递一个文件夹路径 echo_name /Users/joyawang/Library/Developer/Xcode/DerivedData/Build/Products/Debug-iphoneos 获取指定路径的文件夹内包含特定名称的文件 声明一个空数组 results=() function getAllFileNames { # 遍历文件夹 i=0 # 搜索条件 str=\".a\" # $1指传进来的第一个参数，也就是那个指定的文件夹路径 for file in `ls $1` do # 如果数组元素名包含.a if [[ $1/${file} == *$str ]] then # 保存到数组 results[${#results[@]}]=$1\"/\"$file fi # 如果数组元素是文件夹 if [ -d $1\"/\"$file ] then # 递归 getAllFileNames $1\"/\"$file fi done } 调用函数并传递参数 getAllFileNames /Users/joyawang/Library/Developer/Xcode/DerivedData/Build/Products/Debug-iphoneos 要被替换掉的部分 str1=\"/Users/joyawang/Library/Developer/Xcode/DerivedData/Build/Products/Debug-iphoneos\" 用来替换的部分 str2=\"-force_load $(BUILT_PRODUCTS_DIR)\" 把数组中的文件名全部替换并打印出来 for res in ${results[@]} do # 将字符串中的str1替换为str2后，打印出来 echo ${res/$str1/$str2} done ``` "},"知识库/EOS区块链/EOS基本概念.html":{"url":"知识库/EOS区块链/EOS基本概念.html","title":"EOS区块链","keywords":"","body":" EOS基本概念 发送一笔交易(transaction)的流程 钱包作用 账户 系统用户 EOS基本概念 发送一笔交易(transaction)的流程 用户通过接口创建一个Transaction对象，将它发送给钱包，钱包使用存储在其中的私钥对它进行签名，然后返回带有签名的Tansaction对象，然后这个对象被广播到全网。当网络确认这个Transaction有效，它就会被包含进区块链上的一个区块中。 钱包作用 生成密钥对 用cleos wallet create_key创建了一组(用来开发的)密钥对，公钥是EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp 保存秘钥对 钱包是储存公私钥对的仓库。在链上要执行的操作必须使用私钥签名。使用cleos来操作钱包。 Wallets are repositories of public-private key pairs. Private keys are needed to sign operations performed on the blockchain. Wallets are accessed using cleos. 提供签名服务，用私钥签名交易 账户 一个账户是一个授权的集合，存储在区块链上，用来辨别发送者或接收者。它有一个灵活的授权结构使它可以被个人或者群组所拥有，这取决于权限(permission)怎么分配，往区块链上发送或者接受交易(Transaction)需要账户。 像一块有名称(账户名)的内存空间 智能合约: 合约中的方法要被调用的话，是需要不同的权限的 Token 通证等代币 公钥1: owner 用owner公钥对应的私钥打开具有owner权限 公钥2: active 用active公钥对应的私钥打开具有active权限 上面这个样子，一个保险柜有两个开关，不过打开后可以进行操作的权限是不同的。2个私钥可以存在一个钱包里，也可以如上图所示存在不同的钱包里（由不同的人控制）。 owner权限是账户的最高权限，可以修改其它权限。 active权限默认可以进行转账等操作，但不能修改权限。 每个保险箱有一个名字，就是EOS账户名。 转账和智能合约等操作的执行都是在Account这个保险箱进行，所以账户名在EOS世界其实是以太坊的地址。 与以太坊不同，EOS的账户名不再是一串很长很长的地址，而是一个你可以自定义的英文字母+数字(12345)+符号(.)，最长12位，最短1位，全局唯一，先到先得，注册费用还没公布，但据最新的消息，长度不同注册需要的EOS也不一样。 系统用户 每个新EOSIO链有一个默认的system用户叫做eosio，此账户通过加载规定有此EOSIO区块链的管理和共识的system contracts来对此链进行配置，每个新EOSIO区块链都自带一个开发私钥，且这个私钥都是一样的。这个私钥是用来以system user (eosio)的身份签名交易的。用cleos wallet import可以获得这个私钥 系统用户的私钥 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 "},"知识库/EOS区块链/cleos命令.html":{"url":"知识库/EOS区块链/cleos命令.html","title":"cleos命令","keywords":"","body":"cleos命令 cleos wallet create --to-console 创建钱包 cleos wallet open 打开钱包 cleos wallet list 查看所有钱包列表 cleos wallet unlock 解锁钱包 cleos wallet create_key 创建一组密钥对，并导入到钱包，将公钥显示在界面上 cleos wallet private_keys 显示钱包里面存储的所有密钥对 cleos create account 创建账户（用某个密钥对的公钥创建账户） 创建了bob账户，它的两个钥匙孔owner和active都是公钥EOS8m...，也就意味着只有EOS8m...对应的私钥才能对这个账户进行操作。 cleos create account {创建者账户名} {新的账户名} 公钥1 公钥2 cleos create account eosio bob EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp cleos create account eosio alice EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp "},"知识库/EOS区块链/EOS入门教程.html":{"url":"知识库/EOS区块链/EOS入门教程.html","title":"EOS入门教程","keywords":"","body":" EOS入门教程 目标 开发环境安装 安装 eosio 安装二进制文件 创建合约文件夹 安装CDT 创建开发钱包 开启keosd和nodeos 创建账户 智能合约开发 合约开发 创建合约文件 合约代码 编译合约 部署合约 执行合约 通证(Token)的部署、发行和转账 获取通证合约源码 创建要部署合约的账户 编译通证合约 部署通证(Token)合约 创建新通证(Token) 发布通证(Token) 通证(Token)转账 查询账户余额 数据存储 创建新文件夹 创建并打开新文件 EOS入门教程 目标 How to quickly spin up a node 快速搭建一个节点 Manage wallets and keys 管理钱包和秘钥 Create Accounts 创建账户 Write some contracts 编写一些合约 Compilation and ABI 编译合约，创建合约的ABI Deploy contracts 部署合约 开发环境安装 安装 eosio 安装二进制文件 brew tap eosio/eosio brew install eosio 创建合约文件夹 mkdir contracts cd contracts 安装CDT EOSIO Contract Development Toolkit，用来编译合约，生成ABI，Application Binary Files (ABI) ABI 作用就是用 JSON 文件描述合约中定义的方法(函数)名 ，这样就可以用JSON格式文件调用合约中定义的方法了 The Application Binary Interface (ABI) is a JSON-based description on how to convert user actions between their JSON and Binary representations. The ABI also describes how to convert the database state to/from JSON. Once you have described your contract via an ABI then developers and users will be able to interact with your contract seamlessly via JSON. brew tap eosio/eosio.cdt brew install eosio.cdt brew remove eosio.cdt 创建开发钱包 创建钱包 cleos wallet create --to-console 钱包密码 PW5JuurMyks6Y6X8N7EP3UPiZrnRRk8cSsuAqqKdKt42gtEmVvUV3 打开钱包 cleos wallet open cleos wallet open cleos wallet list 解锁钱包 cleos wallet unlock cleos wallet unlock cleos wallet list 将密钥对导入钱包 # 创建密钥对并导入到钱包 cleos wallet create_key 用cleos wallet create_key创建了一组(用来开发的)密钥对，公钥是EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp 导入系统用户的秘钥 Every new EOSIO chain has a default \"system\" user called \"eosio\". This account is used to setup the chain by loading system contracts that dictate the governance and consensus of the EOSIO chain. Every new EOSIO chain comes with a development key, and this key is the same. Load this key to sign transactions on behalf of the system user (eosio) cleos wallet import You'll be prompted for a private key, enter the eosio development key provided below 5KQwrPbwdL6PhXujxW37FSSQZ1JiwsST4cqQzDeyXtP79zkvFD3 开启keosd和nodeos 开启keosd keosd & 开启nodeos 配置节点信息 ~/Library/Application\\ Support/eosio/nodeos/config nodeos -e -p eosio \\ --plugin eosio::producer_plugin \\ --plugin eosio::producer_api_plugin \\ --plugin eosio::chain_api_plugin \\ --plugin eosio::http_plugin \\ --plugin eosio::history_plugin \\ --plugin eosio::history_api_plugin \\ --filter-on=\"*\" \\ --access-control-allow-origin='*' \\ --contracts-console \\ --http-validate-host=false \\ --verbose-http-errors >> nodeos.log 2>&1 & 检查Nodeos是否产生块 tail -f nodeos.log 检查钱包 cleos wallet list 检查RPC API curl http://localhost:8888/v1/chain/get_info 创建账户 # 创建bob账户， 用钱包里存储的自己创建的密钥对中的公钥，作为bob的owner权限的钥匙孔，也作为active权限的钥匙孔，这样此公钥对应的私钥则可以打开这个账户进行操作。 cleos create account eosio bob EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp cleos create account eosio alice EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp 查询账户信息 cleos get account alice 智能合约开发 合约开发 开发一个合约就是创建一个类，并在类里面创建相应的方法(函数) Token合约，也就是Token类(eosio.token)已经定义好了，发行不同的Token，也就是创建不同的Token合约对象。 创建合约文件 也就是创建一个C++文件，里面声明要创建的类名称和方法 cd /Users/joyawang/EOS_Dir/contracts mkdir hello cd hello touch hello.cpp 合约代码 #include using namespace eosio; class [[eosio::contract]] hello : public contract { public: using contract::contract; [[eosio::action]] void hi( name user ) { print( \"Hello, \", user); } }; 编译合约 将C++类文件编译成eos可以执行的二进制文件? eosio-cpp hello.cpp -o hello.wasm 部署合约 创建一个用来部署某个合约的eos账户，相当于分配了一块内存？ cleos create account eosio hello EOS8mkDUDottP33MaC1wNFfCPQVF2JCdR9usQWTCG53jL264Tmtpp -p eosio@active 将合约部署在这个eos账户下, 即在这块内存中，创建并存放一个此类的实例对象？ cleos set contract hello /Users/joyawang/EOS_Dir/contracts/hello -p hello@active 执行合约 调用这个账户的这个类的实例对象的方法？ cleos push action hello hi '[\"bob\"]' -p bob@active 如果合约内容更新后，需要重新编译 eosio-cpp -abigen -o hello.wasm hello.cpp 然后，更新合约 cleos set contract hello /Users/joyawang/EOS_Dir/contracts/hello -p hello@active 通证(Token)的部署、发行和转账 获取通证合约源码 获取存放通证合约(类)的源码 cd /Users/joyawang/EOS_Dir/contracts git clone https://github.com/EOSIO/eosio.contracts --branch v1.7.0 --single-branch cd /Users/joyawang/EOS_Dir/contracts/eosio.contracts/contracts/eosio.token 创建要部署合约的账户 创建eosio.token账户，即一块内存来存放合约的实例对象？ cleos create account eosio eosio.token EOS6MRyAjQq8ud7hVNYcfnVPJqcVpscN5So8BhtHuGYqET5GDW5CV 编译通证合约 编译通证类 eosio-cpp -I include -o eosio.token.wasm src/eosio.token.cpp --abigen 部署通证(Token)合约 创建一个Token类，存到这个账户的内存中？ cleos set contract eosio.token /Users/joyawang/EOS_Dir/contracts/eosio.contracts/contracts/eosio.token --abi eosio.token.abi -p eosio.token@active 创建新通证(Token) 向那个账户(内存)存放的Token实例对象发送create消息，即调用create方法 create方法需要两个参数 issuer、maximum_supply cleos push action eosio.token create '{\"issuer\":\"alice\", \"maximum_supply\":\"1000000000.0000 JLT\"}' -p eosio.token@active 发布通证(Token) 向那个账户(内存)存放的Token实例对象发送issue消息，即调用issue方法 issue方法需要三个参数 name、quantity、memo cleos push action eosio.token issue '[ \"alice\", \"100.0000 JLT\", \"memo\" ]' -p alice@active cleos push action eosio.token issue '[\"alice\", \"100.0000 JLT\", \"memo\"]' -p alice@active -d -j 通证(Token)转账 向那个账户(内存)存放的Token实例对象发送transfer消息，即调用transfer方法 transfer方法需要四个参数 from、to、quantity、memo # 从alice向bob转账 cleos push action eosio.token transfer '[ \"alice\", \"bob\", \"25.0000 JLT\", \"m\" ]' -p alice@active 查询账户余额 cleos get currency balance eosio.token bob JLT 数据存储 创建新文件夹 cd /Users/joyawang/EOS_Dir/contracts mkdir addressbook cd addressbook 创建并打开新文件 touch addressbook.cpp "},"知识库/EOS区块链/EOS常见问题.html":{"url":"知识库/EOS区块链/EOS常见问题.html","title":"EOS常见问题","keywords":"","body":"EOS常见问题 Error: 3190000 block_log_exception: Block log exception: block log does not contain last irreversible block o solve this issue, go to your home directory. Navigate to ~/.local/share/eosio/nodeos Here you will see two files config and data. Delete the data folder using rm -rf data/ and start your nodeos again. Error should be gone. OR You can use --hard-replay to replay the blockchain to the last irreversible block. If you don't mind losing accounts that you have created, the first method is the best, however, if you do not want to lose the current accounts, make sure to use the second method. "},"知识库/计算机通用/编程语言学习/C程序的从创建到运行的流程.html":{"url":"知识库/计算机通用/编程语言学习/C程序的从创建到运行的流程.html","title":"C程序的从创建到运行的流程","keywords":"","body":" C程序的从创建到运行的流程 1. 创建文件 2. 写C代码 3. 编译成二进制代码 4. 链接 5. 运行 C程序的从创建到运行的流程 C代码【.c文件】 -> 编译成二进制代码【.o文件】 -> 链接【.out文件】 -> 运行 1. 创建文件 新建1个后缀为.c的C语言源文件, 如main.c (需要用终端的touch创建) 2. 写C代码 打开此源文件写符合C语言规范的代码 导入头文件：#include 创建main函数(程序运行的入口) 3. 编译成二进制代码 用安装好的编译器将此源文件编译为二进制代码(若安装了Xcode，就会自动安装C的编译器) cc -c main.c 将终端的工作路径切换到源文件所在的路径 在终端中 cc -c 源文件名.c 先执行源文件中的预处理指令 如果有文件包含指令，将文件的内容拷贝到写指令的地方(拷贝函数头等) 如果有宏，进行宏替换... 检查.c文件中的语法是否符合规范。 如果符合，会生成.o文件，叫做目标文件，存储的是.c文件中C代码对应的二进制代码 不符合，报错 4. 链接 光有这个二进制文件是无法启动的，还需要添加一些启动代码进去 cc main.o 为.o的目标文件添加启动代码 链接函数，告诉编译器，要调用的函数实现在什么地方，调用的时候去正确的地方找实现。 链接成功后会生成一个.out程序，a.out文件就是最终的可执行程序 5. 运行 a.out程序: ./a.out 注意：c语言严格区分大小写 "},"知识库/计算机通用/Git/Git 基本指令.html":{"url":"知识库/计算机通用/Git/Git 基本指令.html","title":"Git","keywords":"","body":" Git Git 安装 Git 管理的文件状态 创建 Git 版本库 配置Git 将文件交给 Git 版本库管理 提交更改 查看当前 Git 状态 查看提交历史 回到过去的几种方式 Git Git 安装 Git 官网下载 pkg 安装 上一页 Ctrl + b 下一页 Ctrl + f Git 管理的文件状态 Stage 状态【Cache】 变绿了，可以被 commit 了 Unstaged 状态 Unmodified 刚 commit 完的状态 Modified 上次 commit 完后，又修改了 创建 Git 版本库 创建本地文件夹 MyProject 在 终端 cd 到 MyProject 文件夹 在 MyProject 目录下创建版本库 git init 生成 .git 文件夹，意味着 MyProject 文件夹已经成为 git 管理的版本库 配置Git git config --list 查看 git 的完整配置信息 git config -l 查看当前 git 的配置 设置 git 管理员信息及查看 管理员名称 git config --global user.name \"Joya\" 邮箱 git config --global user.email \"244092911@qq.com\" 查看 git config user.name git config user.email 将文件交给 Git 版本库管理 比如在 MyProject 文件夹创建自己的文件 1.py，git status 查看当前 MyProject 版本库中文件的状态 新创建的文件必须 git add 1.py ，进入staged 转态，这样才能被 Git 管理，才能被 commit 修改了1.py 以后也要 git add 1.py ，进入 staged 状态，才能被 commit git add 1.py stage 单个文件 git add . stage 所有文件(新建的或者变化了的) 提交更改 git commit -m \"注释\" commit 提交此次修改 git commit -am \"注释\" add 和 commit 同时进行，先 stage，后提交【适用于已经被git管理的文件】 查看当前 Git 状态 git status 查看当前 git 状态 git status -s short 形式显示当前 Git 状态 查看提交历史 git log 查看提交历史 git log --oneline 查看提交历史(每个提交显示一行, 小头版本号) git log --pretty=oneline 每行显示一个commit(大头版本号) git log --oneline --graph 图形显示 回到过去的几种方式 amend【回到最后一次提交前修改】 reset【commit和commit之间穿梭】 checkout【单个文件和单个文件之间穿梭】 rebase【将 branch B 的 commit 插入到 branch A 中】 "},"知识库/计算机通用/Git/分支及合并 branch & merge.html":{"url":"知识库/计算机通用/Git/分支及合并 branch & merge.html","title":"分支及合并 branch & merge","keywords":"","body":" 分支及合并 branch & merge 查看所有分支，以及当前所在的分支 创建分支 切换分支 删除分支 删除远程分支 创建分支的同时切换分支 合并分支 解决合并过程中的冲突 分支及合并 branch & merge 查看所有分支，以及当前所在的分支 git branch git branch -a 查看所有分支，包括远程仓库的，git branch貌似只能查看本地的 创建分支 【从当前分支，可以是任一分支】创建名为 dev 的分支 git branch dev 切换分支 切换到 dev 分支，将 HEAD 指针放到 dev 分支 git checkout dev 删除分支 删除 dev 分支【只有当前HEAD不在dev分支时才起作用】 git branch -d dev git branch -D boss 删除远程分支 git push gitee --delete 1.5.0开发 git push origin --delete new_a 创建分支的同时切换分支 【从当前分支，可以是任一分支】创建 dev 分支的同时，切换到 dev 分支 (即将 HEAD 指针放到dev分支) git checkout -b dev 合并分支 先切回主分支 git checkout master git merge dev` 使用 fast forward 方式合并 dev 分支到 master 分支，不添加这次合并的注释信息 git merge --no-ff -m \"合并dev到master\" dev 合并分支，不使用 fast forward 的方式，会添加这次合并的注释。如果 dev 和 master 没有冲突的话就直接成功了 解决合并过程中的冲突 创建了 dev 后，你在 dev 上修改，但同时有人在 master 上修改，当你合并时，就会出现冲突，这时需要解决冲突，解决完了以后，切记！！！要 add 和 commit 一次，注释为 解决冲突 ，因为解决冲突后处于 modified 状态的，提交后就算合并成功了 解决冲突合并后，并不意味着 master 和 dev 的所有都一样了？，master 上会比 dev 多出 修改了但没有和 dev 冲突的部分? 将 dev 与 master 合并了一次以后，如果 dev 再不更改，即便 master 更改了，再次合并 dev ，也无法合并，会显示 \"already up to date\" "},"知识库/计算机通用/Git/回到过去 - amend.html":{"url":"知识库/计算机通用/Git/回到过去 - amend.html","title":"回到过去","keywords":"","body":"回到过去 - amend 如果当前处于刚 commit change2.1 后的状态，想回到 change2.1 前进行修改，重新进行一次change2.1的提交 这时，直接做你要做的修改，比如，重新新建了一个文件 2.py，然后使用 git add 2.py , 再使用git commit --amend --no-edit，这时去 git log --oneline 查看提交历史，发现最后一次提交还是 change2.1，只是前面的commit id 变了 "},"知识库/计算机通用/Git/回到过去 - reset.html":{"url":"知识库/计算机通用/Git/回到过去 - reset.html","title":"reset","keywords":"","body":"回到过去 - reset 【在 commit 和 commit 之间来回穿梭】 当前处于修改了 1.py ，刚 git add 1.py 后的 staged 状态，还没有 commit，但是我后悔刚才 git add 了，不想过早地处于 stage 状态，想返回到 staged 前的 modified 状态去继续进行修改。 使用 git reset 1.py ，就重新回到 modified unstaged 状态了，相当于之前没有 git add 1.py 当前还处于上述当前处于修改了 1.py ，刚 git add 1.py 后的 staged 状态，还没有 commit，但是我后悔刚才 git add 了，不想过早地处于 stage 状态，想返回到 staged 前的 modified 状态去继续进行修改 状态，我可以用 git reset --hard HEAD 回到最后一次 commit 后的 clean 状态，相当于最后一次 change 2.1 的提交后，我啥都没干，即舍弃了从那之后的所有更改 HEAD 指针在哪，当前文件夹中的文件就处于哪个时代，意味着我们就可以在哪个时代进行编辑和修改，master 指的是 git reset --hard HEAD 就相当于回到了上次提交后的状态，从那之后我啥都没干 git reset --hard HEAD git reset --hard HEAD 回到最后一次(上一次)提交，将 HEAD 指针放到最后一次 commit id 的头顶，当前文件夹中的文件处于刚进行了最后一次 commit 后的时代，从那时起啥都没弄 git reset --hard HEAD^ 回到倒数第二次(上上次)提交 git reset --hard HEAD^^ 或者git reset --hard HEAD~2 回到倒数第三次(上上上次)提交 git reset --hard 4077e4e 即使用 commit id 回到 commit id 那一次刚提交后的状态 通过 reset 回到过去某次提交3edb后，git log --oneline 就会发现3edb提交后的所有提交都不见了 这时如果想又回到未来，需要使用 git reflog 通过查看每一步 HEAD 的移动变化，找到未来的那次提交的 commit id， 在通过 git reset --hard commitid 的方法回到未来。 "},"知识库/计算机通用/Git/回到过去 - checkout.html":{"url":"知识库/计算机通用/Git/回到过去 - checkout.html","title":"checkout","keywords":"","body":"回到过去 - checkout 【单个文件和单个文件之间穿梭】 git checkout 要回到的commit id -- 单个文件 git checkout 3a2fc25 -- 1.py 将 1.py 文件穿梭到了 3a2fc25 这次刚 commit 后的时代，而 3a2fc25 到未来最后一次 commit 之间的数据就没有了呢！ 然后在那里进行修改，修改完后 add，再 commit，这样就又重新回到了未来，这时 1.py 就保持了此次 commit 后的状态，其它的文件都处于未来没有变 checkout 还可以在 branch 分支 之间来回穿梭 "},"知识库/计算机通用/Git/回到过去 - rebase.html":{"url":"知识库/计算机通用/Git/回到过去 - rebase.html","title":"rebase","keywords":"","body":"rebase branchB 是主分支，branch A 是基于 branchB 的 C1 (也就是以C1为base)的，在从 c1 处创建 branchA 以后，branch 经过两次提交 C2 和 C4 修复了两个 bug，这时 branchA 也想有 C2和C4 去修改那两个bug，但是依然保留自己从创建分支一直到现在的提交 C3。相当于把 branchB 上的 C2 和 C4 插入 branch A 上的 C1 和 C3 之间。 以 rebase master 为例【危险，因为会修改 master 的 commit 历史】 切换到要被 rebase 的分支，比如 master git rebase dev branch A 指的是 从 dev 分支被创建的 那次提交 C1 开始，将 master 上的 C1 后的提交 C3 先分离出来 把 C2 和 C4 合并到 branch A【已没有C3】 上来【这时没有冲突】，把 C3 最后再拿回来，合并到 branch A 上【此时会有冲突】 解决冲突 冲突就是 C2 和 C4 与 C3 的冲突，解决冲突 git add . 【mark them as resolved】 完成 rebase git rebase --continue 完成【就相当于把 dev 上的 C2 和 C4 插入到了 master 的 C1 和 C3 之间，但是此时的 C3已非之前的 C3， commit id 已经和之前的不同】 或者 git rebase --skip 【skip this commit】 git rebase --abort 【To abort and get back to the state before \"git rebase\"】 "},"知识库/计算机通用/Git/Stash 暂存.html":{"url":"知识库/计算机通用/Git/Stash 暂存.html","title":"Stash 暂存","keywords":"","body":" Stash 暂存 临时修改 场景 Stash 暂存 临时修改 场景 正在 devlop 分支写代码，所以当前 git 状态为 modified 突然接到 boss 电话，master 上需要新加几行代码，因为你现在的 modified 状态，你无法切回 master，所以只能 commit 或者 stash，但你的代码还不能 commit，所以就只能 暂存 stash 了 暂存前，先 git status -s 下看看 git stash 暂存 暂存完毕后，可再 git status -s 下看看 然后切到 master，创建一个 boss 分支，在此分支上写上 boss 的代码，然后提交，并把 boss 合并到 master，这样 boss 的任务就完成了，删除 boss 分支。 重新切回 develop ，取回暂存的代码，重新继续工作，就像一切没有发生过一样 取回暂存前，先 git status -s 下看看 git stash pop 取回暂存 取回暂存后，再 git status -s 下看看 "},"知识库/计算机通用/Git/查看更改前后不同.html":{"url":"知识库/计算机通用/Git/查看更改前后不同.html","title":"查看更改前后不同","keywords":"","body":"查看更改前后不同 git diff 【查看unstaged (modified)状态下异同】 查看当前文件 modified 之后 和 之前 的对比，也就是和上次 commit 完之后的对比 但是必须是在被 git add 之前，也就是处于 unstage 的状态，才能查看修改前后的对比 git diff --cached【查看staged状态下异同】 当文件已经处于 staged 状态时，用此命令查看 当前 staged 的状态和上一次 commit 的转态的对比 git diff HEAD 【查看当前文件所有状态下的不同，包括 staged 和 modified(属于unstaged)】 当一个文件有两个状态时，传入 HEAD 参数查看所有不同 当文件已经处于 staged 状态，但还没有被 commit 前，又进行了 modify，这时它就有 两个状态 MM，一个绿M是 staged 状态, 一个红M是 unstaged 中的 modified 状态 此时，如果用 git diff --cache 参数查看的话，只会显示绿M staged 的状态的异同 此时，如果用 git diff 查看，只会显示最后修改后的 unstaged 的异同 此时如果 git commit 的话，只会将 绿M 状态，也就是处于 staged 转态的更改提交 而处于 红M，也就是 modified 状态的更改依然需要 git add 后才能提交 如果提交以后，git diff 的所有命令都不起作用了 "},"知识库/计算机通用/Git/本地仓库与远程仓库.html":{"url":"知识库/计算机通用/Git/本地仓库与远程仓库.html","title":"本地仓库与远程仓库","keywords":"","body":" 本地仓库与远程仓库 Git 本地项目添加多个远程仓库，推送到指定仓库 Git多SSH账户管理 本地仓库与远程仓库 origin 就代表 远程仓库源 将远程仓库项目下载到当前文件夹 git clone https://github.com/JoyaWang/VocKit.git 查看当前仓库的远程仓库URL git remote -v 为本地项目添加远程仓库 将本地的项目与github上的仓库连接起来 git remote add origin https://github.com/JoyaWang/VocKit.git git remote rm origin 取消与远程仓库的关联 git branch -a 查看所有分支，包括远程仓库的，git branch貌似只能查看本地的 推送到远程源仓库 将本地项目推送到远程源仓库的 master 分支 git push -u origin master 将本地项目推送到远程源仓库 develp 分支 git push -u origin develop 用远程源仓库的代码更新本地仓库代码 git pull origin master 用远程仓库 master 分支更新本地仓库 当前所在分支 会将代码直接合并，造成冲突等无法知道 git fetch origin master:branch2 等价于 git fetch origin :branch2 使用远程 master 分支在本地创建 branch2 (但不会切换到该分支), 如果本地不存在 branch2 分支, 则会自动创建一个新的 branch2 分支, 如果本地存在 branch2 分支, 并且是`fast forward', 则自动合并两个分支, 否则, 会阻止以上操作. Git 本地项目添加多个远程仓库，推送到指定仓库 本地项目添加多个远程仓库 第一种方式： 添加一个远程库 名字不能是origin git remote add 17MOX http://git.17byh.com/17MOX/mxhy.git 查看远程库及地址 git remote -v 拉，推 git pull 17MOX 远程分支名：本地分支名 git push 17MOx 本地分支名：远程分支名 第二种方式：（好处是，推送时，可以同时推送到另外一个库） 添加另外一个远程库 git remote set-url --add origin git@gitlab.com:mzc/DIVIDE_PKG.git 推送 git remote -v git push origin master:master 取消本地目录下关联的远程库 git remote remove origin 将本地项目推送到指定仓库 git push git push git@gitee.com:joyawang/jewelry_shopping_mall.git master 应该这样 git push A master Git多SSH账户管理 本地Git添加多个Github账号(或多个如Gitee的其他远程账号)的情况下需要配置 在生成对应的平台的秘钥对时，可以保存为 /Users/joyawang/.ssh/id_rsa_github /Users/joyawang/.ssh/id_rsa_gitee 以便区分。 在秘钥对存储的相同文件夹下，创建config文件，这样每次提交的时候，会做一个解析，跳转到对应的git平台。 直接在terminal中 touch config，然后用Typora进行编辑，编辑内容如下 Host github.com User git HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_github ServerAliveInterval 300 ServerAliveCountMax 10 Host gitee.com User git HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_gitee ServerAliveInterval 300 ServerAliveCountMax 10 测试是否连通 ssh -T git@github.com "},"知识库/计算机通用/Git/打Tag标签.html":{"url":"知识库/计算机通用/Git/打Tag标签.html","title":"打Tag标签","keywords":"","body":"打Tag标签 给当前head打Tag git tag Handling_User_Input Handling_User_Input 是标签 git tag -m '新发布1.0.1' 1.0.1 -m后面是备注 1.0.1才是标签 给某次commit打Tag git tag -a Building_Lists_and_Navigation 9fbc3d0 删除tag git tag -d Building_Lists_and_Navigation 推送 tag 到远程仓库 git push origin Handling_User_Input git push --tags "},"知识库/计算机通用/Git/修改注释.html":{"url":"知识库/计算机通用/Git/修改注释.html","title":"修改注释","keywords":"","body":" 修改注释 修改最后一次提交的注释 修改之前某次提交的注释 修改之前的某几次注释 修改注释 修改最后一次提交的注释 如果你只想修改最后一次注释（就是最新的一次提交），那好办：git commit --amend, 出现有注释的界面（你的注释应该显示在第一行）， 输入i进入修改模式，修改好注释后，按Esc键 退出编辑模式，输入:wq保存并退出。ok，修改完成。 修改之前某次提交的注释 其实这个原理我的理解就是先版本回退到你想修改的某次版本，然后修改当前的commit注释，然后再回到本地最新的版本 注：不能使用 reset 或 checkout 回退修改注释 输入：git rebase -i HEAD~2 最后的数字2指的是显示到倒数第几次 比如这个输入的2就会显示倒数的两次注释（最上面两行） 你想修改哪条注释, 就把哪条注释前面的pick换成edit【不在这里修改注释】 使用Vim方法编辑并保存: i---编辑，把pick换成edit---Esc---:wq git commit --amend【这个命令后修改注释】 输入上面的命令后，就会用Vim打开注释文本，直接在里面修改注释并保存退出 git rebase --continue【完成注释修改】 修改之前的某几次注释 修改多次的注释其实步骤和上面的一样，不同点在于： 1.同上 2.你可以将多个想修改的commit注释前面的pick换成edit 3.依次修改你的注释（顺序是从旧到新），Terminal基本都会提示你接下来的操作，每修改一个注释都要重复上面的3和4步，直到修改完你所选择的所有注释 已经将代码push到远程仓库 首先，你把最新的版本从远程仓库先pull下来，修改的方法都如上，最后修改完成后，强制push到远程仓库： git push --force origin master 注：很重要的一点是，你最好保证在你强制push之前没有人提交代码，如果在你push之前有人提交了新的代码到远程仓库，然后你又强制push，那么会被你的强制更新覆盖！！！ 最后，可以检查一下远程的提交记录~~ "},"知识库/计算机通用/Git/Git设置代理.html":{"url":"知识库/计算机通用/Git/Git设置代理.html","title":"Git 设置代理","keywords":"","body":" Git设置代理 Git设置代理 Git查看代理 Git取消代理 在终端设置代理 Git设置代理 Git配置文件在~/.gitconfig, 也可打开后在这进行配置 [http \"https://github.com\"] proxy = socks5://127.0.0.1:1080 [https \"https://github.com\"] proxy = socks5://127.0.0.1:1080 Git设置代理 git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080' 为github设置代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:1080 Git查看代理 查看github的代理 git config --global --get http.https://github.com.proxy git config --global --get http.proxy git config --global --get https.proxy Git取消代理 取消github的代理 git config --global --unset http.https://github.com.proxy git config --global --unset http.proxy git config --global --unset https.proxy 在终端设置代理 export https_proxy=socks5://127.0.0.1:1080 http_proxy=socks5://127.0.0.1:1080 all_proxy=socks5://127.0.0.1:1080 "},"知识库/计算机通用/Git/gitignore.html":{"url":"知识库/计算机通用/Git/gitignore.html","title":"gitignore","keywords":"","body":" gitignore 在项目开始时添加 gitignore 文件的步骤 如果在添加 gitignore 之前，某文件如 UserInterfaceState.xcuserstate 已被Git管理，需要做如下步骤使 gitignore 生效【试着效果不好?】 gitignore 在项目开始时添加 gitignore 文件的步骤 创建项目并生成项目文件夹 在 git init 之前把 .gitignore 文件拖到项目文件夹【要和.git文件夹在同级文件夹】 从 Github 搜索 gitignore，下载 Swift.gitignore 将 Swift.gitignore 重命名为 .gitignore【好像是必须的】 在项目文件夹根目录 git init，会在此文件夹生成 .git 文件夹 # 从 Github 下载的默认的 gitignore 应该就是可以的了，以下这些仅做解释，不必往里面添加 #忽略所有包含xcuserdata的文件(夹) xcuserdata #忽略所有以.xcuserstate结尾的文件 *.xcuserstate #忽略所有文件夹中后缀是.DS_Store的文件 .DS_Store 如果在添加 gitignore 之前，某文件如 UserInterfaceState.xcuserstate 已被Git管理，需要做如下步骤使 gitignore 生效【试着效果不好?】 从被 Git 管理的文件目录中删除此文件 git rm --cached 项目名.xcodeproj/project.xcworkspace/xcuserdata/joyawang.xcuserdatad/UserInterfaceState.xcuserstate git rm -r --cached . // 删除本地缓存【貌似】 git rm --cached CoreData\\ -\\ 旧.xcodeproj/project.xcworkspace/xcuserdata/joyawang.xcuserdatad/UserInterfaceState.xcuserstate 提交这次更改 git commit -m \"Removed file that shouldn't be tracked\" 暂时不知有什么用 # WARNING first try git clean -f -d --dry-run, otherwise you may lose uncommited changes. #Then: git clean -f -d "},"知识库/计算机通用/密码学/密码学概念 - 对称和非对称加密.html":{"url":"知识库/计算机通用/密码学/密码学概念 - 对称和非对称加密.html","title":"密码学及其应用","keywords":"","body":" 非对称加密和密钥对 加密解密作用 加密算法 非对称加密的应用场景 常用的算法 非对称加密和密钥对 加密解密作用 网络传输信息过程中可能会被窃取，所以需要加密 网络应用程序的数据安全 a. 网络上不允许传输用户隐私数据的\"明文\"; b. 在本地不允许保存用户隐私数据的\"明文\"; 加密算法 对称加密算法 加密和解密都使用相同的秘钥 速度快，适合对大数据加密 DES, 3DES, AES 非对称加密算法 私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。 私钥只有一个人有，而公钥可以发给所有的人。 算法公开，可逆的加密算法 速度慢，适合对小数据加密 RSA 散列算法 不可逆算法 如MD5作用 对任意的数据源计算，生成固定长度的字符串。32个字符 一般用来加密密码 计算文件的md5值，用户可以验证从网络上下载的文件是否在下载的过程中被修改了 MD5, SHA1, SHA256, SHA512 非对称加密的应用场景 始终记得: 公钥可以随便给人，而私钥要保密 私钥加密的密文，所有公钥都可以解密 公钥加密的密文，只有私钥可以解密 网络间传递加密信息时 【这个场景下公钥用来加密信息，私钥用来解密信息】 客户端生成密钥对AB，把公钥B给服务器 服务器生成密钥对CD，把公钥D给客户端 客户端给服务器发消息时用服务器给的公钥D加密，服务器收到后用自己的私钥C解密 服务器给客户端发消息时用客户端给的公钥B加密，客户端收到后用自己的私钥A解密 认证、确认身份时 【在这个场景下，私钥用来加密，公钥用来解密了】 数字签名、证书 客户端输入了一个网址给服务器发送了一个请求以后，确实拿到了服务器返回的公钥，但是这个服务器是不是冒充的它本意想访问的那个服务器是不确定的。 客户端要求服务器去一家双方都认可的权威的证书机构[如公安局]，公安局用自己的私钥将服务器的公钥加密生成一个数字证书，客户端给公安局打电话拿到了用来从数字证书中解密服务器公钥的公钥，这样当用户可以使用公安局给的公钥正常获得服务器的公钥时，就可以确定这个服务器是真正的服务器。 常用的算法 base 64 编码 可以将任意的二进制数据编码成字符串，在网络传输 在终端使用 base64 编码解码 在终端演示 base64 编码 base64 xx.png -o abc.txt 编码文件 echo -n \"Man\" | base64 编码字符串 在终端演示 base64 解码 base64 abc.txt -o xx.png -D 解码文件 echo -n \"TWFu\" | base64 -D 解码字符串 base64编码的原理 编码后的数据又a-z A-Z 0-9 + / = 表示 把自个字符转换成二进制取出前6位查表 不够6位的时候补0，如果是8位，则补4个0，编码后连接两个== 如果最后是4位，补2个0，编码后连接一个= 编码之后文件会变大，是源文件的4/3——12/8 6/4——3/2 MD5 算法简介 作用 对任意的数据源计算，生成固定长度的字符串。32个字符 一般用来加密密码 计算文件的md5值，用户可以验证从网络上下载的文件是否在下载的过程中被修改了 终端使用 md5 md5 -s \"admin\" MD5 破解 破解MD5，暴力破解(md5不可逆) 百度-在线破解md-5 防止暴力破解 加盐 原密码+一个复杂的字符串，防止用户输入的密码过于简单 HMAC 原密码+一个字符串 进行混合再 md5计算 把计算的结果+原密码 再进行md5计算 md5+时间，每次生成的md5值不一样 一个字符串key md5计算 把原密码和之前生成的md5值再进行hmac加密 从服务器后去当前时间 到分钟 的字符串 第二步产生的hmac值+时间 和第一步产生的md5值进行hmac加密 钥匙串【使用AES算法对密码加密】 详见 网络【Day03 - NSURLConnection模拟登陆v3完整版】 通过系统提供的钥匙串功能可以在本地保存密码，系统使用 AES 的方式对密码加密 查看Safari中保存的密码 使用第三方框架SSKeychain[iOS10以后用SAMKeychain]把密码保存到钥匙串和获取钥匙串中的密码 第三方框架: SAMKeyChain 获取钥匙串中的所有用户 [SSKeychain allAccounts] 把密码保存到钥匙串中 service可以用bundleID 从钥匙串中获取密码 "},"知识库/计算机通用/密码学/密码学应用 - HTTPS.html":{"url":"知识库/计算机通用/密码学/密码学应用 - HTTPS.html","title":"密码学应用 - HTTPS.md","keywords":"","body":" HTTPS HTTPS介绍 HTTPS网络通信过程 HTTPS HTTPS介绍 结合 非对称 和 对称 两种加密算法保证网络数据的安全传输。 HTTPS 主要由两部分组成：HTTP + SSL / TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。 HTTPS原理看了很多，这个是最清晰的！ 也许，这样理解HTTPS更容易 HTTPS网络通信过程 HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。 HTTPS 的整体过程分为证书验证和数据传输阶段，具体的交互过程如下 客户端A; 服务器B; A向B发送网络请求； B把自己的证书(包含自己的公钥)传递给A【网络传输: 无加密，这个证书可以给任何人，即B的公钥任何人都可以拿到，不影响什么】 A用自己装机就带的证书机构的公钥解密证书，拿到B的公钥【本地操作】 A用B的公钥将自己的AES随机数加密传送给B【网络传输: 非对称加密，只有B可以用自己的私钥解密，窃取到的人没有B的私钥无法解密】 这样A和B都安全地拥有了A的AES随机数，它们之间用AES对称加密算法进行数据的安全传输 数字证书: 就是CA用自己的私钥将B的公钥加密后的密文，只能用CA的公钥解密获取到B的公钥和有关B的其他信息。 B为什么不直接把自己的公钥传递给A，而是把证书机构CA给它颁发的证书传给它? 因为如果直接传递公钥的话，可能在半路被代理之类的中间人拦截替换掉，从而截取到通信内容。 而使用证书传递的话可以避免，因为A只会用证书机构的公钥来解密证书，被调包的证书无法用证书机构的公钥解开，这样确保了证书不会被掉包，从而确保了公钥不被掉包。 数字签名： 一下仅为个人理解，很有可能是错的： 用CA的私钥加密后的证书，只能用CA自己的公钥才能解开。所以能用CA的公钥解开的证书，肯定都是CA颁发的。 因此，CA用自己的私钥为B的公钥加密，即制作证书的过程，也就是数字签名的过程？ 而A在用CA的公钥解密一个证书的过程，也叫做验证数字签名？ 怎样辨别同一机构下的不同证书? A拿到了一个CA颁发的证书，能用CA的公钥解开并获取到公钥，可A怎么知道这个公钥是B的还是某个中间人的呢？ A解开这个证书后，证书中会有这个公钥对应的一串编号(数字签名),这个编号也是用CA的私钥加密过的密文，需要用CA的公钥解密才能获取到， 一个编号对应着一个人，这下只要弄清这个编号对应的到底是B还是某个中间人就行了。 "},"知识库/计算机通用/密码学/密码学应用 - SSH登录.html":{"url":"知识库/计算机通用/密码学/密码学应用 - SSH登录.html","title":"密码学应用 - SSH登录","keywords":"","body":"SSH Key登录 Secure Shell 安全外壳协议 公钥和私钥的特点 使用私钥加密的密文，所有公钥都可以解密 使用公钥加密的密文，只有私钥可以解密 使用SSH登录进行通信的流程 在客户端生成一对秘钥对，私钥自己留着，公钥交给服务器。 在客户端生成一个 AES 秘钥(相当于一个随机数?)，用秘钥加密后，通过网络传递给服务器。 服务器用公钥解密，拿到 AES 秘钥。 这样客户端和服务器都安全地拥有了这个 AES 秘钥，从此用 AES 对称加密进行网络通信。 使用方法 使用 RSA 非对称算法，生成 密钥对，自己留着 私钥 (用来解密信息) ssh-keygen -t rsa -C root 默认密钥对存放的位置 /Users/joyawang/.ssh/instance1.pub /Users/joyawang/.ssh/instance1 将 公钥 传递给服务器端(用来加密信息)，或直接去服务器页面手动设置 登录 第一种方式: ssh 用户名@主机地址 比如: ssh root@192.168.38.1 第二种方式: Terminal - Shell - NewRemoteConnection 在 Server 框点击＋ "},"知识库/计算机通用/密码学/密码学应用 - 区块链和数字货币.html":{"url":"知识库/计算机通用/密码学/密码学应用 - 区块链和数字货币.html","title":"密码学应用 - 区块链和数字货币.md","keywords":"","body":" 区块链和数字货币 比特币/数字货币 比特币是一个公共账本 比特币系统中的账号和密码 比特币如何怎么记账 比特币账本安全吗 比特币记账规则可靠吗 比特币是互联网时代的自由货币 区块链和数字货币 私钥是系统随机生成的，公钥是由私钥计算得出的，钱包地址是由公钥计算得出的，也就是：私钥——公钥——钱包地址，这样一个过程； 数字签名，是由交易信息＋私钥信息计算得出的，因为数字签名隐含私钥信息，所以可以证明自己的身份 公钥负责加密，私钥负责解密 公钥全网公开，我用依依的公钥给信息加密，依依用自己的私钥可以解密 私钥负责签名，公钥负责验证 我给依依发信息，我加上我自己的私钥信息形成数字签名，依依用我的公钥来验证，验证成功就证明的确是我发送的信息。 比特币/数字货币 比特币是一个公共账本 比特币本身就是一个大账本。 比特币账本完全公开，谁都可以拷贝一份来看看，甚至记上一笔 比特币系统中的账号和密码 比特币账本并不记录某人有多少币，只记录某些账号有多少币。至于这个账号是谁的，账本不计载。 每个比特币账号 (称为公钥) 都有一个对应的密码 (称为私钥)，只有知道密码的人才能支配相应账号的币。 我用密码A同一个支付命令(如\"支付被账号H一个比特币\")混合运算得到加密信息X，这个过程称之为签名。 然后把字符串X告诉大家。任何人并不需要知道密码A，只需要公开的账号B就可以将X还原成转账指令，即解密。 有了非对称加密技术，比特币账本就可以随便拷贝了，上面没有保存密码和个人信息，只有账号、余额和转账指令，我和我的比特币都是安全的。 比特币如何怎么记账 比特币记账，就是把 人们用密码签名后的转账指令记到账本上。 按上例，就是在地址B上减少1个币，在地址H上增加1个。跟现实中会计记账差不多，比特币系统每隔一段时间，现在大概是8分钟，会把期间发生的所有转账指令记在一个新帐页上。 记新帐页的时候，会把旧帐页的所有信息压缩计算成一串字符，写入帐页开头，这就像会计帐页编号一样确定了所有帐页的顺序，也使得篡改前面帐页中的任何一点信息，都会导致后一帐页的字符串对不上，产生连锁反应，使篡改很容易暴露。 这样的账页称为区块（Block），由编号穿起来的所有帐页形成一个大账本，叫区块链（Blockchain），比特币系统的核心就是这个大账本。 比特币账本可以人人保有，任何人也都可以记账。 但是，不同的人在不同的时间记账，要保证所有账本记得一样几乎是不可能的。但不一样的话就乱了，B到H的转账，有的人记了，有的人没记，账号B和H到底有多少币说不清了。 解决的办法是，一个帐页只能有一个人来记。所有想记账的人在记账前必须做一道数学题，这道题根据前一帐页的编号和待记账的新转账指令来出，最先做出这道题的那个人才有权记录这个新帐页。再过8分钟，系统再根据新发生的转账指令出一道新题接着做……。 记账时，如果两人收集到同样的交易指令，做出了同样的题，那么第一个做出的记账，后面的人白做了。 如果两人收集到的交易指令不一样，就做不一样的题，做出之后各记一个帐页，再出新题，分别接着记账，这就出现了分叉。 不要紧，两边记账的速度总是不一样的，规则规定记得慢的这一支会被丢弃。这样，所有人都会保留账页最多的账本，即最长的区块链，因为不这样的话，自己保留的账本就不会被多数人认可，就毫无用处。这样，所有人就能够保持唯一的公共账本了。 记账是件麻烦事，谁愿意去记账呢？不用担心，记账是有好处的。 规则规定，成功记账者可以在新帐页给自己账号添25个币，而且所记录的各项转账指令中往往也包含少量交易费，这也归记账者，这些就是对记账的奖励。 这个记账过程被称作挖矿，记账者称为矿工，第一个矿工是中本聪。 每帐页25个币的记账奖励是唯一的新发行比特币的办法。这种发行奖励约每四年减半，2140年前会减为0，那时矿工收入就只能靠交易费了。 比特币账本安全吗 比特币记账规则可靠吗 比特币是互联网时代的自由货币 "},"知识库/计算机通用/网络/网络通信.html":{"url":"知识库/计算机通用/网络/网络通信.html","title":"网络","keywords":"","body":" 网络通信 网络通信的过程 - 理论 网络通信的过程 - 实践 遵守 HTTP 协议的网络通信 网络通信 详见 【网络新闻 App】、【网络通信】 网络的实际用途 登录验证 验证服务器上的用户名和密码，登录 发送HTTP请求，使用GET方法，将用户名和密码拼在url中 发送HTTP请求，使用POST方法，将用户名和密码拼在请求体中 获取 data 二进制数据 (html, json, plist, xml等) 上传文件 上传图片、视频等 发送HTTP请求，使用POST方法，将要上传的文件拼在请求体中，需要服务器端php文件支持 发送HTTP请求，通过session，使用PUT方法，不需要php支持，需要配置服务器webDav服务 上传单个文件 上传多个文件 暂停 继续 取消 断点续传 进度显示 下载文件 下载图片、视频等 概念 客户端: 应用 C/S(Client/Server ) B/S(Browser/Server) 服务器: 为客户端提供服务、数据、资源的机器 局域网服务器 外网服务器 本地测试服务器 服务器软件 Apache Nginx 请求：客户端向服务器索取数据 响应：服务器对客户端的请求做出反应，一般是返回给客户端数据 网络通信的过程 - 理论 【理论】网络通信的过程 网络模型 OSI 和 TCP/IP 存在的意义 数据传输时，数据流流经的每一段，也就是数据从网络一端传到另一端要经过的步骤 数据传输的流程 Joya微信打字发送hello到YL手机的微信 微信(应用层)给这段字加上http协议的字段->传输层给这段字加上加上微信的端口信息【TCP(UDP)协议的字段】->网络层给这段字加上Joya手机的IP地址信息[IP协议的字段等]->网络接入层再添加一些信息?就进入网线传递了->到YL所在的网络中后经过相反的拆信息的步骤显示在YL手机的微信上。 OSI模型(Open System Interconnection Model) Application Layer 应用层 Presentation Layer 表示层 Session Layer 会话层 Transport Layer 传输层 四层交换机、四层路由器 Network Layer 网络层 路由器、三层交换机 Datalink Layer 数据连接层 网桥、以太网交换机、网卡 Physical Layer 物理层 中继器、集线器、双绞线 TCP/IP 模型 应用层: 对应OSI的前三层，为用户提供所需的服务如FTP, Telnet, DNS,SMTP,HTTP等。浏览器应用对应http协议，文件传输软件对应ftp协议等。 传输层: 负责为要发送的数据加入始发程序的端口号或者按照接收到的数据的端口号在主机上寻找对应的指定的应用程序 为应用层提供端到端的通信功能，保证了数据包的传输顺序及数据完整性。 端到端，即端口到端口，也就是一个主机上的应用到另一个主机上的应用 两个主要传输协议：TCP和UDP TCP(传输控制协议) 可靠的、通过“三次握手”来连接的数据传输服务，一对一 UDP(用户数据报协议) 不保证可靠、无连接的数据传输服务，广播 网络层 负责为要发送的数据加入自己主机的和要发送到的主机的IP地址信息，或者接收网络上属于自己主机IP地址的信息数据 解决主机到主机的通信问题。它所保护的协议涉及数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。 该层有3个主要协议：IP网际协议、互联网组管理协议(IGMP)和互联网控制报文协议(ICMP)。 网络接入层 （网卡层面）对应数据链路层和物理层 负责监视数据在主机和网络之间的交换 网络通信的过程 - 实践 Socket 通信 介绍 位于应用层和传输层之间，应用程序构造数据，用户输入hello，应用层的软件把数据传给socket，socket把数据封装传输给传输层、网络层等。 Socket又称”套接字“，应用程序通过”套接字“向网络发送请求或向网络做出应答 网络通信其实就是Socket之间的通信 数据在两个Socket之间通过IO传输数据 Socket是纯C语言的，是跨平台的 HTTP协议时基于Socket的，HTTP协议的底层使用的就是Socket 作用 从这里开始传输数据，socket封装应用层App传入的用户要发送的数据，再将其传输给传输层、网络层直到网络通信的另一端(服务器) 通信过程 创建Socket 使用Socket()函数 连接到服务器 使用connect()函数 发送数据给服务器 使用send()函数 从服务器接收数据 使用recv()函数 关闭连接 使用close()函数 遵守 HTTP 协议的网络通信 请求 request 向服务器发送的数据 请求头、请求体 HTTP 请求 HTTP Request，即要发送给服务器的数据，遵守HTTP协议固定格式的数据 HTTP 请求方法 GET GET一般是获取服务器上的数据，可向服务器传递少量数据 优点 GET速度相对较快 GET方式是通过URL传递数据，效率高 缺点 请求的数据在URL上，相对不安全 login.php?username=zs&pwd=123456 GET请求的结果能够被浏览器缓存 URL 中的参数 a. login.php负责处理登录过程的服务器脚本 b. ?后面跟要传到服务器上的参数(http协议的一部分) c. 参数以 键=值 的形式传递 d. 如果有多个参数使用&连接 http://127.0.0.1/php/login.php?username=admin&password=123 e. 参数中如果有中文和空格创建URL会失败, 需要使用%转义，进行URL编码 // 获取网络服务器上JSON数据 NSString *username = @\"张三\"; NSString *password = @\"zhan\"; NSString *urlString = [NSString stringWithFormat:@\"http://127.0.0.1/php/login.php?username=%@&password=%@\",username, password]; // 如果url字符串中有汉字或空格，要对url字符串中?后面的空格或者汉字做百分号转义 urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]]; NSURL *url = [NSURL URLWithString:urlString]; POST POST速度相对GET较慢 传递大量数据时使用，比如上传文件使用post POST一般是往服务器提交数据，并获取服务器返回的结果 POST方式是通过请求体传输数据，效率低 POST请求的数据用户看不到，并且不能被浏览器缓存相对安全，传递隐私数据时使用 POST请求头比GET请求头中多的东西 Content-Length: 25 // 发送给服务器数据的大小 Cache-Control: max-age=0 // 永不缓存数据 Content-Type: application/x-www-form-urlencoded // 请求头中的Content-Type // 告诉服务器，发给服务器的数据格式和url中传参的格式是一样的 key=value&k1=v1 HEAD 不获取响应体，只获取响应头 一般在下载之前先获取文件的大小 PUT PUT 上传 配置Apache服务器WebDav功能 put直接以文件的方式写入 post需要服务器端脚本支持 DELETE OPTIONS TRACE CONNECT PATCH 请求体中各项的含义 请求体: ------WebKitFormBoundaryqwY1zO88PZll2khX Content-Disposition: form-data; name=\"userfile\"; filename=\"pic03.jpg\" Content-Type: image/jpeg 二进制数据(要上传的文件) ------WebKitFormBoundaryqwY1zO88PZll2khX-- 含义: 分隔符 ------WebKitFormBoundaryqwY1zO88PZll2khX name 表单的name属性值 filename 传递给服务器的文件名 Content-Type 告诉服务器传递的文件类型 text/plain image/jpeg image/jpg image/png application/octet-stream等 二进制数据 要上传文件的NSData 响应 response 即服务器返回的数据 HTTP 响应 HTTP Response 即从服务器接收的数据，遵守HTTP协议固定格式的数据 响应的构成 状态行Status Line 响应头Headers 响应体Content 状态码 200 正常 401 没有授权 HTTPS 发送请求之前先挑战服务器(进行https的协商) https的协商 信任服务器返回的证书(公钥) 客户端产生随机秘钥 公钥对随机秘钥进行对称加密(rsa) 把公钥加密后的随机秘钥发送给服务器 使用随机秘钥加密数据和服务器交互 // https的证书认证交换秘钥加密信息等，这个方法实现后，可正常接收https的网页信息 - (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler { NSLog(@\"收到服务器挑战\"); // 判断认证方式(是用户名密码还是证书认证) if (challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust) { // 设置信任服务器的证书 NSURLCredential *credential = [NSURLCredential credentialForTrust:challenge.protectionSpace.serverTrust]; completionHandler(0,credential); } } Charles抓包监视HTTP请求和响应内容 压缩和解压 SSZipArchive【如果走完所有步骤还是无法解压，查看被加压的文件权限】 一台服务器的不同端口可以处理不同的网络请求 192.168.31.254 此地址的服务器可以处理以下不同的网络请求 http://192.168.31.254:5000/ 此服务器上处于 5000 端口的程序处理遵守 http 协议的网络请求(发送的字符串数据是http协议格式) ftp://192.168.31.254:21/ 21 端口的程序处理遵守ftp协议的网络请求(发送的字符串数据是按照ftp协议格式组织的) smb://192.168.31.254:445/ 445 端口的程序处理遵守smb协议的网络请求(发送的字符串数据是按照smb协议格式编制的) afp://192.168.31.254:548 548 端口的程序处理符合afp协议的网络请求(发送的字符串数据是按照afp协议格式编制的) "},"知识库/计算机通用/网络/路由器.html":{"url":"知识库/计算机通用/网络/路由器.html","title":"路由","keywords":"","body":" 路由器 Bridge LAN WAN 路由器 Bridge 桥接，简写br LAN Local Area Network局域网 Interface 接口 这代表着可用来给设备连接网络的口，分为有线接口和无线接口，有线接口就是路由器上的物理接口 Ethernet: eth0, eth1, eth2等，无线接口就是WLan，也就是你自己创建的wifi，对，这个也算是接口 不但可以通过物理接口有线连接网络，也可以通过无线网络的接口，无线接入互联网。 WAN Wide Area Network 广域网 "},"知识库/计算机通用/网络/软路由.html":{"url":"知识库/计算机通用/网络/软路由.html","title":"软路由","keywords":"","body":" 软路由 OpenWrt 软路由 华硕路由器的官方固件 AsusWRT 是基于 TomatoRT 的固件改出来的 这些软件都支持GPL协议 国外网友基于华硕AsusRT开发了 Asuswrt-Merlin的固件【梅林】 增加了很多有用的功能，并且允许第三方开发者开发一些插件在上面运行 KOOL Share论坛的地方，里面大神开发了 软件中心 的插件，与梅林固件打包在一起供大家下载 但是因为梅林固件对硬件有一定的要求，不是一般的机器就可以刷的，战斗民族哥们在梅林基础上改了改开发出了P4DAVAN MOD【老毛子固件】，让很多低端配置的硬路由也吃上了梅林，也享受到了各种插件带来的好处。但是梅林依然不是想刷就能刷的。所以出现了OpenWrt OpenWrt 运行在嵌入设备的 Linux 操作系统 基于OpenWrt做出了很多操作系统 PandoraBox 【潘多拉】 LEDE 光有操作系统是没有用的，没有软件中心，依然是白瞎，所以KOOLSHARE论坛的大神又把软件中心移到了LEDE上 LEDE + 软件中心 = 软路由LEDE系统 echo 0xDEADBEEF > /etc/config/google_fu_mode "},"知识库/计算机通用/网络/WNDR4300刷机.html":{"url":"知识库/计算机通用/网络/WNDR4300刷机.html","title":"WNDR4300v1刷机","keywords":"","body":" WNDR4300刷机 1. 通过TTL转USB线连接路由器和电脑 2. 通过Xshell连接控制com3端口的路由器 3. 进入TFTP恢复模式 4. 将电脑设置为和路由器在同一网段 5. TFTP刷机 在Windows上可以通过TFTP客户端，也可以如下通过cmd命令行 MAC系统下，通过终端 WNDR4300刷机 参考链接: https://zhuanlan.zhihu.com/p/76589656 https://www.zhihu.com/question/38537840 https://www.right.com.cn/forum/thread-2117545-4-1.html 刷机文件: http://gofile.me/4izOQ/PNIVuji5K 1. 通过TTL转USB线连接路由器和电脑 USB 转 TTL 的模块，型号名曰 CH340，或CH340G，到时候要装驱动就直接百度搜CH340G驱动 左下角的四个针脚就是TTL针脚，自下而上分别为 GND、RX、TX、VCC 。路由器与转接模块的连接方式为 GND - GND、RX - TXD、TX - RXD、VCC 不接。连接电脑安装TTL线的驱动后，路由器就是连接在电脑com3串口(串行通讯端口)的设备了。 2. 通过Xshell连接控制com3端口的路由器 在Xshell中，通过建立serial连接，连接到com3或4 设置登录脚本，等待字符串 \"Hit any key to stop autoboot\" ，发送\"?\" （发送任意字符都可以） 设置端口（port）为设备管理器中显示的 COM 端口名，一般为 COM3 。设置波特率（Baud Rate）为 115200 【如果乱码，换成117200】，数据位为8，停止位为1，校验位为 None，流控为 None 。确定，连接。 接通路由器电源，按下开关，如果出现下图中的显示，那就成功一半了。 开启路由器，Xshell中就会打印信息 因为路由器在循环重启，无法在Xshell中输入命令，所以通过创建执行脚本，可以让路由器在Auto boot的地方停下来。 3. 进入TFTP恢复模式 输入fw_recovery, 这时路由器就成为了TFTP服务器，ip地址为192.168.1.1，在69端口等待接收要刷入的系统。 4. 将电脑设置为和路由器在同一网段 断开电脑其他的网络，从路由器的lan口连接网线到电脑，这时电脑会连到路由器的网络，所以可以手动配置IP地址，要配置到跟路由器在同一个网段，也就是192.168.1.x，这样后面才能通过TFTP协议将要刷入的系统传入路由器。 5. TFTP刷机 这时就可以通过各种办法从TFTP客户端将要刷入的系统传入路由器了。 在Windows上可以通过TFTP客户端，也可以如下通过cmd命令行 此处下载固件：Index of /chaos_calmer/15.05/ar71xx/nand/ 文件名：openwrt-15.05-ar71xx-nand-wndr4300-ubi-factory.img 推荐直接 tftp 刷机： 1.电脑设置静态 IP： IP：192.168.1.2 子网掩码：255.255.255.0 默认网关：192.168.1.1 2.将电脑连接至路由器任一 LAN 口 3.在 Windows 控制面板 -> 程序 -> 启用或关闭Windows功能 中，开启 TFTP 客户端 4.关闭路由器电源，使用牙签(或其他类似物)捅住路由器背面的 reset 按钮不放，打开路由器电源，待电源指示灯呈绿色并有规律闪动即可松开 reset 按钮 5.传送固件，打开命令行窗口，使用 tftp -i 192.168.1.1 put /openwrt-15.05-ar71xx-nand-wndr4300-ubi-factory.img 传送固件至路由器，出现如下提示则固件传送成功： 传输成功: 3 秒 12451969 字节，4150656 字节/秒 6.静待路由器重启并完成固件刷新，切不可着急强制切断电源 7.待确认路由器重启成功后(比如可以登录http://192.168.1.1)，直接关闭路由器电源然后再打开电源，否则可能出现 5G WiFi 不可用的问题 MAC系统下，通过终端 先cd切换到有要输入系统的文件夹 输入 tftp 192.168.1.1 输入 binary，表示要以二进制数据传送 输入 verbose，表示要打印传送过程中的所有信息 输入 put 【要刷入的系统文件名】，如 put openwrt-ES-ar71xx-nand-wndr4300-ubi-factory.img 要修改路由器的网路信息时，进入路由器系统中，通过vim etc/config/network "},"知识库/计算机通用/网络/服务器软件.html":{"url":"知识库/计算机通用/网络/服务器软件.html","title":"服务器软件","keywords":"","body":"服务器软件配置 Apache Nginx "},"知识库/计算机通用/网络/使用Socket进行网络通信.html":{"url":"知识库/计算机通用/网络/使用Socket进行网络通信.html","title":"使用Socket进行网络通信","keywords":"","body":" Socket通信 Socket 是什么? Socket的通信过程 短连接 长连接 请求 响应 使用 GCDAsyncSocket 第三方库进行网络通信 Socket通信 Socket 是什么? A软件(自己的App)和B软件(Terminal)之间通信 A使用一个Socket监听本机的一个特定端口，B使用一个Socket通过IP地址找到A所在的主机，再通过端口号找到A的Socket(连接头)，因为A在通过自己的Socket监听此端口，然后开始AB之间的通信即数据传输。 通过IP地址和端口号找到对应的应用，搭一个桥梁，进行数据传输，相当于一个管道 一根管子连接两个油箱，Socket相当于油箱口连接头 在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 Socket的通信过程 创建Socket 连接到服务器 发送数据给服务器 从服务器接收数据 关闭连接 HTTP 协议 HTTP协议要求，请求结束后要关闭连接，节省服务器资源 短连接 http/1.0 : 接收到服务器响应以后，立即断开连接，下次再要从服务器请求数据时，再进行三次握手，建立连接。但节省服务器资源 长连接 http/1.1 : 接收到服务器响应后，不断开连接，下次从服务器请求数据时，直接发送请求，不需要进行三次握手。一直消耗服务器资源。【当服务器响应结束后，连接会等待非常短的时间，如果这个时间内没有新的请求，就断开连接】 比如打开百度的网页，要显示网页，一次性会发送很多个请求，获取文字、图片及视频等，这些请求会在一次长连接中完成。 请求 A软件向B软件发送数据就是请求 A向B发送的数据是一大串，HTTP协议要求把这一大串按照协议规则分割为请求头和请求体 请求头 在请求头中配置一些信息，如请求方法GET还是POST、服务器主机(Host)地址或者域名信息等。 User-Agent: 可以配置请求什么设备的网页 Connection: keep-alive 或者 close 可以配置长连接或者短连接 请求体 可以在请求体传输数据 响应 B软件向回应A软件的请求就是响应 B向A发送的数据是一大串，HTTP协议要求把这一大串按照协议规则分割为响应头和响应体 响应头 响应头中有B的地址、状态码等信息 server: GitHub.com status: 304 响应体 响应体中才是传输的数据，比如一个html网页的字符串格式编码的二进制data，json 字符串格式编码的二进制data，plist 、xml等格式编码的二进制数据。AFN默认会把响应体序列化为 JSON 字符串，可以通过更改响应体序列化器为其他格式来接收其他编码格式的响应体，比如，如果响应体是 htmlString格式的，则需要把响应体序列化器更改为AFHTTPResponseSerializer, 才可以正确的解析出响应体的信息。 使用 GCDAsyncSocket 第三方库进行网络通信 代码见 Mac服务器 Socket是纯C语言的 GCDAsyncSocket是对Socket的封装的OC语言的一个第三方库 服务器端有两个Socket，一个负责监听(宿管大妈)，一个负责通信 初始化一个Socket对象作为服务器A一端的Socket(连接头)，用它绑定一个端口号，然后监听此端口号 /// 创建服务器连接头Socket lazy var server:GCDAsyncSocket = GCDAsyncSocket(delegate: self, delegateQueue: .main) server.accept(onPort: UInt16(portNumber.intValue)) // 绑定并监听一个端口号 /// 绑定并监听一个端口号 /// - Parameter sender: 监听按钮 @IBAction func listeningPort(_ sender: Any) { // 使用 socket 绑定并监听端口 do { try server.accept(onPort: UInt16(portNumber.intValue)) } catch { print(\"监听端口\\(portNumber.intValue)出错:\\(error)\") } // Socket连接之后就开始读取数据 readData() } func readData() { timer = Timer.scheduledTimer(timeInterval: 1.0, target: self, selector: #selector(readingData), userInfo: nil, repeats: true) // 将定时器添加到当前运行循环中 RunLoop.current.add(timer!, forMode: .common) } /// 从所有客户端Socket中读取数据 @objc func readingData() { for newSocket in clientSocketsArray { newSocket.readData(withTimeout: -1, tag: 0) // 调用此方法才会调用 didRead data代理方法 } } 如果有新来的客户端，比如B的Socket访问我们正在监听的端口号，就会调用下面代理方法 func socket(_ sock: GCDAsyncSocket, didAcceptNewSocket newSocket: GCDAsyncSocket) 通过此代理方法获取到访问我们监听的端口号的B软件的Socket(连接头)并持有，以便后面进行通信，否则会被释放 /// 当接收到新 socket 通信时 /// - Parameters: /// - sock: 当前 socket【服务器】 /// - newSocket: 新来的客户端 socket func socket(_ sock: GCDAsyncSocket, didAcceptNewSocket newSocket: GCDAsyncSocket) { print(\"newSocket: \\(newSocket)\") print(\"ip地址: \\(newSocket.connectedHost ?? \"\")\") print(\"端口号:\\(newSocket.connectedPort)\") print(\"连接时间: \\(Date())\") print(\"断开时间:\\(\"\")\") // 保存正在访问的客户端的Socket clientSocketsArray.append(newSocket) // 当第一次连接时，读取一次数据 newSocket.readData(withTimeout: -1, tag: 0) } 服务器A接收客户端B消息 调用客户端B的Socket的 readData(withTimeout:-1, tag:0) 就会读取客户端发来的数据，通过代理方法 socket(_ sock: GCDAsyncSocket, didRead data: Data, withTag tag: Int)来接收数据 /// 通过代理接收数据【客户端Socket的readData被调用时会被调用】 /// - Parameters: /// - sock: 客户端的Socket /// - data: 客户端发送过来的数据 /// - tag: func socket(_ sock: GCDAsyncSocket, didRead data: Data, withTag tag: Int) { let message = String.init(data: data, encoding: .utf8) print(\"客户端发来的贺电: \\(message ?? \"\")\") sock.write(message?.data(using: .utf8), withTimeout: -1, tag: 0) } 服务器A向客户端B发送消息 当服务器的Socket创建连接之后，也就是绑定并监听端口之后，初始化一个定时器，一直调用保存下来的，连接上我们监听的端口的所有Socket的readData，然后在代理方法中接收数据。 由A给B发送消息，则找到B的Socket，调用它的readData方法 "},"知识库/计算机通用/网络/NSURLSession.html":{"url":"知识库/计算机通用/网络/NSURLSession.html","title":"NSURLSession","keywords":"","body":"NSURLSession 简介 之前发送网络请求的过程 URL -- URLRequest -- URLConnection iOS7以后 -- NSURLSession 用于替代NSURLConnection 支持后台运行的网络任务 暂停、停止、重启网络任务，不再需要自己封装NSOperation 下载、断点续传、异步下载 上传、异步上传 获取下载、上传的进度 DataTask 要拿网页HTML数据、JSON、XML数据时使用 【默认挂起，须resume】 UploadTask 要上传文件时使用 默认挂起，须resume 配置Apache服务器WebDav功能 演示 HTTP 的Method，PUT GET DELETE PUT 上传 put直接以文件的方式写入 post需要服务器端脚本支持 通过session发送put请求上传文件 如果直接上传返回状态码401 --没有授权 因为WebDav设置了基本身份验证，所以请求的时候得携带验证的字符串 自己上传或删除一个文件，用charles监视请求 请求头有意向Authorization: Basic YWRtaW46MTIzNDU2 YWRtaW46MTIzNDU2是base64编码的账号和密码 通过base64解码还原admin:123456 常用的请求头 post时候的Content-Type、Range、User-Agent、Authorization DownloadTask 要下载文件时使用 启动任务--执行的过程是异步的 默认挂起，须resume 回调获取文件数据 downloadDelegate获取文件下载进度和实现断点续传，不能使用sharedSession【delegate会出现循环引用】 会出现的问题 狂点暂停，再继续会闪退 暂停，关闭程序重新开始，继续会闪退 多次点击继续会重复从原来的地方继续下载，所以每点击一次就清空一下resumData 在界面上放个scrollView，拖动的时候下载任务不会停止 因为下载任务是异步执行的(即使把下载任务添加到主队列中) 当发生合适的事件后，通知代理对象 所有代理方法都是在主线程上异步执行的(任务添加到主队列的时候) 拖动scrollView的时候下载不会停止 内存暴涨的解决办法 NSFileHandle 在文件存储的路径，实现下一点，往那个路径存一点的功能 还能实现一点一点读的功能？可以解决数组全部加载到内存的问题？ // 为了防止把下载的数据全部加载到内存中，造成内存暴涨闪退，用fileHandle实现下一点往内磁盘存一点，不占用内存 - (void) saveData:(NSData *)data { // 创建保存文件的路径 NSString *filePath = @\"/Users/joyawang/Desktop/v.mp4\"; // NSFileHandle *handle = [NSFileHandle fileHandleForWritingAtPath:filePath]; if (handle == nil) { // 如果此路径还没有文件，先创建文件 [data writeToFile:filePath atomically:YES]; } else { // 开始处理文件 // handle offset指针默认指向文件的头部，而我们要往文件的尾部写入数据，所以，先将指针指向尾部 [handle seekToEndOfFile]; // 写入数据 [handle writeData:data]; // 关闭处理文件 [handle closeFile]; } } NSOutputStream NSStream 流 抽象类 -(void)open; -(void)close; NSOutputStream 输入流 在内存和硬盘之间创建一个管道，运送一些字节 把字节通过流写入文件 [write buffer maxLength]; 步骤 接收到响应头开始创建流并打开 接收到数据开始写文件 下载结束或下载出错，关闭流 问题 如果文件已存在，再次下载的时候会追加文件[导致文件比原来大] 在文件下载之前，先判断有文件，如果有则删除重新下载？ NSURLSessionConfiguration 在一个地方配置请求头的信息，所有任务都使用此请求头 作用 可以设置请求头(Content-Type Range User-Agent Authorization等) 可以设置最大连接数 可以设置超时时长，缓存策略 类构造方法 defaultSessionConfiguration 会使用磁盘缓存，账户信息存储到钥匙链，如果有cookie会携带cookie ephemeralSessionConfiguration 没有磁盘缓存，不存储账户信息，不携带cookie 数据存储在内存，速度快，如果要存储到磁盘须自己写 backgroundSessionConfigurationWithIdentifier 在一个单独的进程上下载 app进入后台或终止之后，依然可以继续下载 属性 HTTPAdditionalHeaders 添加请求头 requestCachePolicy 缓存策略 timeoutIntervalForRequest 请求的超时时长 allowsCellularAccess 运行蜂窝网络访问 HTTPMaximumConnectionPerHost 主机的最大连接数 NSURLResponse MIMEType 返回的文件的类型Content-Type ExpectedContentLength 文件的预期大小(实际大小) suggestedFilename 建议保存的文件的名字 "},"知识库/计算机通用/网络/URL 及其构成详解.html":{"url":"知识库/计算机通用/网络/URL 及其构成详解.html","title":"URL 及其构成详解","keywords":"","body":" URL 及其构成详解 组成部分2: 主机(服务器)IP地址或域名 组成部分3: 端口号 组成部分4: 路径 URL 及其构成详解 URL 组成格式 网络协议://主机IP地址或域名:端口号/路径 网络协议：不同的协议代表不同的资源获取方式 主机地址：主机的唯一标识(ip地址、域名) 路径: 此 url 要访问的资源在主机中的具体位置 组成部分1: 网络协议 存在意义 回忆socket，最原始的网络通信就是通过socket发送和接收二进制数据，在发送和接收时数据的编制遵循一定的规则，才可以正常通信，而不同的规则就是网络协议，比如http协议要求，发送的数据叫做请求，请求有请求头和请求体，请求头中不同field代表不同的含义，这样发送和接收时都遵守这个协议，数据就可发送成功，还有用于其他网络传输的协议。 http 发送的字符串数据是按照 HTTP 协议格式编制的，网络间传输网页(声音、视频、文字等)的URL协议，超文本传输协议 (默认端口80，需要有个处理http请求的软件如apache监听服务器电脑的80端口)超文本传输协议，网页(声音、视频、文字等)传输 http://192.168.31.254:5000/ http://www.baidu.com:80/ http:// www.itheima.com:80/images/xx00.png ftp 网络间传输文件的协议 ftp://192.168.31.254:21 FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP协议包括两个组成部分，其一为FTP服务器，其二为FTP客户端。其中FTP服务器用来存储文件，用户可以使用FTP客户端通过FTP协议访问位于FTP服务器上的资源。在开发网站的时候，通常利用FTP协议把网页或程序传到Web服务器上。此外，由于FTP传输效率非常高，在网络上传输大的文件时，一般也采用该协议。 默认情况下FTP协议使用TCP端口中的 20和21这两个端口，其中20用于传输数据，21用于传输控制信息。但是，是否使用20作为传输数据的端口与FTP使用的传输模式有关，如果采用主动模式，那么数据传输端口就是20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。 smb 发送的字符串数据是按照smb协议格式编制的 Server Message Block SMB，网络间文件共享的协议，默认端口139、445等 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。 smb://192.168.31.254:139 afp Apple Filing Protocol （AFP）是一种网络协议，为Mac计算机提供文件服务，苹果的网络间文件传输协议 afp://192.168.31.254:548 file 可以访问的Mac本地的文件路径的URL file:///Users/joyawang/Desktop/qq空间/244092911 smtp 发送邮件的协议 pop3 接收邮件的协议 tel:// 电话通信协议 sms:// 短信通信协议 组成部分2: 主机(服务器)IP地址或域名 IP 地址 IPV4 IP 地址第 4 版 x.x.x.x 表示互联网中的一个地址 每个x可以是从0到255的任意一个数(256个)，而要表示这个范围的数需要8位二进制数，有4个这样的数，所以需要32位二进制数，而32位二进制数可以表示(2^32)42.95亿个ip地址(256256256*256) IPV6 IP 地址第 6 版 用128位二进制表示一个ip地址，所以可以有(2^128)2的128次方个IP地址 常见 IP 地址: 192.168.1.1 127.0.0.1 回环地址(本机地址) 255.255.255.255 广播 0.0.0.0 any 私有Private IP address: home router, business router 10. 192.168. 172.16. 举例 协议://主机ip地址或域名:端口号/路径 http://www.baidu.com/index.html http:// www.itheima.com:80/images/xx00.png smb://192.168.31.254 从finder去Joyacloud的URL https://joyacloud.cn8.quickconnect.cn/ 从浏览器去JoyaCloud的域名URL http://192.168.31.254:5000/ 从浏览器去JoyaCloud的本地ip地址URL afp://192.168.1.2 file:///Users/joyawang/Desktop/qq空间/244092911 可以访问的Mac本地的文件路径的URL /Users/joyawang/Desktop/qq空间/244092911 Mac本地的文件路径 域名 IP地址不好记，域名好记，但是在访问某域名时需要域名解析服务器将域名解析为对应的IP地址 www.baidu.com 和 182.61.200.6 访问的是同一台服务器，一个是域名，一个是 ip 地址 其它概念 Subnet Mask子网掩码 255.255.255.255 和IP地址一起使用可以确定另一个电脑是否和你在同一网络 which is used to decide whether or not some other computers on the same network as you Gateway/Router 网关/路由器 192.168.31.1 ISP Internet Service Provider 网络服务提供商 DHCP Server 动态IP地址分配服务器 DNS Server 域名解析服务器 免费DNS服务器 谷歌：8.8.8.8 国内：014.014.014.014 WAN口 Wide area network interface 广域网接口 主要用于连接外部网络，如ADSL、DDN、以太网等各种接入线路。 宽带路由器的【路由】功能就是体现在WAN口IP地址和LAN口IP地址之间的数据路由上，我们通常根据网络运营商提供的接入方式来设置WAN口的网络参数，通常有静态IP地址、动态IP地址或PPOE等方式，它与网络运营商的接入设备处于同一个【外部】网络中。 LAN口 Local Area Network Interface 局域网接口 用来连接家庭内部网络，主要与家庭中的交换机、集线器或PC相连。 LAN口的IP地址则设置为本地局域网内的IP地址，通常是我们自己可以在宽带路由器上自行设定的IP地址，LAN口下所连接的计算机组成一个【本地局域网】，路由器的LAN口IP地址是这个网络的网关。 hosts 域名本地解析 相当于本地域名服务器 操作系统中的hosts文件则是有着类似“本地DNS服务器”的作用，而且比网络上的DNS具有更高的优先级。如果你在hosts里面配置了某个域名和IP的对应关系，比如127.0.0.1 -> localhost，那么当你在本机访问localhost时，系统首先会从hosts里面解析出127.0.0.1这个IP，而不会再去查询网络上的DNS服务器。hosts文件仅对本机生效，对其他电脑和网站本身不会造成任何影响 Windows 系统 Hosts 文件路径：C:\\Windows\\System32\\drivers\\etc\\hosts； Mac 系统 hosts 文件路径：/etc/hosts； Linux 系统的 hosts 文件一般也是在：/etc/hosts； Android 系统的 hosts 文件路径：/system/etc/hosts (需要Root权限修改)； 组成部分3: 端口号 介绍 连接到某个服务器后，要根据URL协议类型选择服务器上不同的处理数据的程序，如处理http协议的apache软件一般是服务器的80端口。如果没有安装web服务器软件的话，80端口一般是空闲的。 服务器上会有不同的程序处理不同的网络请求，端口号就是每个程序的身份标识。(是逻辑地址意味着不是物理的，不是物质上实际存在的) HTTP默认的端口80：即向一个服务器发送一个HTTP网络请求时，这个网络请求到了服务器后，直接调用服务器上监听80端口的方法，也就是运行那个程序。 FTP协议默认的端口21 pop3 接收邮件的协议110 smtp 发送邮件的协议25 端口的分类 公认端口(Well Know Ports) 这类端口也常称为“常用端口”。这类端口的端口号从0-1024，它们紧密绑定于一些特定的服务。通常这些端口的通信明确表明了某种服务的协议，这种端口是不可再重新定义它的作用对象。比如:http默认80，ftp默认21 注册端口(Registered Ports) 端口号从1025到49151.分配给用户进程或应用程序。这些进程主要是用户选择安装的一些应用程序，而不是已经分配好了的公认端口的常用程序。 动态或私有端口(Dynamic or Private Ports) 从49152到65535.之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配 例如192.168.31.254这个服务器地址，不同的协议类型会导致访问时访问不同的端口号 http://192.168.31.254:5000/ 192.168.31.254这个地址上的服务器，遵守http协议的web请求会被5000端口的程序处理 smb://192.168.31.254 192.168.31.254这个地址上的服务器，遵守smb协议的请求会被端口的程序处理 组成部分4: 路径 /Users/joyawang/Desktop/qq空间/244092911 Mac本地的文件路径 "},"知识库/计算机通用/网络/URL 类.html":{"url":"知识库/计算机通用/网络/URL 类.html","title":"URL 类","keywords":"","body":"iOS 中的 URL 类 meituan:///showP1:P2:P3:P4:/大西瓜/红牛/小樱桃/小肥羊 属性 scheme 协议头 meituan host 主机头 nil 如果没有 /// pathComponents 返回数组 URL 中所有路径的数组 show：P1:P2:P3:P4: 大西瓜 红牛 小樱桃 小肥羊 query 查询字符串 URL 中 ? 后面所有的内容 "},"知识库/计算机通用/网络/WKWebView.html":{"url":"知识库/计算机通用/网络/WKWebView.html","title":"WKWebView","keywords":"","body":"WKWebView webView/WKWebView【详见Practices中的webView & HTML & JavaScript】 WKWebView的使用详解 实例应用 Practices中的webView & HTML & JavaScript 彩票设置界面 跳转到网页的指定位置 JL微博_JLOAuthViewController 自动填充用户名密码功能 webView 的用途 可加载本地doc、pdf、mp4、html等文件 使用 自动检测网页中的电话、邮件地址、链接 // 在创建webView时，用configuration设置【WKWebView】 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; config.dataDetectorTypes = WKDataDetectorTypeAll; WKWebView *wv = [[WKWebView alloc] initWithFrame:UIScreen.mainScreen.bounds configuration:config]; // 【webView，已废弃】 dataDetectorTypes = UIDataDetectorTypeAll iOS APP 与 HTML 交互 iOS 的控件执行 JavaScript 代码控制 Html5 页面的变化 WKWebView 在用 先设置WKWebView的navigationDelegate 在代理方法didFinishNavigation中调用 [webView evaluateJavaScript:code completionHandler:nil]; webView 已废弃 先设置webView的代理，在代理方法webViewDidFinishLoad里面调用下面方法 [webView stringByEvaluatingJavaScriptFromString:] webView 加载的 html5 页面上的控件执行 iOS 的方法 WKWebView 在用 将JavaScript中要调用的OC方法名先注册到wkWebView.configuration.userContentController中【只写一个方法名即可】 [wv.configuration.userContentController addScriptMessageHandler:self name:@\"showAlert\"]; 遵守WKScriptMessageHandler协议，在协议方法userContentController didReceiveScriptMessage中拦截已注册的方法名并进行本地处理【在这里实现JS要调用的方法】 在此页面销毁时，移除注册的方法，否则会造成内存泄漏[wv.configuration.userContentController removeScriptMessageHandlerForName:@\"showAlert\"] 在HTML5的JavaScript中使用window.webkit.messageHandlers.showAlert.postMessage(\"我是来自HTML网页里JavaScript中的消息\");调用注册的方法 showAlert为注册的方法名 postMessage中为传递给该方法的参数 webView 已废弃 先在html中创建一个超链接 调用OC的方法 source:/// 自定义协议 showMessage:方法名、方法参数 helloword 参数 在webView的代理方法中 从request获取协议信息、方法名、参数 request.URL.scheme协议信息 request.URL.pathComponents[1] 方法名 request.URL.pathComponents[2] 参数 通过方法名创建SEL 判断respondsToSelector后，使用performSelector执行这个SEL对象 delegate 方法 WKNavigationDelegate 页面开始加载时调用 didStartProvisionalNavigation 当内容开始返回时调用 didCommitNavigation 页面加载完成之后调用 didFinishNavigation 页面加载失败时调用 didFailProvisionalNavigation 接收到服务器跳转请求之后调用 didReceiveServerRedirectForProvisionalNavigation 在收到响应后，决定是否跳转 decidePolicyForNavigationResponse 在发送请求之前，决定是否跳转 decidePolicyForNavigationAction WKUIDelegate "},"知识库/计算机通用/内存/内存中的五大区域.html":{"url":"知识库/计算机通用/内存/内存中的五大区域.html","title":"内存管理","keywords":"","body":"内存管理 内存中的五大区域 Stack 栈 Store all the information about function call executions, to store all the local variables 作用：存储局部变量(结构体变量存储于此) 回收：当局部变量的作用域被执行完毕后，此局部变量就会被系统立即回收； 特点： 声明变量时，字节空间由高地址向低地址分配； 空间相对较小，但访问效率较高 Heap 堆 / Free Store We can request memory from the heap during runtime, and that's what we do when we use malloc or new operator. Fixed in size decided at compile time, which means they don't grow while the application is running. 作用：存储OC类对象，程序员手动申请(calloc, malloc等函数) 回收：MRC下 手动回收, ARC 下自动回收 特点： 每次申请的字节地址都是从0开始，且每次地址不一定挨着，但每次申请的指定字节空间是挨在一起的、连续的 空间相对较大，但访问效率相对栈较低 BSS 段 作用：存储未初始化的全局变量、静态变量 回收：一旦初始化，转存至数据段 Static / Global 数据段 / 常量区 Store the global variables that live for the entire lifetime of the program of the application. 作用：存储已经初始化的全局变量、静态变量和常量数据 回收：直到程序结束才被回收 特点：以字符指针形式存在常量区的字符串数据不能改 Code(Text) 代码段 Store all the instructions needs to be executed; 作用：存储代码(C语言的函数、结构体类型声明代码、OC类代码[以Class对象形式存储]) 回收：程序结束回收 C 程序中使用 堆内存 C functions to use heap memory malloc returns a void pointer that gives us the address of the first byte in this block, the block of memory that is allocates. So, using malloc you kind of say that hey, give me a block of with these many bytes. calloc advance malloc. initial to 0 realloc change the size of the block of the memory. free 程序运行过程中 栈内存 的变化 At any time during the execution of the program, the function at the top of the stack is executing and rest is kind of paused waiting for the function above to return something and then is will resume execution. 堆内存 和 栈内存 的区别和各自的作用？ If the allocation of variables and functions in stack exceeds 1MB(assumption), our program will crash. Further the allocation and deallocation of memory onto the stack happens by a set rule, when a function is called, it is pushed onto the stack on top of the stack, when it is finished, it is popped and removed from the stack. It is not possible to manipulate the scope of a variable if it is on the stack. Another limitation is that, if we want to declare a large data type like an array as local valuable, we need to know the size of the array at compile time only. If we have a scenario like we have to decide how large the array will be based on some parameter during runtime then it is a problem with stack. For all these problems, like allocating large chunks of memory or keeping variable in the memory till the time we want, we have heap. Heap is also called dynamic memory and using the heap is referred to as dynamic memory allocation. So, as you see, in terms of the scope of the variable, anything allocated on the heap is not automatically deallocated when the function completes like on the stack. And, it does not need to live for the whole life time of the application like a global valuable. We can control when to free anything on the heap, when to deallocate anything on the heap. "},"知识库/计算机通用/内存/内存管理.html":{"url":"知识库/计算机通用/内存/内存管理.html","title":"内存管理","keywords":"","body":"内存管理 内存的作用 存储数据 如何将数据存储到内存中 当数据不再被使用时，占用的内存空间如何被释放 内存管理的范围 主要指的是 程序员手动申请的存放 对象 的 Heap 堆区的管理 栈、BSS段、数据段、代码段中的空间回收由系统自动管理，不需要人工干预 在iOS开发中，并没有JAVA或C#中的垃圾回收机制(运行时)，但是所有 OC 对象内部都有一个 retainCount，即引用计数器，其他对象每引用一次此对象，此对象的引用计数器加1，而每次引用完毕后，此对象的引用计数器减1，这样，当引用计数器为0时，就代表此对象不被使用了，系统就会释放 free 这个对象。 引用 refrence 当一个对象 A 的某个属性为另一个 B 对象时，这个属性是个指针类型的变量，它就保存了 B 对象在堆内存中的地址，这样就就叫做 A 引用 B 只要有 1 个对象 引用着 B，那么 B 对象就不能轻易释放，否则会出现 野指针 的问题导致程序崩溃 MRC (手动引用计数) 引用计数器: 每个对象都有1个属性，叫做 retainCount，占据 8 个字节，类型是 unsigned long 记录当前的对象被多少人使用 默认情况下，创建1个对象出来，它的引用计数器是1 当对象的引用计数器为 0 的时候，系统就会立即回收这个对象，并调用对象的 dealloc 方法 MRC 内存管理关键字 retain 在声明对象 A 的属性时，如果此属性的类型为 B OC对象，则需要使用 retain 属性修饰符，即当A的这个属性被赋值 B 对象时，B 的 retainCount，即引用计数器会加1，表示 A 引用 B，或者 A 在使用 B release 创建一个新对象后，引用计数器默认为1，所以在使用此对象后需手动 release 当 A 对象销毁时，即 A 不再使用 B 对象了，那么 A 对象必须在自己的 dealloc 方法中，向 B 发送一条 release 消息，B 的 retainCount，即引用计数器会减 1 内存管理原则 有对象的创建，就要匹配 1 个 release retain 的次数 和 release 的次数要匹配 体现在刚创建了对象，就立马匹配一个向它发送 release 谁用谁 retain，谁不用谁 release 体现在声明OC对象类型的属性时 retain 修饰符，和 dealloc 中向该属性发送 release 只有多一人使用时才 retain，少 1 人使用时才 release /// Seller 类 @interface Seller : Person /* > 货物属性的类型是 productForSale，是个 OC 对象，当此属性被赋值该对象时，会向它发送一条 retain 消息 代表该 Seller 对象 引用 此 Goods 对象 > 根据 MRC 内存管理原则，谁用谁 retain，谁不用谁 release，必须在此 Seller 类 的 dealloc 方法中向 productForSale 发送 release 代表当 Seller 对象销毁时，就结束对 Goods 对象的引用，productForSale 对象引用计数器减 1 */ @property(nonatomic, retain) Goods *productForSale; @end - (void)dealloc { [_productForSale release]; [super dealloc]; } 在 MRC 下，重写 dealloc 方法的规范 必须调用父类的 dealloc 方法，并且放在最后调用 因为子类中有父类的属性，而父类属性的 release 是放在父类的 dealloc 方法中的 为了能够释放所有的对象，必须要调用父类的 dealloc 方法 ARC (自动引用计数) 编译的时候，系统会在合适的地方插入 retain 和 release 没有任何强指针指向一个对象的时候，这个对象就会被立即回收 ARC 很好，但是最怕两个对象互相引用，这样它俩的引用计数器都不为0，所以都无法被系统释放 如果一个对象没有任何强类型的指针指向它，即便有 weak 类型的指针指向它，也会被自动释放， 表象: 只要没有强指针指向这个对象，它就会被释放 本质: 对象的引用计数器为 0 时，自动释放 weak 表示这个属性指向的对象被当前对象弱引用，即底层声明此属性时，不用 retain 关键字，即此属性被赋值时，不会向用来赋值的对象发送 retain 消息，它的引用计数器不会加 1 strong 强引用，底层有 retain 关键字，即此属性被赋值时，向用来赋值的对象发送 retain 消息，它的引用计数器会加 1 unowned ARC 和 MRC 的转换 将整个项目设为MRC Target - Build Settings - All 搜索 \"ARC\", 在 Apple Clang - Language - Objective-C 中 将 Objective-C Automatic Reference Counting 从 Yes 改为 No 将特定类设为MRC(告诉编译器，将来编译这个类时用MRC编译)禁用arc Build Phases - Compile Source - 特定类 - Compiler Flags - \"fno-objc-arc\" 将 MRC 转为 ARC Edit - Convert - To Objective-C ARC "},"知识库/计算机通用/内存/内存泄漏.html":{"url":"知识库/计算机通用/内存/内存泄漏.html","title":"内存泄漏","keywords":"","body":"内存泄漏 什么叫内存泄漏？ 指对象没有被回收，该回收的时候没有被回收，一直驻留在内存中知道程序结束 单个对象发生内存泄漏的原因 有对象的创建，没有匹配的 release retain 与 release 不匹配 在不恰当的时候，指针赋值为 nil 在方法中不当使用 retain 如何做到单个对象被正确释放 有对象的创建就要有对象的 release 有多少个 retain 就要有多少个 release 不要轻易为 1 个指针赋值为 nil，除非指针是 1 个野指针 在方法中不要轻易的为参数 retain 多个对象的内存泄漏 当 1 个对象的属性是另外 1 个对象的时候，如果对这个属性的 set 封装还是像我们基础班那样直接赋值，就会出现野指针的问题 set 方法的内存管理 在 MRC 的模式下，如果属性的类型是 OC 对象类型的，这个属性的 setter 方法应该如何写？ /// _dog 属性的 setter 方法 /// @param dog 用来赋值的 dog 对象 - (void)setDog:(Dog *)dog { // 当赋值的对象和就对象是同一对象时，什么也不做 if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值 { // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性 // 1. 就对象不再使用，向旧对象发送一条 release 消息 [_dog release]; // 2. 使用新对象，向新对象发送一条 retain 消息 _dog = [dog retain]; } } 循环 retain 当两个对象相互关联时 人对象中有 1 个车 车对象中有 1 个人 如果这两个 @property 都使用 retain，就会出现泄漏 解决方案: 1 端 retain，1 端 assign，使用 assign 的那端不再需要在 dealloc 中 release 了 "},"知识库/计算机通用/内存/@property.html":{"url":"知识库/计算机通用/内存/@property.html","title":"@property","keywords":"","body":"@property @property 的作用 @property int age; 生成一个私有的，int 类型的属性 _age；是声明在 @implementation 的大括弧中 生成 getter、setter 的声明 生成 getter、setter 的实现 setter 的实现: 将传进来的值不做任何操作直接赋值给属性 @property 可以带参数，不同的参数有不同的效果 与多线程相关 atomic: 默认的 nonatomic: 选择 nonatomic，因为效率高 【MRC下使用】和生成的 set 方法相关的参数 retain 生成的 set 方法就是 标准的 MRC 内存管理代码，不再是直接赋值了 而是先判断新旧对象是否为同一个对象，如果不是，release 旧的，retain 新的。 retain 只是生成的 set 方法是标准的 MRC 内存管理代码，不会自动的在 dealloc 中 release，所以我们还要在 dealloc 方法中手动的 release 属性指向的对象 /// 标准的 MRC 内存管理代码 /// _dog 属性的 setter 方法 /// @param dog 用来赋值的 dog 对象 - (void)setDog:(Dog *)dog { // 当赋值的对象和就对象是同一对象时，什么也不做 if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值 { // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性 // 1. 就对象不再使用，向旧对象发送一条 release 消息 [_dog release]; // 2. 使用新对象，向新对象发送一条 retain 消息 _dog = [dog retain]; } } // retain 不会生成这里的代码，需要手动 release dog - (void)dealloc { // 在此 Person 对象销毁的时候，向持有的 name 和 dog 对象分别发送 release // 让 引用计数器 减 1 [_name release]; [_dog release]; [super dealloc]; } assign 默认值，生成的 set 方法中不做其他任何操作，直接赋值 如果属性的类型是 OC 对象类型的，使用 retain 如果属性的类型是 非OC 对象类型的，使用 assign 【ARC下使用】strong 、weak 都是应用在 属性的类型 是 OC 对象的时候 大部分时候，都用 strong 只有当出现循环引用的时候，一边用 strong，一边用 weak 和生成的属性 只读、读写 有关的参数 readwrite: 默认值， getter setter 同时生成 readonly: 只生成 getter 修改生成 getter、setter 方法的名字 一般情况下别改，只在 1 个地方 当属性的类型是 BOOL 类型的时候，就更改 getter 的名字以 is 开头 "},"知识库/计算机通用/内存/野指针和僵尸对象.html":{"url":"知识库/计算机通用/内存/野指针和僵尸对象.html","title":"野指针和僵尸对象","keywords":"","body":"野指针和僵尸对象 对象回收的本质 内存回收的本质 申请1个变量，实际上就是向系统申请了指定字节数的内存空间，这些空间系统就不会再分配给别人了 当变量被回收的时候，代表变量占用的字节空间从此以后系统可以分配给别人使用了 但那个字节空间存储的数据还在那里 对象回收的本质 所谓的对象回收，指的是对象占用的空间可以分配给别人 当这个对象占用的空间没有分配给别人前，对象的数据还在 野指针 C 语言中的野指针 定义了一个指针变量，没有初始化，这个指针变量的值是一个垃圾值，指向一块随机的内存空间，这个指针叫做野指针 OC 中的野指针 指针变量指向的对象已经被回收了，这样的指针叫野指针 僵尸对象 一个已经被释放的对象，但是它所占用的空间还没被系统分配给别人，这样的对象叫僵尸对象 开启僵尸对象功能，将会使僵尸对象内存空间不能被访问，直接报错 Edit Scheme - Run - Diagnostics - Enable Zombie Objects 使用野指针访问僵尸对象会报错，如何避免僵尸对象错误？ 当一个指针成为野指针后，将它设置为 nil 当一个指针的值为 nil 后，通过这个指针去调用对象方法时，包括使用点语法时，不会报错 只是没有任何反应 但是通过 -> 直接访问属性就会报错 无法复活一个僵尸对象 开启僵尸对象检测 通过野指针访问僵尸对象，不管僵尸对象的空间有没有分配给别人，都会报错 如何避免使用僵尸对象 当指针为野指针的时候，将其赋值为 nil "},"知识库/计算机通用/多线程/多线程.html":{"url":"知识库/计算机通用/多线程/多线程.html","title":"多线程、Runloop、自动释放池","keywords":"","body":"多线程 存在的意义 在主线程(UI线程)上执行耗时任务会造成卡顿，比如网络通信、循环等 屏幕两个控件接收用户点击，一个控件点击后会执行耗时操作，这时再点击另外一个就不起作用，界面卡死了(阻塞)。 解决办法：将耗时操作放到另外一个线程去执行 概念 进程 Process 指在系统中正在运行的一个应用程序 每个进程之间是独立的，每个进程均运行在其专用的受保护的内存空间内 通过\"活动监视器\"可以插卡Mac系统中所开启的进程 线程 Thread 1个进程由多个线程组成(1个进程只要要有1个线程) 线程是进程的基本执行单元，一个进程的所有任务都在线程中执行 主线程 一个程序运行后，默认会开启一个线程，成为”主线程“或”UI线程“，一般用来刷新UI界面，处理UI事件(比如：点击、滚动、拖拽等事件) 主线程的runloop默认开启，保证程序不退出 子线程 除了主线程都是子线程，子线程的runloop默认不开启 多线程 Multi - Thread 一个进程可以开启多个线程，多个线程可以”同时“执行不同的任务 多线程可以解决程序阻塞的问题 多线程可以提高程序的执行效率 队列 Queue 将一些耗时的任务全部添加到队列中，CPU从队列中取出任务执行 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. 串行队列 Serial Queue 这种队列中的任务一个一个的按顺序执行 并行队列 Concurrent Queue 这种队列中的任务可以好几个同时开始执行 同步 sync CPU执行当前线程的代码时，遇到Sync会等待，Sync后的代码块执行完毕再执行下段代码 异步 async CPU执行当前线程的代码时，遇到Async会直接跳过其中的代码块直接执行下段代码【此段代码另开线程执行去了】 多线程原理 CPU快速在多个线程之间切换执行 CPU调度线程的时间足够快，就造成了多线程的“同时”执行 线程执行完毕会自动销毁 多线程优缺点 优点 能适当提高程序的执行效率 能适当提高资源的利用率(cpu, 内存) 线程上的任务执行完成后，线程会自动销毁 缺点 开启线程需要占用一定的内存空间(默认情况下，每一个线程都占512KB) 如果开启大量的线程，会占用大量的内存空间，降低程序的性能 线程越多，cpu在调用线程上的开销就越大 程序设计更加复杂，比如线程间的通信、多线程的数据共享 iOS 中多线程方案 线程间通信 从子线程回到主线程 比如: 当图片在子线程上异步下载完成后回归到主线程上更新UI 多线程访问共享资源的问题【线程安全】 共享资源 1块资源可能会被多个线程共享，也就是多个线程可能访问同一资源 比如多线程访问同一个对象、同一个变量、同一个文件 问题 当多个线程访问同一资源时，很容易引发数据错乱和数据安全问题 互斥锁 线程同步：一个线程一个线程的执行 使用 @synchronized(锁对象) {需要锁定的代码(有对共享变量或文件的读写操作)} 特点 能有效防止因多线程抢夺资源造成的数据安全(正确)问题 但会影响程序的执行效率，因为在锁住的时候，其他线程在等待，削弱了多线程的作用，所以这个锁锁的代码越少越好 原理 每一个对象(NSObject)内部都有一个锁(变量)，当有线程要进入synchronized到代码块中会先检查对象的锁是打开还是关闭状态，如果锁是打开状态(1), 如果是线程执行到代码块内部 会先上锁(0)。 如果锁被关闭，再有线程要执行代码块就先等待，直到锁打开才可以进入。 线程执行到synchronized i 检查上锁状态 如果是开锁状态(1)转到ii 如果上锁(0)转到v ii 上锁(0) iii 执行代码块 iv 执行完毕 开锁(1) v 线程等待(就绪状态) 加锁后程序执行的效率比不加锁的时候要低，因为线程要等待锁，但是锁保证了多个线程同时操作全局变量的安全性 自旋锁 原子属性 属性的修饰符 nonatomic 非原子属性 atomic 原子属性(线程安全)，针对多线程设计的，默认值 保证同一时间只有一个线程能够写入(但是同一个时间多个线程都可以取值) atomic 本身就有一把锁(自旋锁) nonatomic和atomic对比 atomic：线程安全，需要消耗大量的资源 nonatomic：非线程安全，适合内存小的移动设备 iOS开发建议 所有属性都声明为nonatomic 尽量避免多线程抢夺同一资源 尽量将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力 自旋锁无法解决卖票的问题，因为读写还是分开的 互斥锁和自旋锁的区别 互斥锁 如果发现其他线程正在执行锁定代码，线程会进入休眠(就绪状态)，等其他线程时间片到打开锁后，线程会被唤醒(执行) 自旋锁 如果发现有其他线程正在锁定代码，线程会用死循环的方式，一直等待锁定的代码执行完成，自旋锁更适合执行不耗时的代码 线程安全 线程同时操作是不安全的，多个线程同时操作一个全局变量 线程安全：在多个线程进行读写操作时，仍然能够保证数据的正确 主线程(UI线程)保证线程安全 几乎所有UIKit提供的类都是线程不安全的，所有更新UI的操作都在主线程上执行 所有包含Mutable的类都是线程不安全的 多线程和网络通信的关系 多线程是为了减少卡顿，而卡顿是由于在主线程上执行了耗时任务造成的，将耗时任务另外开子线程线程去执行就会减少卡顿，而网络通信就是耗时任务，所以，在网络通信任务一般都会开子线程执行。 "},"知识库/计算机通用/多线程/NSThread.html":{"url":"知识库/计算机通用/多线程/NSThread.html","title":"NSThread","keywords":"","body":"NSThread 简介 OC语言 使用更加面向对象 简单易用，可直接操作线程对象 线程生命周期程序员管理 线程的状态 新建 就绪 运行 阻塞 死亡 线程的属性和方法 线程名称name 设置线程名称可以当线程执行的方法内部出现异常的时候，记录异常和当前线程 线程优先级threadPriority 线程的优先级，并不能保证谁先执行完 内核调度算法在决定该运行哪个线程时，会把线程的优先级作为考量因素，较高优先级的线程会比较低优先级的线程具有更多的运行机会。较高优先级不保证你的线程具体执行时间，只是相比较低优先级的线程，它更有可能被调度器选择执行而已。 isMainThread 使用方法 // 线程状态之 - 创建 NSThread *thr = [[NSThread alloc] initWithTarget:self selector:@selector(demo) object:nil]; // 线程状态之 - 就绪(进入可调度线程池，CPU会来给它几毫秒的执行时间) [thr start]; "},"知识库/计算机通用/多线程/GCD.html":{"url":"知识库/计算机通用/多线程/GCD.html","title":"GCD","keywords":"","body":"GCD 简介 C语言 旨在替代NSThread等线程技术 充分利用设备的多核 线程生命周期自动管理 什么是 GCD 全称是Grand Central Dispatch 纯C语言，提供了非常多强大的函数 GCD 优势 GCD是苹果公司为多核的并行运算提出的解决方案 GCD会自动利用更多的CPU内核(比如双核、四核) GCD会自动管理线程的生命周期(创建线程、调度任务、销毁线程) 程序员只需告诉GCD想要执行什么任务，不需要编写任何线程管理代码 GCD 两个核心概念 任务 Operation：要执行的耗时操作，比如打开网页、循环等 队列 Queue：用来存放任务 GCD 使用的两个步骤 创建任务：确定要做的事情 将任务添加到队列中，就自动开始执行了 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. GCD中执行任务的2个函数 同步方式执行任务 dispatch_sync(dispatch_queue_t queue, dispatch_block_t block) 同步，在当前线程中执行任务，不开新线程 异步方式执行任务 dispatch_async(dispatch_queue_t queue, dispatch_block_t block) 异步，在新的线程中执行任务，会开新线程(只有开多于1个线程才能异步执行) GCD队列的2大类型 并发队列(Concurrent Dispatch Queue) 作用 可以让多个任务并发(同时)执行(自动开启多个线程同时执行任务) 并发功能只有在异步(dispatch_async)函数下才有效 全局队列 本质就是并发队列 全局队列和并发队列的区别 全局队列一直存在，并发队列任务执行完会销毁 并发队列有名称，可以跟踪错误，全局队列没有 在ARC中不需要考虑释放内存，因为不允许调用dispatch_release(q). 在MRC中需要手动释放内存，并发队列是create创建出来的，在MRC中见到create就要release，全局队列不需要release(只有一个)。 一般使用全局队列 全局队列的参数 第一个: 服务质量(线程的优先级) 第二个: future use 串行队列(Serial Dispatch Queue) 作用 让任务一个接一个执行(一个完成后再执行下一个) 主队列 是个特殊的串行队列 在async函数中【异步执行】 不开线程(特殊之处，与一般串行队列不同)，同步执行 主队列特点: 如果主线程正在执行代码暂时不调度任务，等主线程执行结束后再执行任务 又叫全局串行队列 在sync函数中【同步执行】 程序执行不出来(死锁) 死锁的原因: 当程序执行到下面sync函数这段代码的时候 主队列：如果主线程正在执行代码，就不调度任务 同步执行：如果第一个任务没有执行，就继续等待第一个任务执行完成，再执行下一个任务此时互相等待，程序就无法往下执行(死锁) 注意: 虽然主队列也是串行队列，但它执行异步任务时不开新线程，即做dipatch_async函数的参数时, 只是等主线程当前正在执行的任务结束后再执行主队列的任务 队列 和 同异步执行的组合 sync函数 + 串行队列 特点: 不开新线程(就在当前线程)，队列中任务一个一个按顺序执行 sync函数 + 并行队列 特点: 不开线程(只在当前线程)，队列中任务一个一个按顺序执行(因为只有一个线程，无法异步) async函数 + 串行队列 特点: 新开一个线程，队列中任务一个一个按顺序执行 注意: 虽然主队列也是串行队列，但它执行异步任务时不开新线程，只是等主线程当前正在执行的任务结束后再执行主队列的任务 async函数 + 并行队列 特点: 新开多个线程，无序执行 使用方法 选择一个用来存放任务的合适的队列 使用dispatch_async或dispatch_sync函数将任务block添加到队列并开始执行 GCD会自动将队列中的任务取出，放到对应的线程中执行 任务取出遵循FIFO原则：First in First out. // OC - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // // 创建队列 // dispatch_queue_t queue = dispatch_get_global_queue(0, 0); // // 创建任务 // dispatch_block_t task = ^ { // NSLog(@\"%@\", [NSThread currentThread]); // }; // // 将任务添加到队列 // dispatch_async(queue, task); // 简易用法 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"%@\", [NSThread currentThread]); }); } // Swift // 模拟从网络异步加载视图配置信息 JSON，并存储到 沙盒中 DispatchQueue.global().async { let url = Bundle.main.url(forResource: \"main.json\", withExtension: nil) let data = try! Data(contentsOf: url!) let docPath = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] let docUrl = URL(fileURLWithPath: docPath) let fileURL = docUrl.appendingPathComponent(\"main.json\") print(fileURL.absoluteString) try? data.write(to: fileURL) } 理解方式 当 CPU 开始执行某线程上的代码时: 执行到async函数代码块时，会\"直接跳过\"函数参数Queue中的任务(代码块)[其实是开了另外的线程去执行Queue中的任务]，直接执行后面的代码。 执行到sync函数代码块时，当前线程会等待函数参数Queue中所有任务(代码块)执行完毕，才继续执行后面的代码 而Queue中的所有任务(代码块)，会根据Queue种类不同有不同的执行方式: serial串行执行: 所有任务一个一个按顺序执行 concurrent并发执行: 几个任务同时开始执行，高效率省时间，但是没有顺序 同时使用同步和异步保证任务执行顺序 // 模拟app store购买的过程 // 验证密码 - 扣费 - 下载应用 - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 因为这三个环节都是通过网络，会是耗时操作，所以不能同步执行，不然会导致卡死 // // 这里是异步，所以肯定会开一个线程执行里面这三个添加任务的代码 dispatch_async(dispatch_get_global_queue(0,0), ^{ // 这里是同步(不开新线程)，所以在当前线程按顺序执行(不管什么队列) dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"1. 验证密码: %@\", [NSThread currentThread]); }); // 这里是同步(不开新线程)，所以在当前线程按顺序执行(不管什么队列) dispatch_sync(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"2. 扣费: %@\", [NSThread currentThread]); }); // 这里是异步(开新线程执行，也可能会线程重用)，但是只有这一个任务了，前面两个任务都完成了，所以这最后一个任务无所谓按顺序与否 dispatch_async(dispatch_get_global_queue(0, 0), ^{ NSLog(@\"3. 下载应用: %@\", [NSThread currentThread]); }); }); } barrier阻塞 主要用于在多个异步操作完成后，统一对非线程安全的对象进行更新 适合于大规模的I/O操作 当访问数据库或文件的时候，更新数据的时候不能和其他更新或读取的操作在同一时间执行，可以使用调度组，不过有点复杂。 可以使用dispatch_barrier_async解决 延迟执行 // OC NSLog(@\"三秒后打印我爱你\"); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ NSLog(@\"我爱你\"); }); // Swift // 为了防止还没滚到顶部，就已经开始刷新数据了 DispatchQueue.main.asyncAfter(deadline: .now() + 1) { tvc.loadData() // 刷新新微博后，取消 tabbar 和 APP 红点 self.tabBar.items?[0].badgeValue = nil UIApplication.shared.applicationIconBadgeNumber = 0 } 一次执行 /* 原理是在常量区设置了一个变量，执行一次后设个值，以后每次过来检查如果是这个值就不执行 */ for (int i = 0; i 调度组监听所有任务完成通知 要异步(多个线程)下载三首歌，三首歌全部下载完成后通知用户，就可以使用dispatch_group【但并不能保证下载完成的先后顺序】 // Swift /* 1) loadImage 是 SDWebImage 的核心方法 2) 图像下载完成后，会自动保存在沙盒中，文件路径是 URL 的 md5 3) 如果沙盒中已经存在缓存的图像，后续使用 SD 通过 URL 加载图像，都会加载本地沙盒的图像 4) 不会发起网络请求，同时，回调方法，同样会调用！ 5) 方法还是同样的方法，调用还是同样的调用，不过内部不会再次发起网络请求！ ***注意*** 如果缓存的图像累计很大，要找后台要接口！ */ /// 缓存只有一张图像的微博的图像 /// - Parameter list: 本次下载的视图模型数组 private func cacheSingleImage(list:[JLStatusViewModel], finished: @escaping (_ isSuccess:Bool, _ shouldRefresh:Bool)->()) { // 记录所有单张图片缓存的内存大小 var cacheSize = 0 // 创建调度组 let group = DispatchGroup() // 遍历此次获取的微博数组 list.forEach{(vm) in // 找到只有 1 张图片的，进行下载缓存 if vm.picURLS?.count == 1, let urlStr = vm.picURLS?.first?.thumbnail_pic { // `入组` 将要执行图片下载任务 group.enter() // 用 SD 下载此图片并自动缓存 SDWebImageManager.shared.loadImage(with: URL(string: urlStr), options: [], context: nil, progress: nil) { (image, data, nil, _, _, _) in cacheSize += data?.count ?? 0 // 更新单个图片的尺寸 if let image = image { vm.updateSingleImageSize(with: image) } // `出组` 此图片任务完成， group.leave() } } } // 监听调度组任务完成情况 group.notify(queue: .main) { print(\"此次所有单张图片缓存完毕，大小为: \\(cacheSize / 1024)kb\") // 完成回调 finished(true, true) } } "},"知识库/计算机通用/多线程/NSOperation.html":{"url":"知识库/计算机通用/多线程/NSOperation.html","title":"NSOperation","keywords":"","body":" NSOperation NSOperation VS GCD NSOperation 其实就是要往队列里添加的耗时任务 简介 OC语言 基于GCD(底层是GCD) 比GCD多了一些更简单实用的功能 使用更加面向对象 线程生命周期自动管理 特点 NSOperation是一个抽象类 不能直接使用(方法只有声明没有实现) 用来约束子类都具有共同的属性和方法 NSOperation的子类 NSInvocationOperation 创建NSInvocationOperation对象 调用start方法开始执行操作 默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行，只有将NSOperation放到一个NSOperationQueue中，才会异步执行操作。 NSBlockOperation 创建NSBlockOperation对象 通过addExecutionBlock:方法添加更多操作 只要NSBlockOperation封装的操作数>1，就会异步执行操作 自定义operation 即通过创建NSOperation的子类，可以定制一些功能，需要重写main方法，添加自动释放池等 目的: 封装如 下载图片 这样的耗时操作 自定义Operation，模拟下载图片 创建HMDownloaderOperation类，继承自NSOperation 重写自定义Operation的main方法 重写- (void)main方法，在里面实现想执行的任务 自己创建自动释放池(因为如果是异步操作，无法访问主线程的自动释放池) 经常通过-(BOOL)isCancelled方法检测操作是否被取消，对取消做出响应 在controller中调用start方法，或者添加到队列。main方法会被调用 NSOperationQueue 队列 存放并执行操作的地方 使用步骤 先将需要执行的操作封装到一个 NSOperation 对象中 然后将 NSOperation 对象添加到 NSOperationQueue 中 系统会自动将 NSOperationQueue 中的 NSOperation 取出来执行 将取出来的 NSOperation 封装的操作放到一条新线程中执行 队列中操作的执行的过程 把操作添加到队列[self.queue addOperationWithBlock]; 去线程池取空闲的线程，如果没有就创建新线程 把操作交给从线程池中取出的线程执行 执行完成后，把线程再放回线程池中 重复2,3,4直到所有操作都执行完 线程间通信 从子线程回到主线程 比如: 当图片在子线程上异步下载完成后回归到主线程上更新UI 主队列 添加到主队列的操作，最终都执行在主线程上 当前队列 获取当前操作的队列 [NSOperationQueue currentQueue]; 最大并发数 什么是最大并发数？ 最多同时执行的任务数 比如，同时开3个线程执行3个任务，并发数就是3 最大并发数的相关方法 maxConcurrentOperationCount setMaxtConcurrentOperationCount 队列的暂停、取消、恢复 取消队列的所有操作 cancelAllOperations; 也可以调用NSOperation的cancel方法取消单个操作 暂停和恢复队列 setSuspended // YES代表暂停队列，NO代表恢复队列执行 isSuspended 操作的优先级 和 监听操作完成 不设置优先级的话，可以明显看出开了两个线程切换执行op1和op2 可以设置操作(任务)的优先级(服务质量),但并不能保证高优先级的任务执行过程中，低优先级的任务不执行 op1.qualityOfService = NSQualityOfServiceUserInteractive; 可以设置监听某个任务完成后回调某个方法 [op1 setCompletionBlock:^{ NSLog(@\"-----------------op1 finished--------------\"); }]; 操作依赖 (保证任务执行顺序) NSOperation之间可以设置依赖来保证执行顺序 下载、解压和升级完成分别在不同的线程上执行，用add dependency来确保执行顺序 下载和解压操作在子线程，升级完成在主线程执行，依然可以添加依赖。 NSOperation VS GCD GCD iOS4.0推出，主要针对多核cpu做了优化，是C语言的技术 GCD是将任务(block)添加到队列(串行/并行/全局/主队列)，并且以同步/异步的方式执行任务的函数 GCD提供了一些NSOperation不具备的功能 一次性执行 延迟执行 调度组 NSOperation NSOperation是iOS2.0推出的，iOS4之后重写了NSOperation 将操作NSOperation(异步的任务)添加到队列(并发队列)，就会执行 NSOperation中提供的方便的操作 最大并发数 队列的暂定/继续(暂停的是没有执行的任务) 取消所有的操作 执行操作之间的依赖关系(GCD中用同步就可以实现) "},"知识库/计算机通用/多线程/Runloop 消息循环.html":{"url":"知识库/计算机通用/多线程/Runloop 消息循环.html","title":"Runloop 消息循环","keywords":"","body":"Runloop 消息循环 简介 消息循环属于线程，主线程的消息循环默认开启着，里面在等待着屏幕上的用户输入事件。 相当于给当前的代码这里插入一个while死循环而已，然后while里面可以运行代码。while循环体内的代码运行在当前线程的消息循环上，而外面的代码运行在当前线程上(非消息循环上)。 作用 保证程序不退出 接收和处理用户的事件【主线程的消息循环(while死循环)在程序加载完毕就一直在等待处理用户的输入事件】 原理 就是一个死循环 在每次循环中，一直卡在等待用户输入信息的位置(用户触摸屏幕) 当用户点击屏幕(产生事件)，就会有相应的处理事件的方法被调用 这个方法执行完毕后，这次消息循环完毕，又重新开始下一次消息循环 注意【消息循环模式会变化】 注意： 因为runloop在不同的情况下有不同的模式，比如当屏幕上的scrollView被拖动时，主线程的runloop就会由defaultMode模式变为UITrackingRunLoopMode，但是这两个模式都属于commonModes。如果timer源被添加在runloop的defaultMode，那它的方法在trackingMode就不会被执行，所以可以将它添加在runloop的commonModes来解决问题。 自动释放池 存在意义 / 作用 如果一个循环创建了大量的临时对象 你可以在循环内部使用自动释放池在下次循环开始前处理掉那些对象。这样可以减少程序的最大内存使用量。 如果你创建了一个子线程。 你必须在子线程开始执行前立即创建自动释放池，否则你的程序会发生内存泄漏。 自动释放池 标记为autorelease的对象，会被添加到最近一次创建的自动释放池中 当自动释放池被销毁或耗尽时，会向自动释放池中的所有对象发送release消息 自动释放池是什么时候创建的？又是什么时候销毁的？ 每一次主线程的消息循环开始的时候会先创建自动释放池 消息循环结束前，会释放自动释放池 自动释放池被销毁或耗尽时会向池中所有对象发送release消息，释放所有autorelease的对象 使用NSThread做多线程开发时，需要在线程调度方法中手动添加自动释放池 "},"知识库/计算机通用/数据读取解析存储/数据读取、解析.html":{"url":"知识库/计算机通用/数据读取解析存储/数据读取、解析.html","title":"数据读取解析存储","keywords":"","body":" 数据读取、解析 基本数据类型的读取和存储 读取 存储 对象的存储和读取 归解档 [旧OC] 归解档[新 Swift] 注意： 数据读取、解析 基本数据类型的读取和存储 读取 文件位置 -> 数组 、字典、字符串 到数组 [NSArray arrayWithContentsOfURL:] [NSArray arrayWithContentsOfFile:] 到字典 [NSDictionary dictionaryWithContentsOfURL:] [NSDictionary dictionaryWithContentsOfFile: ] 到 字符串 [[NSString alloc] initWithData] 文件位置 -> data -> 数组、字典 文件位置 -> data [NSData dataWithContentsOfURL] [NSData dataWithContentsOfFile] data -> 数组 或 字典 json data 解析成 JSONObject, 即 数组 或 字典 NSArray *array = [NSJSONSerialization JSONObjectWithData: data]; NSDictionary *dict = [NSJSONSerialization JSONObjectWithData: data]; pList data 解析成 数组 或 字典 NSArray *array = [NSPropertyListSerialization propertyListWithData: data] NSDictionary *dict = [NSPropertyListSerialization propertyListWithData: data] 存储 直接写入文件 字典 写到 文件 [dict writeToURL]; [dict writeToFile]; 数组 写到 文件 [arr writeToURL]; [arr writeToFile]; 转为 data 后再 写入文件 注: 不管是 基本数据类型 还是 对象 ，都要先存到 字典 或 数组 中，最后再写入文件存到某个位置 转为 json data 字典[基本数据类型] NSData *data = [NSJSONSerialization dataWithJSONObject: dict]; 数组[基本类型数据] NSData *data = [NSJSONSerialization dataWithJSONObject: arr]; 转为 pList data NSData *data = [NSPropertyListSerialization dataWithPropertyList: dict] NSData *data = [NSPropertyListSerialization dataWithPropertyList: arr] 字符串 转为 data NSData *data = [str dataUsingEncoding:NSUTF8StringEncoding] 将 data 写到文件 [data writeToURL]; [data writeToFile]; 对象的存储和读取 注: 不管是 基本数据类型 还是 对象 ，都要先存到 字典 或 数组 中，最后再写入文件存到某个位置 原理: 先将 自定义对象 转为 数据字典，再进行后续操作 归解档 [旧OC] 自定义对象类遵守 NSCoding 协议，实现两个可以将 对象 和 字典 互转的归解档方法，再用 NSKeyedArchiver 来和 data 互转 存储 【对象 -> data】 使对象类遵守NSCoding协议，实现如下将对象转化为数据字典 aCoder 的方法， encodeWithCoder:(NSCoder*)aCoder 直接归档写入文件并存储到位置 [NSKeyedArchiver archiveRootObject: toFile:] 或 自定义对象 -> data -> 写到文件并存储 将 自定义对象 或 自定义对象数组 归档 为 data NSData *data = [NSKeyedArchiver archivedDataWithRootObject:arr] 将 data 写入文件存储到相应位置 [data writeToURL]; [data writeToFile]; 读取 【data -> 对象】 使对象类遵守NSCoding协议，实现如下将数据字典aDecoder 转为 对象 的方法 initWithCoder:(NSCoder *)aDecoder 直接从存储位置解档成 元素为自定义对象的 数组或字典 NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithFile:] 或 存储位置 -> data -> 自定义对象数组或字典 用 存储位置 创建 data NSData data = [NSData dataWithContentsOfURL]; NSData data = [NSData dataWithContentsOfFile]; 用 data 解档生成 元素为自定义对象的 数组或字典 NSArray *array = [NSKeyedUnarchiver unarchiveObjectWithData:data]; NSDictionary *dict = [NSKeyedUnarchiver unarchiveObjectWithData:data]; 归解档[新 Swift] 原理和 OC 旧方法一样，只不过协议换成了 Codable，一般情况下只要层层遵守Codable协议就可以成功归档解档了，如果不行，或者需要自定义归解档的属性，就实现下面两个方法。 类对象只要可以归解档了，也就可以用 JSONEncoder 和 JSONDecoder 操作了？ /// 此 对象 对应的 数据字典 的 `键` enum CodingKeys:String, CodingKey { case word case chinesesString = \"chineses\" case meaningsArray = \"meanings\" case dateCreated = \"creation_date\" case dateModified = \"modification_date\" case frequency } /// 解档方法 /// 将 数据字典 解档为 自定义对象 /// - Parameter decoder: 数据字典 required init(from decoder: Decoder) throws { super.init() let values = try decoder.container(keyedBy: CodingKeys.self) word = try values.decode(String.self, forKey: .word) meaningsArray = try values.decode([Meaning].self, forKey: .meaningsArray) dateCreated = try values.decode(Date.self, forKey: .dateCreated) dateModified = try values.decode(Date.self, forKey: .dateModified) frequency = try values.decode(Int.self, forKey: .frequency) } /// 归档方法 /// 将 自定义对象 归档为 数据字典 /// - Parameter encoder: 数据字典 func encode(to encoder: Encoder) throws { var container = encoder.container(keyedBy: CodingKeys.self) try container.encode(word, forKey: .word) try container.encode(chinesesString, forKey: .chinesesString) try container.encode(meaningsArray, forKey: .meaningsArray) try container.encode(dateCreated, forKey: .dateCreated) try container.encode(dateModified, forKey: .dateModified) try container.encode(frequency, forKey: .frequency) } 注意： [String : Any] 或 [Any]， 在将包含 Any 类型的数组或字典使用JSONEncoder转换为 JSON 二进制 Data 时，会报错，可使用如下方法： let data = try? JSONSerialization.data(withJSONObject: arr, options: [.prettyPrinted]) let url = URL.init(fileURLWithPath: \"/Users/joyawang/Desktop/demo.json\") try? data?.write(to: url) 如果数据是自定义对象(数据模型)，将对象转换为键值对为基本数据类型的字典，再将字典存入数组中 原理： 对象 -> 字典 -> 数组[字典] -> Data obj -> dict = [obj dictionaryWithValuesForKeys] -> [dict] -> Data "},"知识库/计算机通用/数据读取解析存储/数据存储.html":{"url":"知识库/计算机通用/数据读取解析存储/数据存储.html","title":"数据存储","keywords":"","body":" 数据存储: 将二进制数据Data存储到不同的位置 本地存储 网络存储 数据存储: 将二进制数据Data存储到不同的位置 可存储的位置介绍 存到本地磁盘 存储在本机磁盘的一个特定目录下，Sandbox 沙盒 (可在 Files 文件 App 中本机显示) 存到系统提供的用来存储用户偏好的文件，UserDefaults 用户偏好 存到 钥匙串，用 第三方框架 SAMKeyChain 存到自己生成的二进制数据文件，再写入到沙盒的 document 目录 存到本地数据库文件(本质是生成数据库文件，算法进行管理)，再存到沙盒的 document 目录 FMDB (SQLite) CoreData 【SkillKit】 Realm Firebase 存到网络服务器磁盘 iCloud 本地存储 沙盒目录简介及获取方法 Documents 简介 保存应用产生的文件或数据，如游戏进度、涂鸦软件的绘图 目录中的文件会自动保存到iCloud上？ 不哟啊保存从网络上下载的文件 iTunes会备份 路径获取方法 // OC NSHomeDirectory NSString *document = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; // Swift let docURL = try! FileManager.default.url(for: .documentDirectory, in: .userDomainMask, appropriateFor: nil, create: true) Library / Cache 简介 保存临时文件，后续需要使用。如缓存图片、离线地图数据 系统不会自动清理此目录？ 程序员需提供清理此目录的功能？ iTunes不会备份 路径获取 - (instancetype)cachePath { // 获取当前path中文件的名字 NSString *fileName = [self lastPathComponent]; // 获取沙盒中document文件夹的路径 NSString *cache = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject]; // 拼接成当前文件在沙盒cache文件夹的路径 return [cache stringByAppendingPathComponent:fileName]; } Library / Preference 简介 用户偏好，存储用户的一些偏好操作 iTunes会备份 路径获取 UserDefaults ??? 存: [[NSUserDefaults standardUserDefaults] setValue: forKey:]; 取: [[NSUserDefaults standardUserDefaults] valueForKey:]; temp 简介 保存临时文件，后续不需要使用 tmp目录中的文件，系统会自动清理 系统磁盘空间不足，会自动清理 系统重启，会清理该文件 iTunes不备份 路径获取 // OC - (instancetype)tempPath { return [NSTemporaryDirectory() stringByAppendingPathComponent:[self lastPathComponent]]; } 沙盒文件在 Files App 中本机显示 如果往本地SandBox的Documents存了文件，但是在Files中不显示，不可见，那么在info.plist中添加如下两个key UIFileSharingEnabled LSSupportsOpeningDocumentsInPlace 网络存储 iCloud 目录获取 须判断，为空则没有登录苹果账户或没打开iCloud // iCloud入口文件夹URL FileManager.default.url(forUbiquityContainerIdentifier: nil) // iCloud中Documents文件夹URL: FileManager.default.url(forUbiquityContainerIdentifier: nil)?.appendingPathComponent(\"Documents\") 在 Files 文件 App 中 iCloud 显示 如果往iCloud的Documents存了文件，但是在Files中不显示，不可见，那么在info.plist中添加如下key NSUbiquitousContainers ​ iCloud.com.Joya-Wang.VocKit ​ ​ NSUbiquitousContainerIsDocumentScopePublic ​ ​ NSUbiquitousContainerName ​ VocKit ​ NSUbiquitousContainerSupportedFolderLevels ​ Any ​ 如果添加了上面的key后在Files中依然无法看见自己的app文件夹，改变下面的CFBundleVersion也就是内建版本号buildVersionNumber。（CFBundleShortVersionString是发布版本号releaseVersionNumber) CFBundleVersion ​ 1 CloudKit Container CloudKit 开启 default container: 以当前项目 bundle id 命名 四级目录 Container【VocKit Container】 Database 【PrivateDatabase】 Private 属于当前手机icloud账户的DB，该账户登录期间，数据提交到该DB里，且只有在该账户登录时，才能取到相关记录。切换icloud账户将无法获取到。 Shared 所有人都可以访问，但只限于同bundleID的 app。（由于container 的bundle ID限制） Public IOS10新推出的，用 CKShare 创建的记录，设定一定的权限 即可被遵守相同规则的 app访问到。 Zones 【Vocabularies】【Meanings】 Records 【Vocabulary】【Meaning】 使用 //获取container，可以用ID来指定 自定义的container，也可以使用默认的。 CKContainer *myContainer = [CKContainer defaultContainer]; //获取container里的 db。这里用的是public DB CKDatabase *publicDatabase = [myContainer publicCloudDatabase]; //recordID， name必须在这个DB里是唯一的。 CKRecordID *artworkRecordID = [[CKRecordID alloc] initWithRecordName:@\"119\"]; //创建一条新的record。recordType 类似于DB的表名。 CKRecord *artworkRecord = [[CKRecord alloc] initWithRecordType:@\"Artwork\" recordID:artworkRecordID]; //record的 这种key-value 存储方式；value支持的数据类型参考 CKRecord.h 的CKRecordValue协议 artworkRecord[@\"name\"] = @\"testName\"; //新建/更改记录 CKModifyRecordsOperation *modifyRecords= [[CKModifyRecordsOperation alloc] initWithRecordsToSave:@[artworkRecord] recordIDsToDelete:nil]; modifyRecords.savePolicy=CKRecordSaveAllKeys; modifyRecords.qualityOfService=NSQualityOfServiceUserInitiated; modifyRecords.modifyRecordsCompletionBlock= ^(NSArray * savedRecords, NSArray * deletedRecordIDs, NSError * operationError){ // the completion block code here NSLog(@\"\"); }; //获取记录 [publicDatabase fetchRecordWithID:artworkRecordID completionHandler:^(CKRecord * _Nullable record, NSError * _Nullable error) { NSLog(@\"\"); }]; "},"知识库/计算机通用/数据读取解析存储/NSFileManager 文件管理器.html":{"url":"知识库/计算机通用/数据读取解析存储/NSFileManager 文件管理器.html","title":"NSFileManager 文件管理器","keywords":"","body":"NSFileManager 文件管理器 【像Finder一样管理文件】 初始化 [NSFileManager defaultManager] 判断 判断指定文件或文件夹是否存在 fileExistsAtPath 判断指定文件夹是否可读取 isReadableFileAtPath 判断指定文件夹或文件是否可写入 isWriteableFileAtPath 判断指定文件夹或文件是否可删除 isDeleteableFileAtPath 获取信息 获取指定文件夹或文件的属性信息 attributesOfItemAtPath 获取指定路径下的所有文件和目录，所有子目录和文件 subpathsAtPath 获取指定路径的所有子目录和文件，不包括孙子辈 contentsOfDirectoryAtPath 文件 / 文件夹操作 在指定目录创建文件 createFileAtPath 在指定目录创建文件夹 createDirectoryAtPath 拷贝文件 copyItemAtPath toPath 移动文件(剪切文件，可用来重命名) moveItemAtPath toPath 删除文件(不倒废纸篓，直接删除，谨慎使用) removeItemAtPath "},"知识库/计算机通用/数据读取解析存储/CoreData_SQLite.html":{"url":"知识库/计算机通用/数据读取解析存储/CoreData_SQLite.html","title":"CoreData_SQLite","keywords":"","body":" CoreData 创建数据库和数据表 数据操作 CoreData SQLite 概念简介 表 一张表 table 用来存储一类对象，表的 column / 字段 / 属性 就是对象的属性 Person 表就存储 Person 类的所有对象 Teacher 表就存储所有 Teacher 类的对象 db 一个数据库 database，可存很多不同的表，即可以存储不同类的对象 Person 表和 Teacher 表 都存在 froshims.db 数据库中 CoreData 简介 存储数据，也就是要把一个个 OC 对象，比如 Student 对象，存储到数据库中 那么需要在数据库中创建一个存储这个对象类型的表，在 FMDB 中，通过语句创建，而在 CoreData 中，通过视图界面创建 Entity，每个 Entity 对应一张表，Entity 的 attributes 对应对象的属性。 创建了一个 Entity，如 Teacher以后，默认创建了这样一个 OC 类，虽然看不见，但你可以直接使用 Teacher 这个类创建对象，也可以在 Entity 的 Codegen 里面更改，将 Entity 的属性以 Extension 的形式添加给你自己后面手动创建的 Teacher 类。 CoreData 不能执行 SQL 语句，取而代之，操作的是对象，FMDB SQLite 可以直接 SQL 语句 Core Data iOS5之后才出现的一个框架 如果创建项目时选择 Use Core Data add some code to AppDelegate Create a .xcdatamodeld file 【Data Model】就像 数据库的 Storyboard Entities (which are like a class) Attributes (which is like a var) Relationships (a var that points to other Entities) 创建数据库和数据表 【创建数据库】 在创建项目的时候选择使用 CoreData，就会在 App Delegate 中创建 Container，也就是数据库，也可以自己参照这个代码创建 【创建数据表】打开 .xcdatamodeld 文件 增加 Entity 创建 Entity，也就是创建要在数据库中存储的 类，比如 Tweet 比如 Tweet、TweetUser 为 Entity，添加 attributes，也就是为 类 添加 属性/字段 比如，为 Tweet Entity 添加如下属性 created Date类型 identifier String 类型 text String类型 创建 relationShip 在此 Entity 的 Codegen 的地方选择要自动生成和此 Entity 对应的 OC 类，比如 Tweet，或者生成那个类的 Extension 如果选择了自动生成对应的 Tweet 类，则无法再手动创建 Tweet 类并方便的添加方法，所以建议自动生成 Tweet 的 Extension，Tweet 类自己手动创建 不管这两个选择哪一个，最后在创建对象的时候 Tweet 对象就自动拥有了 entity 中设置的属性 数据操作 获取 NSPersistentContainer 和 viewContext let persistentContainer = (UIApplication.shared.delegate as! AppDelegate).persistentContainer let context:NSManagedObjectContext = persistentContainer.viewContext 数据库操作 增 // 最基本的存储一条数据到 Coredata 的方式 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 创建 Entity // 必须先创建 Tweet 类，继承自 NSManagedObject，可在 Entity 那里用 Codegen 生成 // 通过实体描述，描述出实体对象【连接Coredata的 Tweet Entity 和 Swift 的 Tweet 类？】 let tweet:Tweet = NSEntityDescription.insertNewObject(forEntityName: \"Tweet\", into: context) tweet.text = \"我的第一条推文\" // 设置对象属性 // 3. 保存Entity到数据库【上面的更改只在内存中，除非保存起来】 try? context.save() ```swift // ** 方便的存储一条数据到 Coredata 的方式 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 创建 Entity，并设置属性 let tweet = Tweet(context: context) tweet.text = \"我的第一条推文\" tweet.date = Date() // 3. 保存 Entity 到数据库 try? context.save() ``` 删 // 1. 获取 viewContext let context = persistentContainer.viewContext // 2. 删除 context.delete(tweet) 改 查 // 1. 创建 request 【获取哪类对象】 let request:NSFetchRequest = Tweet.fetchRequest() // 2.设置 request 的条件【可省略?】 // 2.1 设置查询条件 let searchString = \"foo\" let predicate = NSPredicate(format: \"text contains[c] %@\", searchString) // 2.2 设置结果排序方式 let sortDescriptor = NSSortDescriptor( key:\"screenName\", ascending: true, // 根据 screenName，升序 selector: #selector(NSString.localizedStandardCompare(_:)) // can skip this ) // 2.3 将条件设置给 request request.predicate = predicate request.sortDescriptors = [sortDescriptor] // 3. 获取结果 let thetweets = try? context.fetch(request) "},"知识库/计算机通用/数据读取解析存储/FMDB_SQLite.html":{"url":"知识库/计算机通用/数据读取解析存储/FMDB_SQLite.html","title":"FMDB_SQLite","keywords":"","body":" FMDB SQLite 使用方法 FMDB SQLite 详见 JL微博、数据存储-FMDB SQLite 概念简介 表 一张表 table 用来存储一类对象，表的 column / 字段 / 属性 就是对象的属性 Person 表就存储 Person 类的所有对象 Teacher 表就存储所有 Teacher 类的对象 db 一个数据库 database，可存很多不同的表，即可以存储不同类的对象 Person 表和 Teacher 表 都存在 froshims.db 数据库中 FMDB 和 CoreData 异同 存储数据，也就是要把一个个 OC 对象，比如 Student 对象，存储到数据库中 那么需要在数据库中创建一个存储这个对象类型的表，在 FMDB 中，通过语句创建，而在 CoreData 中，通过视图界面创建 Entity，每个 Entity 对应一张表，Entity 的 attributes 对应对象的属性。 创建了一个 Entity，如 Teacher以后，默认创建了这样一个 OC 类，虽然看不见，但你可以直接使用 Teacher 这个类创建对象，也可以在 Entity 的 Codegen 里面更改，将 Entity 的属性以 Extension 的形式添加给你自己后面手动创建的 Teacher 类。 CoreData 不能执行 SQL 语句，取而代之，操作的是对象，FMDB SQLite 可以直接 SQL 语句 简介 什么是FMDB？ 一个iOS中SQLite API的封装库 1.是对libsqlite3库的封装，使用起来简洁、高效，没有原来的一大堆晦涩难懂、影响开发效率的C语句，更加面向对象 2.非常的轻量化、灵活 3.对于多线程的并发操作进行了处理，是线程安全的（重要特性之一） 4.因为它是OC语言封装的，只能在ios开发的时候使用，所以在实现跨平台操作的时候存在局限性 iOS FMDB数据库详解教程 FMDB Github地址 大写只是为了区分代码命令和用户信息 iOS 中 ? 代表预编译指令的占位符 安装和导入 安装 cd到项目目录 pod init vim Podfile并添加pod 'FMDB' pod install 导入libsqlite3框架 import 使用方法 创建数据库 创建 froshims.db 数据库 终端 sqlite3 froshims.db 数据库文件默认存储位置为当前用户的家目录 // MARK: 创建数据库 /// 创建数据库 - (void) createDatabase { // 1. 获取数据库文件的路径 _docPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject]; NSLog(@\"%@\", _docPath); // 设置数据库名称 NSString *filename = [_docPath stringByAppendingPathComponent:@\"student.sqlite\"]; // 2. 创建数据库 _db = [FMDatabase databaseWithPath:filename]; if ([_db open]) { NSLog(@\"打开数据库成功\"); } else { NSLog(@\"打开数据库失败\"); } } 创建数据表 创建一个名为 registrants，3 个 column (列)，分别为 id，name，dorm 的数据表 终端 CREATE TABLE 'registrants' ('id' integer, 'name' varchar(255), 'dorm' varchar(255)); // MARK: 创建表 /// 创建表 - (void) createTable { BOOL result = [_db executeUpdate:@\"CREATE TABLE IF NOT EXISTS t_student (id integer PRIMARY KEY AUTOINCREMENT, name text NOT NULL, age integer NOT NULL, sex text NOT NULL);\"]; if (result) { NSLog(@\"创建表成功\"); } else { NSLog(@\"创建表失败\"); } } 【增】新增数据 向 registrants 表添加一条数据， id, name, dorm column 中的值分别填1, 'Brian', 'Pennypacker' 终端 INSERT INTO registrants (id, name, dorm) VALUES(1, 'Brian', 'Pennypacker'); // MARK: - 增 // 插入数据 - (void) addStudent { // 插入数据 NSString *name = [NSString stringWithFormat:@\"王子涵%@\", @(mark_student)]; int age = mark_student; NSString *sex = @\"男\"; mark_student ++; // 1. executaUpdate: ?为占位符 (后面参数必须是OC对象，; 代表语句结束) BOOL result = [_db executeUpdate:@\"INSERT INTO t_student (name, age, sex) VALUES (?,?,?)\", name, @(age), sex]; //2.executeUpdateWithForamat：不确定的参数用%@，%d等来占位 （参数为原始数据类型，执行语句不区分大小写） // BOOL result = [_db executeUpdateWithFormat:@\"insert into t_student (name,age, sex) values (%@,%i,%@)\",name,age,sex]; //3.参数是数组的使用方式 // BOOL result = [_db executeUpdate:@\"INSERT INTO t_student(name,age,sex) VALUES (?,?,?);\" withArgumentsInArray:@[name,@(age),sex]]; if (result) { NSLog(@\"插入成功\"); } else { NSLog(@\"插入失败\"); } } 【删】删除数据 删除 id 为 1 的那一行数据 终端 DELETE FROM registrants WHERE id = 1; // 删除数据 - (void)deleteStudent { // 1. 占位符用? (后面参数必须是OC对象)，需要将int包装成OC对象) int idNum = 11; // BOOL result = [_db executeUpdate:@\"delete from t_student where id = ?\", @(idNum)]; // 占位符用%@，%d等 BOOL result = [_db executeUpdateWithFormat:@\"delete from t_student where name = %@\", @\"王子涵0\"]; if (result) { NSLog(@\"删除成功\"); } else { NSLog(@\"删除失败\"); } } // 删除表 - (void) deleteTable { // 如果表格存在 则销毁 BOOL result = [_db executeUpdate:@\"drop table if exists t_student\"]; if (result) { NSLog(@\"删除表成功\"); } else { NSLog(@\"删除表失败\"); } } 【改】修改 / 更新 数据 更新 registrants 表，将 id 为 1 的那一行的 dorm 改为 Canaday 终端 UPDATE registrants SET dorm = 'Canaday' WHERE id = 1; // MARK: - 改 // 修改数据 - (void) modifyStudent { // 修改学生名字 NSString *newname = @\"李浩宇\"; NSString *oldname = @\"王子涵2\"; BOOL result = [_db executeUpdateWithFormat:@\"update t_student set name = %@ where name = %@\", newname, oldname]; if (result) { NSLog(@\"修改成功\"); } else { NSLog(@\"修改失败\"); } } 【查】读取数据 读取所有数据 选择显示 registrants 这个表中的所有数据 终端 SELECT * FROM registrants; 按条件读取数据 选择显示 registrants 这个表中 dorm 是 China 的所有数据 SELECT * FROM registrants WHERE dorm = 'China'; 选择显示 registrants 这个表中 dorm 为 Africa 的所有数据的 name SELECT name FROM registrants WHERE dorm = 'Africa'; // MARK: - 查 // 查询 - (void) search { // 查询整个表 // FMResultSet *resultSet = [_db executeQuery:@\"select * from t_student\"]; // 根据条件查询 FMResultSet *resultSet = [_db executeQuery:@\"select * from t_student where id "},"知识库/计算机通用/数据读取解析存储/XML 的 存储 和 解析.html":{"url":"知识库/计算机通用/数据读取解析存储/XML 的 存储 和 解析.html","title":"XML 的 存储 和 解析","keywords":"","body":"XML 的 存储 和 解析 数据数组和字典与 XML Data互转 SAX的方式解析: 简介 SAX: simple API for XML 特点: iOS上解析，速度快，内存占用小，只读 SAX的解析步骤:【具体见网络通信的Day02】 加载xml数据【获取网络中的xml data】 创建NSXMLParser对象parser 设置parser的delegate 在NSXMLParserDelegate协议方法中解析XML data a. 开始解析XML文档【didStartDocument】 b. 找开始节点(包括节点的属性)【didStartElement】 c. 找节点之间的内容【foundCharacters】 d. 找结束节点【didEndElement】 e. 完成XML文档解析【parserDidEndDocument】 注意 使用KVC为对象属性赋值注意: KVC赋值的过程就是将value的地址赋值给key，即对象的属性指针指向value，所以在从网络中获取数据转模型时，模型类的属性最好设置为copy，这样在赋值的时候会复制一份value，把新value的地址赋值给key。在setValue过程中不会做类型转换，直接把value地址赋值给属性指针。这也是为什么NSNumber类型的属性，用string类型的value也可以赋值的原因。 DOM 的方式解析 简介 DOM : Document Object Model 文档对象模型(文档树模型) 把整个xml文件当成文档对象来处理，所有信息都在这个文档对象中。 特点: mac上的解析方式，iOS无法直接使用，解析过程中内存占用大，读写 一次性把xml全部加载到内存，内存消耗大 之前的SAX方式只能读取XML，DOM可以修改，添加、删除、修改节点 iOS默认不支持DOM解析(不支持NSXML这个类) 在iOS解析DOM需要使用第三方框架 GData/KissXML(XMPP中使用此框架) 适合读写比较小的XML文件 GData 解析的步骤【详见网络通信Day03，DOM解析】 将GDataXMLNode.h和m拖进项目 在build setting中搜索'Header Search Paths'，添加/usr/include/libxml2 在build setting中搜索'Other Linker Flags'，添加-lxml2 获取xml data 使用data创建document(GDataXMLDocument)对象 获取根元素(节点)document.rootElement rootElement的所有children就是一个个video对象，遍历并video对象 rootElement每个child是一个video对象，child的children是video的子标签(就是video的属性)，使用KVC赋值 rootElement每个child是一个video对象，child的attributes是video的属性(就是video的属性)，使用KVC赋值 "},"知识库/计算机通用/数据读取解析存储/NSCache 缓存.html":{"url":"知识库/计算机通用/数据读取解析存储/NSCache 缓存.html","title":"NSCache 缓存","keywords":"","body":"NSCache 缓存 - (NSCache *)cache { if(!_cache) { _cache = [[NSCache alloc] init]; _cache.countLimit = 5; _cache.delegate = self; } return _cache; } - (void)cache:(NSCache *)cache willEvictObject:(id)obj { NSLog(@\"从缓存中移除%@\", obj); } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { // 往缓存中存储数据 for (int i = 1; i "},"知识库/计算机通用/编程语言学习/编程语言学习.html":{"url":"知识库/计算机通用/编程语言学习/编程语言学习.html","title":"编程语言学习","keywords":"","body":" 编程语言学习 基础语法 数据处理 内存中如何存储数据 基本数据类型 字符串 集合类型 变量和常量 可选项 表达式 流程控制 循环控制 高级? 函数 / 方法 指针 函数指针 / Block / Closure 结构体 枚举 面向对象 内存管理 数据类型与变量 可用来声明变量的数据类型: 数据类型与变量的使用 文件权限控制 编程语言学习 基础语法 数据处理 内存中如何存储数据 基本数据类型 字符串 集合类型 数组 字典 集合 变量和常量 声明 初始化 / 赋值 值输出 作用域 可选项 表达式 算术运算符和算术表达式 复合赋值运算符、自增自减运算、逗号表达式、比较表达式、三元表达式 流程控制 逻辑运算符及其优先级 if 结构 循环控制 switch-case 语法 while 循环 do-while 循环 break, continue, goto 关键字 for 循环 高级? 函数 / 方法 意义 函数声明 函数实现 函数调用 参数 参数的本质 形参 实参 返回值 执行步骤 不同数据类型作为函数参数和返回值时的传值方式 基本数据类型(int, char, float, double) 数组 结构体【个人创建的数据类型】 指针【存储变量所在的内存空间的地址】 函数指针 结构体指针 指针 变量的值和地址 指针类型变量的声明、初始化和使用 野指针、NULL 指针类型与函数 函数指针 / Block / Closure 声明变量 与函数 做函数的参数 做函数的返回值 初始化 / 赋值 调用 结构体 结构体概述 用结构体创建新数据类型 结构体存在的意义 新数据类型(使用结构体创建)的变量的初始化、默认值 新数据类型(使用结构体创建)之间的相互赋值 新数据类型(使用结构体创建)与数组 新数据类型(使用结构体创建)与指针 新数据类型(使用结构体创建)嵌套 新数据类型(使用结构体创建)与函数 typedef 定义新数据类型 枚举 面向对象 类 成员属性 方法 对象 对象的创建 对象的使用 对象的存储 对象的消息机制 构造和析构函数 构造函数 (创建对象的方法) 重载构造函数 (initWith) 重写构造函数 (override) KVC 构造函数 (用dict创建对象) 便利构造函数 (条件判断是否创建对象) 析构函数 封装 将相同功能的代码抽取并封装为方法、对象等 继承 子类继承父类的属性和方法 多态 同一方法名，不同具体实现 内存管理 数据类型与变量 任何数据类型都会用来与变量打交道 可用来声明变量的数据类型: 基本数据类型和基本数据类型组合的新数据类型 int, char, float, double pointer newDataType(使用结构体 struct 和 typedef 创建的、使用 enum 和 typedef 创建的) array, dictionary 数据类型与变量的使用 变量的声明 比如声明int类型的变量、指针类型的变量、struct Person 类型的变量 变量的默认值、初始化 / 赋值 变量与容器(数组、字典) 变量与指针 变量与函数 文件权限控制 "},"知识库/计算机通用/编程语言学习/Shell/Shell自动交互.html":{"url":"知识库/计算机通用/编程语言学习/Shell/Shell自动交互.html","title":"Shell自动交互","keywords":"","body":"Shell自动交互 一、背景 shell脚本在处理自动循环或大的任务方面可节省大量的时间，通过创建一个处理任务的命令清单，使用变量、条件、算术和循环等方法快速创建脚本以完成相应工作，这比在命令行下一个个敲入命令要省时省力得多。 但是有时候我们可能会需要实现和交互程序如ftp,telnet服务器等进行交互的功能，这时候我们需要用到shell的自动交互功能，本文收集了较常用的三种自动交互方法，并进行了比较和总结。 二、需求 需求1： 从一台linux机器ftp登陆到另一台linux机器，进行系列操作后关闭，懒得每次都手动输入密码。 需求2： 改变登录用户密码，懒得每次都输入新旧密码。 需求3： 希望su自动登录到root账户，懒得每次都输入root密码。 三、调试环境 终端：SecureCRT 系统：WinXP, CentOS 4.4(VmWare) Shell:bash 注：shell有很多种，B类SHELL（sh, bash, ksh）之间行为相近；C类SHELL（csh, tcsh）之间行为相近，还有zsh和rc等shell，本文的调试环境是bash。 四、自动交互方法一 自动交互最关键的就是交互信息的自动输入，首先联想到文件重定向，在shell编程中有这样一种用法(参考LINUX与UNIX SHELL编程指南 chapt 5.7)：\"command 重定向操作符command 对于需求1 要求的自动登陆ftp，并作系列操作，则可以用这种方法进行自动交互。代码如下： ;) #!/bin/bash ftp -i -n 192.168.167.187 ;) 测试可以发现，如上代码使用帐号名hzc，密码123456成功登陆了ftp服务器，并进入目录，打印出了pwd。 五、自动交互方法二 需求2中要求采用非交互的方式改变登录用户密码，尝试用方法1，无法实现。 这时候联想到交互信息的另一个自动输入方法，管道，通过echo + sleep + | 可以实现这个需求。 ;) #!/bin/bash (echo \"curpassword\" sleep 1 echo \"newpassword\" sleep 1 echo \"newpassword\")|passwd ;) 测试通过，运行这个脚本，直接把当前用户的curpassword改成newpassword。 六、自动交互方法三 需求3中要求自动登录root账号，尝试方法1和方法2，都出现错误提示standard in must be a tty。 这时候尝试寻找外部帮助，一个shell工具expect可以实现这个功能，其实expect就是一个专门用来实现自动交互功能的工具，expect的语法可以参考相关资料，代码如下： #!/usr/bin/expect spawn su root expect \"password: \" send \"123456\\r\" expect eof exit 测试通过，运行这个脚本，直接从当前用户登录到root用户。 七、方法总结 方法一(重定向)简单直观，也经常有实际应用，但是在自动交互领域功能有限。 方法二(管道)也很简单直观，有时甚至不用sleep配合就能展现强大的自动交互实力，但是在某些时候也束手无策。 方法三(expect)在功能上是最为强大的，expect本来就是为实现自动交互功能而生，但是缺点是需要安装expect包，在嵌入式等环境下难以安装。 三个方法各有优劣，应用的好，都可以让实际工作中的很多琐事一劳永逸。(完) 转自http://blog.sina.com.cn/s/blog_62bbc49c0100fs0i.html 分类: Linux "},"知识库/计算机通用/编程语言学习/C 语言/C 语言知识点.html":{"url":"知识库/计算机通用/编程语言学习/C 语言/C 语言知识点.html","title":"C 语言","keywords":"","body":" C 语言知识点 Day01 开发前奏 Day02 IDE和基本数据类型 Day03 表达式 Day04 流程控制结构 Day05 循环控制结构 Day06 循环控制结构 Day07 函数 Day08 进制 Day09 数组 Day10 字符串 Day11 指针 Day12 指针 Day13 结构体与枚举 Day14 预处理指令 C 语言知识点 Day01 开发前奏 操作系统 应用软件和操作系统 移动开发 OS X、Dock栏、任务栏、OS X系统的目录结构、移动磁盘的读写和操作 C语言介绍 终端使用 开发C程序的步骤 Day02 IDE和基本数据类型 数据处理 内存中如何存储数据 变量的声明、赋值、输出printf 基本数据类型: int, char, float, double Day03 表达式 输入scanf、 算术运算符和算术表达式、 复合赋值运算符、 自增自减运算、 逗号表达式、 比较表达式 Day04 流程控制结构 逻辑运算符和其优先级、 if结构、 变量作用域、 三元表达式 Day05 循环控制结构 switch-case语法、 程序调试、 while循环、 break、 continue Day06 循环控制结构 do-while循环、 for循环 Day07 函数 函数意义使用函数来实现代码的重用、 函数声明、 实现、 调用、 参数的本质、形参、实参、【基本数据类型、数组、结构体、函数作为函数参数时不同传递】 执行步骤、 返回值、 goto、break、continue补充。 Day08 进制 预处理指令概述、 文件包含指令、 相对路径和绝对路径、 多文件开发、 二、八、十、十六进制、 内存构造和变量占用的字节数、 原码、反码、补码、按位与、或、取反、异或、左移、右移、 深入变量、 int修饰符、有符号和无符号、 char变量深入 Day09 数组 格式控制符总结、 垃圾值、 数组概述、 声明、 存储、 元素本质、取值、遍历、长度、元素默认值和初始化、在内存中的存储形式、地址、 长度计算、 【必须掌握的算法：找最大值、找最小值、求累加和、求平均值、判断数组包含某元素、找某元素第一次出现的下标、产生不重复的随机数、选择排序、冒泡排序！、二分查找法】、 数组作为函数参数是地址传递 Day10 字符串 数组函数模块、 二维数组声明、 存值、取值、遍历、行列数、初始化、 在内存中的存储、 与函数(作为参数、返回值)、 字符数组、 从控制台接受字符串数据、 字符串长度计算、 字符串相关函数 Day11 指针 变量的值和地址、 指针变量声明、初始化、使用、 野指针、NULL、 多个指针指向同一变量、 指针与函数、指针类型、多级指针、指针与整数的加减法、 指针与数组、使用指针遍历数组、数组作为函数参数的本质、数组使用中括号下标的本质、指针变量的加减法、存储指针的数组、 指针之间的减法和比较运算 Day12 指针 字符串数据的两种存储方式、 内存中的五大区域、 字符串的恒定性、字符串数组、 字符串数组排序、 fputs输出字符串、fgets输入字符串、 const修饰基本数据类型、数组、指针、 malloc、calloc与realloc函数 Day13 结构体与枚举 指针与函数、 指向函数的指针、 结构体概述、 用结构体创建新数据类型、 结构体存在的意义、 结构体变量初始化、默认值、 结构体类型的作用域、 结构体变量之间的相互赋值、结构体数组、指针、结构体嵌套、结构体与函数、枚举的简单使用、typedef类型定义 Day14 预处理指令 文件包含指令、 宏定义、 带参数和无参数的宏、 条件编译指令、 static和extern "},"知识库/计算机通用/编程语言学习/Objective-C 语言/OC 知识点.html":{"url":"知识库/计算机通用/编程语言学习/Objective-C 语言/OC 知识点.html","title":"Objective-C 语言","keywords":"","body":" Ojective-C 语言 OC 概述 OC 中的面向对象 OC 中面向对象特性 OC 中分类、协议、类扩展、委托模型 Block 复制 (深浅拷贝) 单例 内存管理 Foundation 框架介绍 文件操作 对象归档 KVC / KVO Ojective-C 语言 OC 概述 OC 介绍及发展背景 OC 对比 C 语言的差异化 OC - HelloWorld OC 中的面向对象 类的基本概念 方法、成员属性 对象的基本概念 对象的声明、使用、存储细节 对象的消息机制 OC 中面向对象特性 封装 继承 多态 OC 中分类、协议、类扩展、委托模型 分类 / 类目 Category 协议 Protocol 类扩展 / 延展 Extension 委托模型 Delegate (代理模式) Block blocks 基本概念 blocks 声明 blocks 使用 blocks 作为方法的参数 blocks 作回调 block 作用域 复制 (深浅拷贝) 单例 copy 和 mutableCopy 单例模式 内存管理 ARC 和 非 ARC 的区别 手动内存管理 手动释放池介绍 点语法内存管理 Foundation 框架介绍 NSString / NSMutableString NSArray / NSMutableArray NSDictionary / NSMutableDictionary NSData NSSet / NSMutableSet NSPoint / NSRange / NSRect NSNumber / NSValue / NSNull 文件操作 NSFileManager NSFileHandle 应用程序沙盒及使用 对象归档 NSKeyedArchiver / NSKeyedUnarchiver NSCoder KVC / KVO NSKeyValueCoding Key-Value Observing "},"知识库/计算机通用/编程语言学习/Swift 语言/":{"url":"知识库/计算机通用/编程语言学习/Swift 语言/","title":"Swift 语言","keywords":"","body":" Swift 和 OC 语言 Swift 简介 Swift 快速体验 Swift 基础语法 Swift 函数和闭包 函数 闭包 Swift 面向对象 构造和析构函数 懒加载 计算型属性 重写 setter 方法 命名空间和反射机制 获取成员变量、属性和方法列表 Swift 和 OC 语言 Swift 简介 Swift 快速体验 Playground 第一个应用程序 Swift 基础语法 变量和常量 可选项 控制流 循环 字符串 集合 错误处理 Swift 函数和闭包 函数 函数的定义 闭包 闭包的定义 声明变量【闭包类型】 做函数的参数【闭包类型】 做函数的返回值【闭包类型】 尾随闭包 闭包的循环引用和解除 Swift 面向对象 构造和析构函数 构造函数基础 重载和重写构造函数 KVC 构造函数[运行时] 便利构造函数 析构函数 懒加载 计算型属性 重写 setter 方法 命名空间和反射机制 获取成员变量、属性和方法列表 "},"知识库/计算机通用/编程语言学习/PHP/PHP.html":{"url":"知识库/计算机通用/编程语言学习/PHP/PHP.html","title":"PHP","keywords":"","body":"服务器端php搭建 登录 login.php 1, 'userName' => $userName, 'userImage' => $accessType ); // 将数据字典使用JSON编码 echo json_encode($result); } else { // 将查询结果绑定到数据字典 $result = array( 'userId' => -1, 'userName' => $userName, 'userImage' => $accessType ); // 将数据字典使用JSON编码 echo json_encode($result); } return true; } } header('Content-Type:application/json;charset=utf-8'); $itcast = new itcastUsers; $itcast->userLogin(); ?> login.html post请求 GET请求 POST请求 上传文件 upload.php ```php // 打印出上传的文件的信息 print_r($_FILES); // 创建一个空数组(字典?)来存储最终要返回的响应 $response = array(); // 获取服务器的根目录，拼接存储上传的文件的路径 $target_path = $_SERVER['DOCUMENT_ROOT'].\"/upload/files/\";//接收文件目录 // 在上传的路径上拼接文件名 $target_path = $target_path . basename( $_FILES['userfile']['name']); // 将文件从暂存目录移动到接收文件目录 // $_FILES是个字典 // $_FILES['userfile']是上传的文件的信息数组 // $_FILES['userfile']['tmp_name']是文件信息数组中文件的暂存路径(包括文件临时名称) if(move_uploaded_file($_FILES['userfile']['tmp_name'], $target_path)) { // 如果上传成功，往响应字典中存储成功信息 $response ['success'] = \"The file \". basename( $_FILES['userfile']['name']). \" has been uploaded\"; } else{ // 如果上传失败，存储失败信息 $response ['error'] = \"There was an error uploading the file, please try again!\". $_FILES['userfile']['error']; } // 返回响应json格式 echo json_encode($response); ?> ``` upload.html 文件上传测试 文件上传 请选择要上传的文件: "},"知识库/计算机通用/编程语言学习/JavaScript/JavaScript.html":{"url":"知识库/计算机通用/编程语言学习/JavaScript/JavaScript.html","title":"JavaScript","keywords":"","body":"JavaScript 介绍 JavaScript是一门广泛用于浏览器客户端的脚本语言 由Netspace公司设计，当时跟Sun公司合作，所以名字起的像Java 一般简称JS 常见用途 HTML DOM操作(节点操作，比如添加、修改、删除节点) 给HTML网页增加动态功能，比如动画 事件处理：比如监听鼠标点击、鼠标滑动、键盘输入 语法 声明变量 var num = 5; 循环 for (var i = 0; i 打印到控制台 console.log() 声明方法 function() { } 获取HTML文档中的控件 document.getElementById(\"textField1\"); document.getElementsByTagName(\"input\"); 返回数组 判断 viewDidLoad window.onload = function() {当html的所有view全都加载完毕后执行的代码} 跳转到文档中的某个位置 document.location.href = '#id号'; "},"知识库/计算机通用/编程语言学习/HTML & CSS/HTML.html":{"url":"知识库/计算机通用/编程语言学习/HTML & CSS/HTML.html","title":"HTML","keywords":"","body":"HTML 详见Practice中的【HTML练习】 可在菜鸟教程学习https://www.runoob.com/ WebStorm IDE破解 http://www.mamicode.com/info-detail-2912162.html WebStorm无法打开解决 https://www.javatang.com/archives/2017/10/09/32061820.html HTML简介 什么是HTML Hyper Text Markup Language, 超文本标记语言 其实就是文本，由浏览器负责将它解析成具体的网页内容 比如，浏览器会将左边的HTML代码转换为右边的网页内容 HTML和XML的区别 html的标签是预定义好的 xml的标签是自己定义的 html目的是用来展示数据 xml目的是用来存储或通过网络传输数据 HTML演示 主要理解表单的作用：让用户提交数据 HTML 组成 跟XML类似，HTML由N个标签(节点、元素、标记)组成 HTML语法非常松散，目前的最新版是5.0，也就是HTML5 常见标签 标题: h1, h2, h3, h4, h5... 段落: p 换行: br 容器: div, span (用来容纳其他标签) 表格: \\ table row table head table data相当于cell列表: ul 无序列表 ol 有序列表 li 每项 图片: img 【images/01.jpg这种路径是相对于当前html所在路径的相对路径】 表单: input【textField、UIButton等获取用户输入的控件】 链接: a 百度 【超链接】 空格:   注释 一条横线 "},"知识库/计算机通用/编程语言学习/HTML & CSS/CSS.html":{"url":"知识库/计算机通用/编程语言学习/HTML & CSS/CSS.html","title":"CSS","keywords":"","body":"CSS 【详见Practice中的HTML练习】 简介 CSS的全称是Cascading Style Sheets，层叠样式表 用来控制HTML标签的样式，在美化网页中起到非常重要的作用 CSS的编写格式是键值对形式的 color: red; background-color: blue; font-size: 20px; CSS有3种形式 行内样式：直接在tag的属性处用style设置 页内样式: 创建一个style class，在tag属性处应用 外部样式: 在外部的css文件中声明style class，链接这个文件到此html，在tag属性处应用那些class 选择器 作用 选择对应的标签，为其添加样式 分类 标签选择器 div { color:red; } 类选择器 .cls { color:blue; } id选择器 #hi { color:orange; } 并列选择器 div, .cls { color: red; }【所有div和所有cls类都用这个样式】“或” 复合选择器 div .cls { color:red; }【是div且cls类的才用这个样式】\"且\" 后代选择器 div p {color: red;} 直接后代选择器 div > p {color: red;} 布局介绍 【见practices中的布局介绍】 "},"知识库/计算机通用/Gitbook/Gitbook.html":{"url":"知识库/计算机通用/Gitbook/Gitbook.html","title":"Gitbook","keywords":"","body":"Gitbook 在电脑上创建一个存储 Book 的文件夹 初始化项目 gitbook init 生成 \"README.md\" 和 \"SUMMARY.md\" 两个基本文件 README.md SUMMARY.md 总目录框架 可以在里面搭建好目录后，再 gitbook init, 会生成没有的的文件夹和文件 在md文件中创作 在本地服务器上查看电子书预览 gitbook serve 首先调用 gitbook build编译书籍，完成以后会打开一个 web 服务器，监听本地 4000 端口，在浏览器中输入http://localhost:4000，即可打开电子书。 生成电子书 gitbook build 该命令会在当前文件夹中生成_book文件夹，里面是 html 版本的电子书 插件 expandable-chapters 配置目录折叠功能如下 chapter-fold 导航目录折叠 page-toc-button 悬浮目录 貌似没起作用 back-to-top-button 回到顶部 lightbox 单击查看图片 custom-favicon 修改标题栏图标 splitter 侧边栏宽度可调节 tbfed-pagefooter 页面添加页脚 search-pro 高级搜索（支持中文） page-treeview 生成页内目录 必须用不同的标题字体才可以，挺有用 删除版权信息 大约43行，在generateContent方法定义中，该方法的返回值 return renderContent ? `${copyRight + renderContent}` : ''; // 改成： return renderContent; 在 node_modules 中全部删除 在 book.json 配置好 最后重新 gitbook install 即可 "},"知识库/计算机通用/Gitbook/Github Pages.html":{"url":"知识库/计算机通用/Gitbook/Github Pages.html","title":"Github Pages","keywords":"","body":"Github Pages Github Pages 功能介绍 首先，必须在 Github 创建一个 joyawang.github.io 为名的仓库(Repository)【只能创建一个?】用来当做Github Pages https://joyawang.github.io/ 的主页 在此仓库的设置界面找到 Github Pages 选项， 就可以设置主页的网页内容来源了，默认从此仓库的 master 分支加载 index.html 文件 从现在开始，Github 任何一个仓库都可以在 https://joyawang.github.io/ 上托管页面 在 Github 创建一个 ThinkTank 仓库，在设置界面找到 Github Pages，将来源选为 master 分支的 /docs 文件夹【也可选其他方式】 这样，https://joyawang.github.io/ThinkTank 就会从 ThinkTank 仓库 master 分支的 docs 文件夹加载 index.html 文件。 所以，只要将你生成的书的 html 文件实时上传到 ThinkTank 仓库 master 分支的 docs 文件夹，你就可以从 https://joyawang.github.io/ThinkTank 访问你的书内容了 GitHub Pages 的静态资源支持下面 3 个来源： master 分支 master 分支的 /docs 目录 gh-pages 分支 第一种方式 在生成静态网页时，将保存的目录指定为 ./docs【gitbook build会替换原来的_book文件夹，所以每次生成到./docs文件夹，让gitpages从那加载】 $ gitbook build ./ ./docs 然后 git add . 并且 git commit 提交 最后推送到 GitHub 仓库，更新 master 上的 /docs 文件夹中的内容 $ git push origin master 第二种方式 执行下面命令，将 _book 目录推送到 GitHub 仓库的 gh-pages 分支。【gitbook build会替换原来的_book文件夹，所以每次上传的时候，也用最新的_books文件夹完全覆盖gh-pages】 $ git subtree push --prefix=_book origin gh-pages "},"知识库/计算机通用/操作系统/The Linux Command Line.html":{"url":"知识库/计算机通用/操作系统/The Linux Command Line.html","title":"The Linux Command Line","keywords":"","body":" The Linux Command Line INTRODUCTION PART I: LEARNING THE SHELL 学习Shell Chapter 1: What is the Shell? Shell是什么 1. Terminal Emulators 终端仿真程序 2. Making Your First Keystrokes 3. Try Some Simple Commands 4. Ending a Terminal Session 5. Summing Up Chapter 2: Navigation 文件导航 1. Understanding the File System Tree 理解文件系统树 2. The Current Working Directory 当前工作文件夹 3. Listing the Contents of a Directory 显示文件夹的文件目录 4. Changing the Current Working Directory 切换当前工作文件夹 Absolute Pathnames 绝对路径名 Relative Pathnames 相对路径名 Some Helpful Shortcuts 有用的快捷键 Summing Up 总结 Chapter 3: Exploring the System 探索文件系统 1. More Fun with ls ls的更多用法 Options and Arguments 选项和参数？ A Longer Look at Long Format 长格式 2. Determing a File's Type with file 使用file命令查看一个文件的类型 3. Viewing File Contents with less 使用less命令查看文件内容 4. Taking a Guided Tour 5. Symbolic Links 6. Hard Links 7. Summing Up 总结 Chapter 4: Manipulating Files and Dictionaries 操作文件和字典 1. Wildcards 通配符 2. mkdir - Create Directories 创建文件夹 3. cp - Copy Files and Directories 复制文件和文件夹 4. mv - Move and Rename Files 移动和重命名文件 5. rm - Remove files and Directories 删除文件和文件夹 6. ln - Create Links 创建链接 7. Building a Playground Creating Directories Copying Files Moving and Renaming Files Creating Symbolic Links Removing Files and Directories Chapter 5: Working with Commands 使用命令 1. What Exactly Are Commands? 命令到底是什么？ 2. Identifying Commands 辨别命令 type - Display a Command's Type 显示命令的类别 which - Display an Executable's Location 显示可执行命令的位置 3. Getting a Command's Documentation 获取命令的文档 help - Get Help for Shell Builtins 获取Shell内置命令的帮助 --help - Display Usage Information 显示使用信息 man - Display a Program's Manual Page 显示一个程序的使用手册页 apropos - Display Appropriate Commands 显示合适的命令? whatis - Display One-line Manual Page Description 显示一行手册页描述 info - Display a Program's Info Entry 显示一个程序信息入口 README and Other Program Documentation Files README和其他程序文档文件 4. Creating Our Own Commands with alias 用快捷方式创建我们自己的命令 5. Summing Up 总结 Chapter 6: Redirection 重定向 1. Standard Input, Output, and Error 标准输入、输出和错误 2. Redirecting Standard Output 重定向标准输出 3. Redirecting Standard Error 重定向标准错误 Redirecting Standard Output and Standard Error to One File 将标准输出和标准错误重定向到一个文件 Disposing of Unwanted Output 处理不想要的输出 4. Redirecting Standard Input 重定向标准输出 cat: Concatenate Files cat命令连结文件 5. Pipelines Filters 过滤 uniq: Report or Omit Repeated Lines 报告或者忽略重复行 wc: Print Line, Word, and Byte Counts 打印行、单词和字节数 grep: Print Lines Matching a Pattern 打印匹配一个模式的行 head/tail: Print First/Last Part of Files 打印文件的头/尾部 tee: Read from Stdin and Output to Stdout and Files 从标准输入读取并输出到标准输出和文件 Chapter 7: Seeing the World as the Shell Sees It 1. Expansion 扩展？ Pathname Expansion 路径名扩展? Tilde Expansion Arithmetic Expansion 算术扩展？ Brace Expansion Parameter Expansion 参数扩展 Command Substitution 命令替换 2. Quoting Double Quotes Single Quote Escaping Characters Backslash Escape Sequences 3. Summing Up Chapter 8: Advanced Keyboard Tricks 1. Command Line Editing 命令行编辑 Cursor Movement 光标移动 Modifying Text 修改文字 Cutting and Pasting (Killing and Yanking) Text 剪切和粘贴 2. Completion 补全 3. Using History 使用历史 Searching History 搜索历史 History Expansion 历史扩展? 4. Summing Up Chapter 9: Permissions 1. Owners, Group Members, and Everybody Else 拥有者、群组成员、其他人 2. Reading，Writing，and Executing 读取、写入和执行 chmod: Change File Mode 修改文件模式 Setting File Mode with the GUI 使用GUI修改文件模式 umask: Set Default Permissions 设置默认权限 Some Special Permission 一些特殊权限 3. Changing Identities su: Run a Shell with Substitute User and Group IDs 更换用户 sudo: Execute a Command As Another User chown: Change File Owner and Group 改变文件所有者和所属群组 chgrp: Change Group Ownership 更改群组 4. Exercising Our Privileges 5. Changing Your Password 6. Summing Up Chapter 10: Processes 1. How a Process Works 一个程序怎么工作 2. Viewing Processes 查看程序 Viewing Processes Dynamically with top 使用top命令动态查看所有程序 3. Controlling Processes 控制程序 Interrupting a Process 中断一个程序 Putting a Process in the Background 将一个程序放到后台 Returning a Process to the Foreground 将程序返回到前台 Stopping (Pausing) a Process 停止(暂停)一个程序 4. Signals Sending Signals to Processes with kill 使用kill命令向程序发送信号 Sending Signals to Multiple Processes with killall 使用killall命令向多个程序发送信号 5. Shutting Down the System 关闭系统 6. More Process-Related Commands 更多程序相关的命令 7. Summing Up 总结 PART II: CONFIGURATION AND THE ENVIRONMENT 配置和环境 Chapter 11: The Environment 环境 1. What is Stored in the Environment? 环境中存储了什么？ Examining the Environment 检查环境 Some Interesting Variables 一些有趣的变量 2. How is the Environmnet Established 环境是怎么建立的？ What's in a Startup File? 启动文件中有什么？ 3. Modifying the Environment 修改环境 Which Files Should We Modify? 我们应该修改哪些文件？ Text Editors 文件编辑器 Using a Text Editor 使用文件编辑器 Activating Our Changing 激活我们的更改 Chapter 12: A Gentle Introduction to vi 简单介绍vi编辑器 1. Why We should Learn Vi 为什么要使用Vi 2. A Little Background 背景 3. Starting and Stopping vi 使用和停止vi 4. Editing Modes 编辑模式 Entering Insert Mode 进入插入模式 Saving Our Work 保存我们的工作 5. Moving the Cursor Around 移动光标 6. Basic Editing 基本编辑 Appending Text 添加文字 Opening a Line 开启一行 Deleting Text 删除文字 Cutting, Copying, and Pasting Text 剪切、复制和粘贴 Joining Lines 拼接行 7. Searching and Replace 搜索和替换 Searching Within a Line 行内搜索 Searching the Entire File 在整个文件中搜索 Global Search-and-Replace 全局搜索和替换 8. Editing Multiple Files 编辑多个文件 Switching Between Files 切换文件 Opening Additional Files for Editing 打开多个文件进行编辑 Copying Content from One File into Another 从一个文件中粘贴内容到另一个 Inserting an Entire File into Another 将整个文件插入到另一个中 9. Saving Our Work 保存 10. Summing Up 总结 Chapter 13: Customizing the Prompt 1. Anatomy of a Prompt 2. Trying Some Alternative Prompt Designs 3. Adding Color 4. Moving the Cursor 5. Saving the Prompt 6. Summing Up PART III: COMMON TASKS AND ESSENTIALS TOOLS 普通任务和基本工具 Chapter 14: Package Management 包管理 1. Packaging Systems 打包系统 2. How a Package System Works 包系统怎么工作 Package Files 包文件 Repositories 库 Dependencies 依赖 High- and Low-Level Package Tools 高级和低级打包工具 3. Common Package Management Tasks 普通包管理任务 Finding a Package in a Repository 从库中寻找包 Installing a Package from a Repository 从库中安装包 Installing a Package from a Package File 从包文件中安装包 Removing a Package 删除包 Updating Packages from a Repository 从库中更新包 Updating a Package from a Package File 从包文件中更新包 Listing Installed Packages 显示所有安装的包 Determining Whether a Package Is Installed 查看是否安装了某个包 Displaying Information About an Installed Package 显示一个已安装的包的信息 Finding Which Package Installed a File 查找哪个包安装了文件 4. Summing Up Chapter 15: Storage Media 存储介质 1. Mounting and Unmounting Storage Devices 加载和推出存储设备 Viewing a List of Mounted File Systems 查看加载的文件系统列表 Determining Device Names 决定设备名称 2. Creating New File System 创建新文件系统 Manipulating Partitions with fdisk 用fdisk命令进行分区 Creating a New File System with mkfs 用mkfs命令创建一个新文件系统 3. Testing and Repairing File Systems 测试和修复文件系统 4. Moving Data Directly to and from Devices 设备间移动数据 Creating CD-ROM Images 创建CD-ROM镜像? Creating an Image Copy of a CD-ROM 创建镜像复件 Creating an Image from a Collection of Files 用文件集合创建镜像 5. Writing CD-ROM Images 写入镜像 Mounting an ISO Image Directly 直接加载一个ISO镜像 Blanking a Rewritable CD-ROM 清空一个可重复读写的CD-ROM Writing an Image 写一个镜像 6. Summing Up 7. Extra Credit Chapter 16: Networking Chapter 17: Searching for Files Chapter 18: Archiving and Backup Chapter 19: Regular Expressions Chapter 20: Text Processing Chapter 21: Formatting Output Chapter 22: Printing Chapter 23: Compiling Programs PART IV: WRITING SHELL SCRIPTS Chapter 24: Writing Your First Scripts Chapter 25: Starting a Project Chapter 26: Top-Down Design Chapter 27: Flow Control: Branching with If Chapter 28: Reading Keyboard Input Chapter 29: Flow Control: Looping with while/until Chapter 30: Troubleshooting Chapter 31: Flow Control: Branching with case Chapter 32: Positional Parameters Chapter 33: Flow Control: Looping with for Chapter 34: Strings and Numbers Chapter 35: Arrays Chapter 36: Exotica The Linux Command Line INTRODUCTION PART I: LEARNING THE SHELL 学习Shell Chapter 1: What is the Shell? Shell是什么 1. Terminal Emulators 终端仿真程序 2. Making Your First Keystrokes 3. Try Some Simple Commands 4. Ending a Terminal Session 5. Summing Up Chapter 2: Navigation 文件导航 1. Understanding the File System Tree 理解文件系统树 2. The Current Working Directory 当前工作文件夹 3. Listing the Contents of a Directory 显示文件夹的文件目录 4. Changing the Current Working Directory 切换当前工作文件夹 Absolute Pathnames 绝对路径名 Relative Pathnames 相对路径名 Some Helpful Shortcuts 有用的快捷键 Summing Up 总结 Chapter 3: Exploring the System 探索文件系统 1. More Fun with ls ls的更多用法 Options and Arguments 选项和参数？ A Longer Look at Long Format 长格式 2. Determing a File's Type with file 使用file命令查看一个文件的类型 3. Viewing File Contents with less 使用less命令查看文件内容 4. Taking a Guided Tour 5. Symbolic Links 6. Hard Links 7. Summing Up 总结 Chapter 4: Manipulating Files and Dictionaries 操作文件和字典 1. Wildcards 通配符 2. mkdir - Create Directories 创建文件夹 3. cp - Copy Files and Directories 复制文件和文件夹 4. mv - Move and Rename Files 移动和重命名文件 5. rm - Remove files and Directories 删除文件和文件夹 6. ln - Create Links 创建链接 7. Building a Playground Creating Directories Copying Files Moving and Renaming Files Creating Symbolic Links Removing Files and Directories Chapter 5: Working with Commands 使用命令 1. What Exactly Are Commands? 命令到底是什么？ 2. Identifying Commands 辨别命令 type - Display a Command's Type 显示命令的类别 which - Display an Executable's Location 显示可执行命令的位置 3. Getting a Command's Documentation 获取命令的文档 help - Get Help for Shell Builtins 获取Shell内置命令的帮助 --help - Display Usage Information 显示使用信息 man - Display a Program's Manual Page 显示一个程序的使用手册页 apropos - Display Appropriate Commands 显示合适的命令? whatis - Display One-line Manual Page Description 显示一行手册页描述 info - Display a Program's Info Entry 显示一个程序信息入口 README and Other Program Documentation Files README和其他程序文档文件 4. Creating Our Own Commands with alias 用快捷方式创建我们自己的命令 5. Summing Up 总结 Chapter 6: Redirection 重定向 1. Standard Input, Output, and Error 标准输入、输出和错误 2. Redirecting Standard Output 重定向标准输出 3. Redirecting Standard Error 重定向标准错误 Redirecting Standard Output and Standard Error to One File 将标准输出和标准错误重定向到一个文件 Disposing of Unwanted Output 处理不想要的输出 4. Redirecting Standard Input 重定向标准输出 cat: Concatenate Files cat命令连结文件 5. Pipelines Filters 过滤 uniq: Report or Omit Repeated Lines 报告或者忽略重复行 wc: Print Line, Word, and Byte Counts 打印行、单词和字节数 grep: Print Lines Matching a Pattern 打印匹配一个模式的行 head/tail: Print First/Last Part of Files 打印文件的头/尾部 tee: Read from Stdin and Output to Stdout and Files 从标准输入读取并输出到标准输出和文件 Chapter 7: Seeing the World as the Shell Sees It 1. Expansion 扩展？ Pathname Expansion 路径名扩展? Tilde Expansion Arithmetic Expansion 算术扩展？ Brace Expansion Parameter Expansion 参数扩展 Command Substitution 命令替换 2. Quoting Double Quotes Single Quote Escaping Characters Backslash Escape Sequences 3. Summing Up Chapter 8: Advanced Keyboard Tricks 1. Command Line Editing 命令行编辑 Cursor Movement 光标移动 Modifying Text 修改文字 Cutting and Pasting (Killing and Yanking) Text 剪切和粘贴 2. Completion 补全 3. Using History 使用历史 Searching History 搜索历史 History Expansion 历史扩展? 4. Summing Up Chapter 9: Permissions 1. Owners, Group Members, and Everybody Else 拥有者、群组成员、其他人 2. Reading，Writing，and Executing 读取、写入和执行 chmod: Change File Mode 修改文件模式 Setting File Mode with the GUI 使用GUI修改文件模式 umask: Set Default Permissions 设置默认权限 Some Special Permission 一些特殊权限 3. Changing Identities su: Run a Shell with Substitute User and Group IDs 更换用户 sudo: Execute a Command As Another User chown: Change File Owner and Group 改变文件所有者和所属群组 chgrp: Change Group Ownership 更改群组 4. Exercising Our Privileges 5. Changing Your Password 6. Summing Up Chapter 10: Processes 1. How a Process Works 一个程序怎么工作 2. Viewing Processes 查看程序 Viewing Processes Dynamically with top 使用top命令动态查看所有程序 3. Controlling Processes 控制程序 Interrupting a Process 中断一个程序 Putting a Process in the Background 将一个程序放到后台 Returning a Process to the Foreground 将程序返回到前台 Stopping (Pausing) a Process 停止(暂停)一个程序 4. Signals Sending Signals to Processes with kill 使用kill命令向程序发送信号 Sending Signals to Multiple Processes with killall 使用killall命令向多个程序发送信号 5. Shutting Down the System 关闭系统 6. More Process-Related Commands 更多程序相关的命令 7. Summing Up 总结 PART II: CONFIGURATION AND THE ENVIRONMENT 配置和环境 Chapter 11: The Environment 环境 1. What is Stored in the Environment? 环境中存储了什么？ Examining the Environment 检查环境 Some Interesting Variables 一些有趣的变量 2. How is the Environmnet Established 环境是怎么建立的？ What's in a Startup File? 启动文件中有什么？ 3. Modifying the Environment 修改环境 Which Files Should We Modify? 我们应该修改哪些文件？ Text Editors 文件编辑器 Using a Text Editor 使用文件编辑器 Activating Our Changing 激活我们的更改 Chapter 12: A Gentle Introduction to vi 简单介绍vi编辑器 1. Why We should Learn Vi 为什么要使用Vi 2. A Little Background 背景 3. Starting and Stopping vi 使用和停止vi 4. Editing Modes 编辑模式 Entering Insert Mode 进入插入模式 Saving Our Work 保存我们的工作 5. Moving the Cursor Around 移动光标 6. Basic Editing 基本编辑 Appending Text 添加文字 Opening a Line 开启一行 Deleting Text 删除文字 Cutting, Copying, and Pasting Text 剪切、复制和粘贴 Joining Lines 拼接行 7. Searching and Replace 搜索和替换 Searching Within a Line 行内搜索 Searching the Entire File 在整个文件中搜索 Global Search-and-Replace 全局搜索和替换 8. Editing Multiple Files 编辑多个文件 Switching Between Files 切换文件 Opening Additional Files for Editing 打开多个文件进行编辑 Copying Content from One File into Another 从一个文件中粘贴内容到另一个 Inserting an Entire File into Another 将整个文件插入到另一个中 9. Saving Our Work 保存 10. Summing Up 总结 Chapter 13: Customizing the Prompt 1. Anatomy of a Prompt 2. Trying Some Alternative Prompt Designs 3. Adding Color 4. Moving the Cursor 5. Saving the Prompt 6. Summing Up PART III: COMMON TASKS AND ESSENTIALS TOOLS 普通任务和基本工具 Chapter 14: Package Management 包管理 1. Packaging Systems 打包系统 2. How a Package System Works 包系统怎么工作 Package Files 包文件 Repositories 库 Dependencies 依赖 High- and Low-Level Package Tools 高级和低级打包工具 3. Common Package Management Tasks 普通包管理任务 Finding a Package in a Repository 从库中寻找包 Installing a Package from a Repository 从库中安装包 Installing a Package from a Package File 从包文件中安装包 Removing a Package 删除包 Updating Packages from a Repository 从库中更新包 Updating a Package from a Package File 从包文件中更新包 Listing Installed Packages 显示所有安装的包 Determining Whether a Package Is Installed 查看是否安装了某个包 Displaying Information About an Installed Package 显示一个已安装的包的信息 Finding Which Package Installed a File 查找哪个包安装了文件 4. Summing Up Chapter 15: Storage Media 存储介质 1. Mounting and Unmounting Storage Devices 加载和推出存储设备 Viewing a List of Mounted File Systems 查看加载的文件系统列表 Determining Device Names 决定设备名称 2. Creating New File System 创建新文件系统 Manipulating Partitions with fdisk 用fdisk命令进行分区 Creating a New File System with mkfs 用mkfs命令创建一个新文件系统 3. Testing and Repairing File Systems 测试和修复文件系统 4. Moving Data Directly to and from Devices 设备间移动数据 Creating CD-ROM Images 创建CD-ROM镜像? Creating an Image Copy of a CD-ROM 创建镜像复件 Creating an Image from a Collection of Files 用文件集合创建镜像 5. Writing CD-ROM Images 写入镜像 Mounting an ISO Image Directly 直接加载一个ISO镜像 Blanking a Rewritable CD-ROM 清空一个可重复读写的CD-ROM Writing an Image 写一个镜像 6. Summing Up 7. Extra Credit Chapter 16: Networking Chapter 17: Searching for Files Chapter 18: Archiving and Backup Chapter 19: Regular Expressions Chapter 20: Text Processing Chapter 21: Formatting Output Chapter 22: Printing Chapter 23: Compiling Programs PART IV: WRITING SHELL SCRIPTS Chapter 24: Writing Your First Scripts Chapter 25: Starting a Project Chapter 26: Top-Down Design Chapter 27: Flow Control: Branching with If Chapter 28: Reading Keyboard Input Chapter 29: Flow Control: Looping with while/until Chapter 30: Troubleshooting Chapter 31: Flow Control: Branching with case Chapter 32: Positional Parameters Chapter 33: Flow Control: Looping with for Chapter 34: Strings and Numbers Chapter 35: Arrays Chapter 36: Exotica Index "},"知识库/计算机通用/操作系统/ls -al 各字段含义.html":{"url":"知识库/计算机通用/操作系统/ls -al 各字段含义.html","title":"ls -al 各字段含义.md","keywords":"","body":" 终端命令 Unix / Linux Command ls -al 各字段含义 终端命令 Unix / Linux Command ls -al 各字段含义 在终端运行的程序 Git, Cocoa Pods, Trojan, Nginx, apache, Home brew, Vim "},"知识库/计算机通用/操作系统/Linux系统服务器下载、上传目录和文件.html":{"url":"知识库/计算机通用/操作系统/Linux系统服务器下载、上传目录和文件.html","title":"Linux系统服务器下载、上传目录和文件","keywords":"","body":" Linux系统服务器下载、上传目录和文件 1、从服务器下载文件 2、上传本地文件到服务器 3、从服务器下载整个目录 4、上传目录到服务器 Linux系统服务器下载、上传目录和文件 1、从服务器下载文件 scp username@servername:/path/filename /tmp/local_destination 例如scp codinglog@192.168.0.101:/home/kimi/test.txt 把192.168.0.101上的/home/kimi/test.txt 的文件下载到 /tmp/local_destination 2、上传本地文件到服务器 scp /path/local_filename username@servername:/path 例如scp /var/www/test.php codinglog@192.168.0.101:/var/www/ 把本机/var/www/目录下的test.php文件 上传到192.168.0.101这台服务器上的/var/www/目录中 3、从服务器下载整个目录 scp -r username@servername:remote_dir/ /tmp/local_dir 例如:scp -r codinglog@192.168.0.101 /home/kimi/test /tmp/local_dir 4、上传目录到服务器 scp -r /tmp/local_dir username@servername:remote_dir 例如： scp -r test codinglog@192.168.0.101:/var/www/ 把当前目录下的test目录上传到服务器 的/var/www/ 目录 "},"知识库/计算机通用/操作系统/Mac系统快捷键.html":{"url":"知识库/计算机通用/操作系统/Mac系统快捷键.html","title":"Mac系统","keywords":"","body":"Mac 快捷键 "},"知识库/计算机通用/操作系统/Windows系统快捷键.html":{"url":"知识库/计算机通用/操作系统/Windows系统快捷键.html","title":"Windows系统","keywords":"","body":"Windows快捷键 Windows 快捷键 win+E 打开我的电脑 win+R 打开运行对话框 win+D 秒回桌面 win+M 最小化所有窗口 win+Pause/Break 打开系统属性对话框 win++/- 放大缩小 win+L 瞬间锁屏 win+T 程序切换 win+F 搜索计算机 win+方向键 分屏 win+上下方向键 最大最小化 Ctrl+A 全选 Ctrl+B 加粗 Ctrl+C 复制 Ctrl+D将当前WEB页添加到收藏夹 Ctrl+F 查找 Ctrl+N 新建文件 Ctrl+O 打开键入的文档或文件夹INTERNE地址 Ctrl+P 打印 Ctrl+R 刷新 Ctrl+S 保存 Ctrl+V 粘贴 Ctrl+W 关闭当前窗口 Ctrl+X 剪切 Ctrl+U 加下划线 Ctrl+Z 撤销 Ctrl+Esc 打开开始菜单 Ctrl+Shift 切换输入法 Ctrl+Tab 切换网页 Ctrl+Alt+A QQ截屏 Ctrl+Home 光标快速移到文件头 Ctrl+End 光标快速移动到文件尾 Ctrl+Shift+ Ctrl+Shift+> 快速放大文字 Alt+F4 关闭当前程序 Alt+空格+C 关闭窗口 Alt+空格+N 最小化当前窗口 Alt+空格+R 恢复最小化窗口 Alt+空格+X 最大化当前窗口 Alt+空格+M 移动窗口 Alt+空格 还原/移动小窗口 Alt+Tab 两个程序交换 Alt+F 打开文件菜单 Alt+V 打开视图菜单 Alt+E 打开编辑菜单 Alt+I 打开插入菜单 Alt+O 打开格式菜单 Alt+T 打开工具菜单 Alt+A 打开表格菜单 Alt+W 打开窗口菜单 Alt+H 打开帮助菜单 Alt+回车 查看文件属性 Alt+双击文件 查看文件属性 "},"知识库/计算机通用/操作系统/Windows系统安装.html":{"url":"知识库/计算机通用/操作系统/Windows系统安装.html","title":"Windows系统安装","keywords":"","body":"Windows系统安装 用小白装机大师xiaobaixitong.com Bios - Security - Secure Boot - Disabled 如果你的BIOS里有这些选项请设置如下： Secure Boot 设置为Disabled【禁用启动安全检查，这个最重要】 OS Optimized设置为Others或Disabled【系统类型设置】 CSM(Compatibility Support Module) Support设置为Yes UEFI/Legacy Boot选项选择成Both UEFI/Legacy Boot Priority选择成UEFI First Legacy Boot (传统老式启动）对应硬盘分区表必须为MBR，这种电脑一般只能装32位操作系统。 UEFI Boot（新版电脑启动）对应硬盘分区表必须为GPT（GPT和MBR分区表下都有NTFS格式），这种电脑可以装32位系统，也可以装64位。装64位系统一般对应UEFI Boot和GPT分区表；装32位系统一般对应Legacy Boot和MBR分区表。 如果是32位的系统，必须使bios中能支持legacy boot，并且硬盘要格为MBR分区表。32位的系统，以legacy boot，但是硬盘位GPT，就会卡在win10安装过程中的选盘界面，详细提示“Windows无法安装，选中的磁盘为GPT分区形式”，这时就需要用disk genius格盘，选mbr分区。 "},"知识库/计算机通用/操作系统/Windows系统下常见问题解决.html":{"url":"知识库/计算机通用/操作系统/Windows系统下常见问题解决.html","title":"Windows系统下常见问题解决","keywords":"","body":" Windows系统下常见问题解决 关闭系统自动更新 苹果手机iPhone热点连上没有网 Windows系统下常见问题解决 关闭系统自动更新 开机点按F8进入有安全模式和最后一次正常配置的界面； 禁用Windows Update：win+r调出运行-输入“services.msc”-找到“Windows Update”双击-启动类型改为禁用-应用即可 苹果手机iPhone热点连上没有网 首先给电脑无线连接的ipv4设置成手动分配ipIP：192.168.1.1DNS：114.114.114.114确定，然后再改回自动设置IP和DNS我的电脑是这样解决的，你可以试试看 "},"./":{"url":"./","title":"iOS 必备知识","keywords":"","body":" Introduction iOS 必备知识 内存管理 Block 多线程 Runtime Runloop 第三方库的源码 生命周期 UI 数据存储 架构 OC 语言特性 其他 必备书单 通用必备基础知识 计算机网络 算法 数据结构 编译原理 操作系统 数据库 设计模式 概率论 Linux 版本控制 通用语言基础 Introduction iOS 必备知识 内存管理 ARC 和 MRC 的区别 属性的关键字，他们具体的底层实现以及区别，被问烂的知识点包括 copy， 浅拷贝和深拷贝的区别， weak 的底层实现。稍微新颖一点的 assgin 和 weak，unsafe_unretained 具体有什么区别，assgin是否可以用来修饰对象。这一部分是面试必问，一定要弄懂。 Autorelease pool的底层实现原理，与 Runloop 的关系， autoreleasing 关键字。 Block 本质，基础概念 使用时要注意的地方 block的实现，如何截获自动变量的，如何修改自动变量的值的，block的几种形式 __block的本质 forwarding 指针 block怎么避免循环引用。是不是所有的block都会产生循环引用，block里面怎么避免被提前释放 多线程 iOS 中多线程的几种方式，区别，使用场景，基本概念，同步异步，串行并行的区别。 GCD，写一个死锁，并行和串行队列，同步和异步的区别，GCD怎么控制最大并发数 怎么让子线程定时执行一个方法，具体的实现方法 如何控制线程的最大并发数为10，然后加载十个图片最后展示出来，具体方法 子线程的runloop是怎么执行的，它里面的 autoreleasepool 是怎么执行的。 NSMutableArray 怎么保证线程安全的。 GCD怎么避免block中的变量被提前释放 Runtime 消息的动态转发 给 Category 添加属性，关联对象都有几种形式 method swizzling 说一说类的结构，运行时中的class都有什么属性，property都有什么属性 说一说isa指到NSObject的那个过程 Category的本质，load方法什么时候加载，Category重写了父类的方*怎样，底层源码 ，如果两个Category和一个基类，都有同名方法，先执行哪个 property会自动生成什么，如果此时已经有下划线_name的实例变量了那会生成什么 load 和 initialize Runloop runloop实现原理 source 类型 线程保活的方式 runloop和多线程的关系，以及timer的关系 第三方库的源码 生命周期 app 的声生命周期 控制器的生命周期 视图的生命周期 UI UICellectionView 瀑布流 UITableView 相关的优化，底层原理等 页面布局 layoutSubviews 和 drawRect 等的区别 自己实现一个 UIScrollView 事件的传递链和响应链 界面非常卡顿怎么定位到具体的类和方法 UIView 和 CALayer 区别 数据存储 数据持久化都有什么，用过什么，归档，偏好设置都可以存储什么类型 架构 MVC、MVVM 从 0 到 1 实现一个 app 的思路 对于项目从 main 函数执行之前到之后启动优化，卡顿优化和界面优化 OC 语言特性 OC 和 C 的区别， OC 和 Java、C++ 的区别 iOS 中的协议 OC 动态性 C 语言如何动态的交换两个方法的实现 其他 KVO 的底层原理，自己实现 KVC 的底层原理，自己实现 NSNotification 的底层原理，是同步还是一部，如何实现一个，如果在子线程接收一个通知能不能接收到 几种页面传值方式的区别 界面非常卡顿怎么定位到具体的类和方法 一个 int 类型的值，被 @ 包装成 NSNumber 类型，传递到一个接受 id 类型的方法参数中，这个值能不能保持正确 在 iPad 上面，分屏功能，拖拽 wps 的文件到 qq 的过程是怎么实现的 (进程间通信的方法) 如何实现 dispatch_once Instrument 的使用 热修复用过吗，平时版本怎么迭代，线上 bug 怎么修复？ 必备书单 ​ 图解 TCP/IP, 图解 HTTP ​ 剑指offer ​ Effective Objective-C ​ iOS 与 OSX 高级编程 ​ 以上都是必须要重复看很多遍的书单，其他不太重要的暂不列出 通用必备基础知识 ​ 抛开iOS 开发这一项技能，我们最基础的本质还是一名软件开发工程师，所以基础的部分必不可少，本篇面经中，不会具体总结出每个公司每一面具体考的内容，而是会根据不同的知识点将面试真题分为不同的专题部分来具体分析。 计算机网络 ​ 对于大前端类，计算机网络主要考量的还是传输层和应用层部分的知识。 ​ 浏览器输入url到网页显示经历了什么过程? ​ TCP三次握手：具体是怎么握手？为什么要三次握手？两次行不行？为什么不行？三次握手，第二次和第三次分别因为什么? ​ TCP是如何保持可靠传输的（拥塞控制，慢启动等等概念的理解） ​ TCP为什么要四次挥手，TIME_WAIT为什么至少设置两倍的MSL时间？ ​ TCP三次握手的详细数据传递，四次挥手详细数据内容，数据包组成、TIME_WAIT状态，2MSL，RTT，重传、滑动窗口、拥塞原理等等 ​ TCP、UDP面向连接、无连接具体理解，他们的区别，如何将 UDP 改造成和 TCP 功能相似 ​ TCP/IP四层协议，OSI七层协议，每层都有啥对应的协议，原理是啥 ​ http报文结构，http中超文本超是啥意思，http请求的组成 ​ http 报文头部含有什么，multipart了解吗 ​ http的状态码，200，304，301，http请求报文，响应报文 ​ get和post请求的区别？什么情况下用到？POST传输的数据都有哪些格式呢（这里需要搞定http各种请求传输的数据格式） ​ 描述一次完整的http请求 ​ 什么是cookie，什么是session，区别联系，cookie的本质是什么 ​ http1.0，1.1，2.0的区别 ​ https有几次握手和挥手？https的原理。http有几次挥手和握手？TLS在哪一网络层，基本原理是什么？ ​ https与中间人攻击 ​ HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数 ​ HTTPS是什么？握手过程，SSL原理，非对称加密了解多少 ​ 证书是干什么用的 算法 ​ 剑指 offer 上面的题目都是面试过程中的算法高频题，特别是二叉树和字符串，栈队列，链表，跳台阶问题一定要弄懂并且熟练。 ​ 八大排序算法的复杂度，概念，最好最坏情况，手写都是必须要掌握的，其中的重点是快排和堆排序，对于快排的优化，快排的基础原理，系统 API 快排的实现原理等都是必须要掌握的基础知识。 ​ 二分查找在面试过程中也比较常见，因为比较简单，包括二分查找的变种。 ​ 二叉树的前中后序的递归与非递归遍历方式，以及层序遍历和蛇形遍历都是重点。 ​ 海量数据如何找到重复次数最多的那个 优化 ​ 海量数据，但是都是1~100之间的，如何找到重复次数最多的那个 ​ 面试算法题一般不难，掌握技巧很重要。二叉树相关的算法题基本都要往二叉树的遍历上靠，链表相关的算法题基本都要往额外的“帮助指针”上面靠。 数据结构 ​ 在面试过程中这一类主要是和算法来一起考，数据结构一般主要会问栈与堆的区别，栈与队列的区别等等，在前端的面试中，红黑树这类的很少被问到。 编译原理 ​ 主要需要了解程序的编译过程的基础概念就OK。 操作系统 ​ 操作系统老生常谈的就是进程，线程的概念和区别，几个状态，以及他们的调度方式，通信方式，保持安全等等知识点，基本面试都会被考到一点，这一部分需要牢牢掌握，实在理解不了就背下来。 ​ 说说递归和普通的循环方式有什么区别 ​ 计算机存储系统是指？哪些存储系统能提高程序执行的效率？ ​ 段错误和栈溢出分别在什么时候会出现，为什么 ​ 其他方面的包括页置换等等基础知识，知道概念就OK，在前端面试过程中这部分不是特别重点考量的点。 数据库 ​ 数据库这部分也比较简单，主要就是 ACID 等基础概念，几大范式，简单的 sql 语句。 设计模式 ​ 工厂方法，抽象工厂，简单工厂的区别和联系 ​ 装饰者 ​ 观察者 ​ *模式等等 概率论 ​ 三门问题 ​ 红黑球等等常见问题百度即可 Linux ​ 主要包括基本的 shell 编程，基本的脚本命令，重点是 grep，ps，top，free等 版本控制 ​ 版本控制主要包括 Git 和 SVN ​ git 的基础概念，基本命令，包括 merge 和 rebase 的区别等。 ​ Git 和 SVN 的区别，异同点 ​ 平时开发中，版本控制的流程是怎么样的 通用语言基础 ​ 面向对象的多态。多态的几种方式 ​ 各个语言中的单例模式 ​ 内存管理方式 ​ static 和 const 的作用和区别 ​ C 语言的内存分段 "},"知识库/iOS 知识点/常用功能和第三方库/常用功能和第三方库.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/常用功能和第三方库.html","title":"iOS 常用功能集成","keywords":"","body":" 常用功能和第三方库 常用功能 第三方库 自动布局 网络访问 数据处理、压缩、解析、反射、KVC、字典转模型 IM聊天 通知推送 加密、解密 弹窗、指示器、进度提示 轮播图 分页菜单显示 音频、视频 相册图片/视频选择、相机拍摄、保存到相册 选择器 PickerView 数据库、存储 工具条 UIToolbar 搜索 导航栏 NavigationBar 下拉/上拉 状态栏 TabBar 输入框、字符串、文本框、键盘 日期、时间、日历事件、定时器 UIImage 图片、截图、Gif 颜色 UIColor 动画、渐变 绘图 列表，表格 UITableView UICollectionView 网格视图 UIScrollView StackView 滑块 地图、定位 分享 二维码、条形码 电话、短信、邮件、通讯录 设备信息、传感器、网络连接状态、系统声音服务、震动 图表 侧滑菜单 国际化、打包、发布 UI控件、组件、界面搭建、画界面 其他待分类 常用功能和第三方库 常用功能 客服 融云、七鱼、环信 聊天 XMPP、融云、七鱼、环信 支付 支付宝、微信、银联、Apple Pay 短信验证码 MobTech 掌淘科技 地图 百度地图、高德地图、苹果地图 音频、视频 AVPlayer、AVMediaPlayer、直播、点播 分享 友盟 异常上报/崩溃收集 腾讯 bugly 蓝牙 推送/通知 本地推送 远程推送：极光推送 授权登录 OAuth SSH SSO 打包、分发 第三方库 source 'https://github.com/CocoaPods/Specs.git' platform :ios, '9.0' pod 'CYLTabBarController', '~> 1.24.0' #TabbarController pod 'ZLCollectionViewFlowLayout'#类似淘宝首页，京东首页，国美首页等复杂布局 pod 'MJRefresh'#上拉下拉刷新 pod 'Masonry', '1.1.0' #自动布局-OC pod 'SnapKit', '4.2.0' #自动布局-Swift # pod 'EasyPeasy', '1.9.0' #自动布局 pod 'CocoaLumberjack'#日志 pod 'XCGLogger', '~> 7.0.1'#日志-Swift pod 'PYSearch', '0.9.1' #搜索 pod 'Eureka'#表单-Swift pod 'XLForm', '~> 4.1' #表单-OC pod 'SwiftForms' #表单 pod 'WMZDropDownMenu'#下拉菜单、筛选 pod 'SDCycleScrollView','>= 1.80' #轮播图 pod 'SideMenu' #侧滑菜单栏 pod 'SwipeCellKit' #单元格滑动按钮库 pod 'FoldingCell', '5.0.2' #折叠单元格 pod \"RATreeView\", \"~> 2.1.2\"#树层次结构列表 pod 'TYPagerController' #分页显示 pod \"PagingMenuController\" #分页显示 pod 'SVProgressHUD', '2.2.5' #进度指示器、弹窗【优先使用】 pod 'MBProgressHUD', '~> 1.2.0' #进度指示器、弹窗 pod 'ProgressHUD'#进度指示器、弹窗 pod 'JCAlertController' #替代UIAlertController的弹窗库 pod 'TZImagePickerController' #iOS8 and later 选择图片 pod 'SJVideoPlayer' #视频播放 pod \"SwViewCapture\" #滚动截图-Swift pod ‘AFNetworking’, ‘4.0.0’ #网络请求-OC pod 'Alamofire', '~> 5.1'#网络请求-Swift pod 'Moya', '~> 14.0' #网络访问层 # or pod 'Moya/RxSwift', '~> 14.0' # or pod 'Moya/ReactiveSwift', '~> 14.0' pod 'YYModel', '1.0.4' #数据解析字典转模型、KVC pod 'SwiftyJSON', '~> 4.0' #JSON数据解析-swift pod 'CryptoSwift', '~> 1.0' #加密 pod 'SAMKeychain'#钥匙串 pod 'SSZipArchive'#压缩 pod 'BRPickerView', '2.5.7' #日期/地址等选择器 pod 'SwiftDate', '~> 5.0'#日期处理 pod \"pop\" #动画 pod 'AAInfographics', :git => 'https://github.com/AAChartModel/AAChartKit-Swift.git' #图表库 pod 'Charts' #图表库 pod \"PromiseKit\", \"~> 6.8\"#异步编程库 pod 'Highlightr'#字符串高亮 pod 'mob_smssdk' #免费短信验证、掌淘科技MobTech pod 'Bugly' #腾讯bugly异常上报崩溃收集集成 pod 'FMDB', '2.7.5' #SQLite数据库 pod 'RealmSwift' #数据库 pod 'IceCream' #realm和iCloud同步 自动布局 Swift - 使用Auto Layout和Size Classes实现页面自适应弹性布局 Swift - 伸缩优先级详解（Content Hugging、Content Compression Resistance） Swift - 自动布局库SnapKit的使用详解1（配置、使用方法、样例） Swift - 自动布局库SnapKit的使用详解2（约束的更新、移除、重做） Swift - 自动布局库SnapKit的使用详解3（约束优先级，约束做动画） Swift - 自动布局库SnapKit的使用详解4（样例1：实现一个登录页面） Swift - 自动布局库SnapKit的使用详解5（样例2：实现一个计算器界面） 网络访问 Swift - 网络抽象层库Moya的使用详解 Swift - 使用原生方式同时上传多个文件和参数（form表单提交、post方式） Swift - 获取文件的MIMEType类型（根据后缀名自动获取） Swift - 实现大文件的后台上传功能（附样例） Swift - 实现大文件的后台下载功能（附样例） Swift - HTTP网络操作库Alamofire使用详解1（配置，以及数据请求） Swift - HTTP网络操作库Alamofire使用详解2（文件上传） Swift - HTTP网络操作库Alamofire使用详解3（文件下载，断点续传） Swift - HTTP网络操作库Alamofire使用详解4（用户权限认证） Swift - 使用Alamofire通过HTTPS进行网络请求，及证书的使用 Swift - 取消未完成的网络请求（使用Alamofire） Swift - 将网页缓存到本地（抓取html页面，并实现离线浏览） Swift - 拦截Alamofire的网络请求（缓存请求结果，从缓存中读取数据） Swift - Cookie内容的读取、删除、写入（附：手动清除Session） Swift - GCDWebServer使用详解1（介绍、安装配置、HTTP服务实现） Swift - GCDWebServer使用详解2（实现静态、动态网站，Web服务器） Swift - GCDWebServer使用详解3（文件传输、WebDav服务器实现） Swift - HTTP网络操作库SwiftHTTP使用详解1（配置，及数据请求） Swift - HTTP网络操作库SwiftHTTP使用详解2（文件上传、下载） Swift - HTTP网络操作库SwiftHTTP使用详解3（用户权限认证） Swift - 使用SwiftHTTP通过HTTPS进行网络请求，及证书的使用 Swift - FTP客户端的制作（使用Rebekka库） Swift - 做一个简单的无线U盘（手机端Http服务器搭建） Swift - 使用URLSession通过HTTPS进行网络请求，及证书的使用 Swift - 网络抓包工具Charles使用介绍1（模拟器、真机HTTP请求捕获） Swift - 网络抓包工具Charles使用介绍2（HTTPS请求捕获） 数据处理、压缩、解析、反射、KVC、字典转模型 Swift - 使用ObjectMapper实现模型转换1（JSON与Model的相互转换） Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍） Swift - 使用反射将自定义对象数据序列化成JSON数据 Swift - SwiftyJSON的使用详解（附样例，用于JSON数据处理） Swift - 使用gzip压缩Data数据（附：请求时将JSON数据进行压缩） Swift - 使用SSZipArchive实现文件的压缩、解压缩 Swift - 解析JSON数据（内置JSONSerialization与第三方JSONKit） XML Swift - 使用原生的XMLParser类来解析xml数据（附样例） pod 'XMLParsing', :git => 'https://github.com/ShawnMoore/XMLParsing.git' #Swift - 生成XML格式数据1（使用XMLParsing库） pod 'AEXML' #Swift - 生成XML格式数据3（使用AEXML库） GDataXML pod 'KissXML' #KissXML（DDXML） IM聊天 Swift - 使用vapor socks库进行socket通信（基于TCP、UDP协议） Swift - 使用socket进行通信（附聊天室样例） Swift - socket不定长消息发送接收的几种方法 （以聊天室为例） 通知推送 Swift - UserNotifications框架使用详解1（基本介绍，权限的申请与判断） Swift - UserNotifications框架使用详解2（发送本地通知） Swift - UserNotifications框架使用详解3（推送远程通知） Swift - UserNotifications框架使用详解4（通知的处理、回调、应用内展示） Swift - JPush极光推送的使用1（配置、简单的推送测试样例） Swift - UserNotifications框架使用详解5（Actionable可交互通知） Swift - UserNotifications框架使用详解6（ServiceExtension、多媒体内容推送） Swift - UserNotifications框架使用详解7（自定义通知详情视图） Swift - JPush极光推送的使用2（PHP调用服务接口给所有人发推送） Swift - JPush极光推送的使用3（根据Alias别名，给某个指定用户发推送） Swift - JPush极光推送的使用4（根据Tag标签，给同一类别用户发推送） Swift - JPush极光推送的使用5（发送通知时附带自定义参数） Swift - JPush极光推送的使用6（定时推送通知） Swift - JPush极光推送的使用7（发送自定义消息） Swift - 使用NotificationCenter发送通知，接收通知 加密、解密 Swift - 将图片、文件转成Base64编码字符串（Base64加密、解密） pod 'CryptoSwift', '~> 1.0' #Swift - 第三方加密库CryptoSwift使用详解 Swift - 使用RSA算法进行数据加密，解密以及数字签名 Swift - 如何实现字符串的HMAC_SHA1加密 Swift - 获取字符串的MD5值 弹窗、指示器、进度提示 Swift - 第三方透明指示器SwiftNotice使用详解 Swift - 第三方Alert弹出框组件（SCLAlertView）使用详解 Swift - 第三方透明指示器MBProgressHUD使用详解 Swift - 自定义UIAlertController的样式2（添加自定义视图） Swift - 自定义UIAlertController的样式1（修改标题、按钮的字体和颜色） 轮播图 Swift - 图片循环轮播组件的实现（附样例） 分页菜单显示 Swift - 分页菜单的实现（使用PagingMenuController库实现tab标签切换） 音频、视频 Swift - 使用AVKit播放本地视频，在线视频（AVPlayerViewController） Swift - 使用Media Player播放本地视频，在线视频 Swift - 制作一个在线流媒体音乐播放器（使用StreamingKit库） Swift - 制作一个录音机（声音的录制与播放） Swift - 使用AVPlayer制作一个音乐播放器 Swift - 使用ijkplayer框架播放直播视频1（RTMP/HTTP视频流播放） Swift - 使用ijkplayer框架播放直播视频2（RTSP视频流播放） Swift - 获取视频截图（本地视频、网络视频的缩略图） Swift - 视频录制教程1（调用摄像头录像，并保存到系统相册） Swift - 视频录制教程2（小视频拍摄，将多段视频进行合并） Swift - 视频录制教程3（设置拍摄窗口大小，录制正方形视频） Swift - 视频录制教程4（设置视频压缩质量、分辨率） 相册图片/视频选择、相机拍摄、保存到相册 Swift - 使用ALAssetsLibrary获取相簿里所有图片，视频（附样例） Swift - 监听照片库里的变化（自动获取最新添加的图片） Swift - 从相册中选择照片并上传（使用UIImagePickerController） Swift - 使用相机拍摄照片 Swift - 相册图片多选功能的实现 Swift - 从相册中选择视频（过滤掉照片，使用UIImagePickerController） Swift - 保存图片到系统相册（相机胶卷），并获取存放路径、缩略图 Swift - 从ALAsset中获取照片的原图并转换成NSData Swift - 使用Photos框架（PhotoKit）将图片保存到自定义相簿 选择器 PickerView Swift - 让UIPickerView里的选项文字自动换行（多行显示） Swift - UIPickerView无限循环滚动的实现（数据循环显示） Swift - 省市县三级联动功能的实现（使用UIPickerView选择框） 数据库、存储 Swift - 第三方SQLite库FMDB使用详解 Swift - 常用文件目录路径获取（Home目录，文档目录，缓存目录等） Swift - 文件，文件夹操作大全 Swift - 本地数据的保存与加载（使用NSCoder将对象保存到.plist文件） Swift - 使用Core Data进行数据持久化存储 Swift - 在已有项目上添加CoreData（之前创建时未勾选Use Core Data） Swift - 操作SQLite数据库（引用SQLite3库） Swift - SQLiteDB库新增的SQLTable功能详解（便于操作SQLite库） Swift - Realm数据库的使用详解（附样例） Swift - .plist文件数据的读取和存储 Swift - iCloud存储介绍 工具条 UIToolbar Swift - 工具条（UIToolbar）的用法 搜索 Swift - 实现带有搜索框的导航栏（将UISearchController集成到Navigation上） Swift - 使用UISearchController实现带搜索栏的表格 Swift - searchBar放在tableView外部，固定位置（点击消失问题解决） Swift - 修改UISearchControlle取消按钮的文字（默认为Cancel） Swift - 搜索条（UISearchBar）的用法 Swift - 修改搜索条（UISearchBar）中取消按钮的文字、颜色 Swift - 在表格头部添加一个带范围选择（scope bar）的搜索栏 导航栏 NavigationBar Swift - 在导航栏左侧或者右侧放置多个按钮 Swift - 将导航栏标题修改成自定义视图（图片、按钮、分段选择等） Swift - 修改导航栏的样式（文字颜色，背景颜色，背景图片） Swift - 修改导航栏“返回”按钮文字，图标 Swift - 实现带有搜索框的导航栏（将UISearchController集成到Navigation上） Swift - 导航栏标题下拉菜单的实现（BTNavigationDropdownMenu库） Swift - 实现下拉时背景图片放大效果（仿QQ个人资料页面） Swift - 导航栏滑动透明渐变效果的实现（透明度随视图滚动而改变） Swift - 导航栏背景全透明效果的实现（沉浸式效果） Swift - 去掉导航栏的半透明效果（元素被导航栏遮挡问题） Swift - edgesForExtendedLayout属性介绍（元素被导航栏遮挡问题） Swift - 当存在导航栏时，scrollview自动下移的问题解决 Swift - 让导航栏随页面一起移动，而不是淡入淡出 Swift - 自定义导航栏leftBarButtonItems导致滑动返回失效问题解决 Swift - 导航控制器（navigationController）全屏滑动返回功能实现 Swift - 导航栏标题文字太长，导致返回按钮文字消失问题解决 下拉/上拉 Swift - 导航栏标题下拉菜单的实现（BTNavigationDropdownMenu库） Swift - 实现下拉时背景图片放大效果（仿QQ个人资料页面） Swift - MJRefresh库的使用详解1（配置，及库自带的下拉刷新组件） Swift - MJRefresh库的使用详解2（创建自定义的下拉刷新组件） Swift - MJRefresh库的使用详解3（库自带的上拉加载组件） Swift - MJRefresh库的使用详解4（创建自定义的上拉加载组件） Swift - MJRefresh库的使用详解5（CollectionView上实现上拉下拉刷新） Swift - MJRefresh库的使用详解6（WebView上实现下拉刷新） Swift - MJRefresh库的使用详解7（ScrollView上实现上拉下拉刷新） Swift - 表格tableView上拉加载新数据的功能实现（附样例） Swift - 下拉刷新数据的功能实现（使用UIRefreshControl） Swfit - 使用自定义的UIRefreshControl下拉刷新界面 Swift - UIRefreshControl下拉时，刷新时分别使用不同的描述文字 Swift - 下拉刷新数据的功能实现（使用UIRefreshControl） 状态栏 Swift - 动态改变状态栏statusBar文字颜色（preferredStatusBarStyle无效问题） Swift - 修改顶部状态栏（statusBar）文字颜色为白色 Swift - 隐藏状态栏（statusBar）的两种方法 Swift - 点击状态栏使tableView返回顶部（附：状态栏点击事件响应） TabBar Swift - 标签条（UITabBar）标签页控制器（UITabBarController）用法 Swift - 让TabBarItem的图标和文字在iPad下仍然是上下排列 Swift - 让标签栏按钮UITabBarItem图片居中（没有文字） Swift - 标签栏按钮UITabBarItem样式修改（图标文字尺寸，颜色等） 输入框、字符串、文本框、键盘 Swift - 去除UITextView的内边距（去掉Padding） Swift - 在数字键盘上添加自定义按钮（增加return键） Swift - 键盘出现后自动改变页面布局，防止下方元素被键盘遮挡 Swift - 解决表格中TextField,TextView编辑时，输入框被键盘遮挡的问题 Swift - 输入框抖动效果的实现（扩展UIView、支持所有UI组件） Swift - 手机号码输入框的实现（手机号验证、格式化显示） Swift - 修改UITextView中链接的样式（链接颜色、下划线样式） Swift - 让textview支持特殊标签点击响应（@标签、#标签） Swift - 给UITextView添加自定义链接，以及链接的点击响应 Swift - 使用NSDataDetector进行URL验证，及提取字符串中所有链接 Swift - 字符串的替换与过滤（附：过滤emoji表情符号） Swift - 去除字符串前后的空白（trim方法） Swift - 实现URL字符串的编码与解码（urlEncoded、urlDecoded） Swift - 扩展String增加字符串截取方法subString(start:, length:) Swift - 在字符串中查找另一字符串首次出现的位置（或最后一次出现位置） Swift - 文本框textView图文混排的实现（附样例） Swift - 将字符串拆分成数组（把一个字符串分割成字符串数组） 日期、时间、日历事件、定时器 Swift - 第三方日期处理库SwiftDate使用详解 Swift - 实现公历、农历日期之间的相互转换 Swift - 获取本周（或指定日期所在周）的第一天、最后一天日期 Swift - 获取（当月、当年、任意月|年）的第一天、最后一天日期 Swift - 计算当月、任意月一共有多少天 Swift - 获取当前时间的时间戳（时间戳与时间互相转换） Swift - 实现日期（Date）与字符串（String）的相互转换 Swift - 第三方日历组件CVCalendar使用详解 Swift - 判断两个日期是不是同一天的几个办法 Swift - 使用EventKit获取系统日历事件，添加事件 Swift - 获取日历中所有的事件并显示在表格中（带有搜索功能） Swift - 时间控制器NSTimer（每隔一定时间执行某个函数） UIImage 图片、截图、Gif Swift - 使用Image Literal实现代码中图片的智能提示（Xcode自带功能） Swift - 图片处理库ImageHelper详解（扩展UIImage,UIImageView） Swift - 圆形图片的生成及显示（两种办法） Swift - 实现图片（UIImage）的水平翻转(镜像)，垂直翻转 Swift - 截图功能的实现1（通过扩展实现将UIView转成UIImage) Swift - 截图功能的实现2（使用SwViewCapture库实现滚动视图的截屏） Swift - 获取视频截图（本地视频、网络视频的缩略图） Swift - 实现下拉时背景图片放大效果（仿QQ个人资料页面） Swift - 使用resizableImage拉伸图片的指定部分（九宫格拉伸） Swift - 设置UIView的背景图片（平铺、拉伸） Swift - 改变UIImage图片的大小尺寸，或按比例缩放 Swift - 将图片裁剪成指定的长宽比例（自动裁掉多余部分，确保图片不变形） Swift - 将图片缩放至指定尺寸（自动裁掉多余部分，确保图片不变形） Swift - 将图片、文件转成Base64编码字符串（Base64加密、解密） Swift - 实现图片全屏展示功能（可左右滑动切换图片） Swift - 抠图，及图片合成功能的实现（适用于纯色背景） Swift - 去处图片的白色、黑色背景（使UIImage背景透明） Swift - 使用OpenCV2进行图片拼接（将多张照片合并成全景图） Swift - 人脸检测，以及人脸打码的功能实现（附样例） Swift - 使用CIPixellate给图片打码（全图马赛克，部分区域马赛克） Swift - 自动优化照片，改善图像质量 Swift - 给图片（imageView）添加阴影边框 Swift - 给图片添加滤镜效果（棕褐色老照片滤镜，黑白滤镜） Swift - 给图片添加图片水印（图片上绘制另一张图，并可设透明度） Swift - 给图片添加文字水印（图片上写文字，并可设置位置和样式） Swift - 使用CGBlendMode改变UIImage颜色 Swift - 实现图片的模糊效果（高斯模糊滤镜） Swift - GIF动态图片的播放（分别使用SwiftGif和YLGIFImage-Swift） Swift - 微信聊天群头像实现 （群聊的组合头像） Swift - QQ讨论组头像的实现 （多人聊天的组合头像） 颜色 UIColor Swift - 使用Color Literal实现代码中颜色的智能提示（Xcode自带功能） Swift - 获取UIColor的HSV/HSB值（Hue色相、S饱和度、B亮度） Swift - 获取图片UIImage指定像素的颜色值 Swift - 十六进制颜色字符串与UIColor之间的相互转换（附样例） Swift - 计算一个颜色的反色（UIColor的反色） Swift - 生成随机颜色（扩展UIColor） 动画、渐变 Swift - 动画效果的实现方法总结（附样例） Swift - CAGradientLayer使用详解 Swift - 沿路径运动的动画实现（圆形、曲线、直线等路径轨迹） Swift - 刮刮卡效果的实现（附样例） Swift - 使用CAKeyframeAnimation实现关键帧动画 Swift - 使用CABasicAnimation实现动画效果 Swift - 通过设置视图的transform属性实现动画 Swift - 使用CATransition制作过渡动画（页面切换转场效果） 绘图 Swift - Core Graphics绘图框架详解1（绘制线条） Swift - Core Graphics绘图框架详解2（绘制图形） Swift - Core Graphics绘图框架详解3（绘制渐变、填充渐变色） Swift - Core Graphics绘图框架详解4（绘制图片、图形变换） Swift - Core Graphics绘图框架详解5（绘制文字、文字复杂排版） Swift - 捕获用户签名（用户在屏幕上手写签名，并生成图片） Swift - 在UIView上绘制图形阴影 Swift - 在UIView上使用自定义曲线绘制复杂图形（贝塞尔曲线） Swift - 在UIView上使用多条子路径绘制图形 Swift - 在UIView上绘制矩形（直角，圆角，带边框） Swift - 设置圆角样式的图片，圆角样式的按钮 列表，表格 UITableView Swift - SwiftForms的使用详解 Swift - 表格UITableView的plain、grouped两种样式详解（附分组头悬停） Swift - 两个 tableView 间联动功能的实现（左侧分类列表，右侧商品列表） Swift - tableView与collectionView联动功能的实现（左侧大分类，右侧小分类） Swift - 实现表格tableViewCell里嵌套collectionView（附样例） Swift - 单元格滑动按钮库SwipeCellKit使用详解 Swift - 自定义tableViewCell滑动事件按钮 Swift - 表格section header增加滑动删除功能（删除该分区下所有cell） Swift - 设置表格cell的分隔线边距（分割线与边框距离） Swift - 实现tableView中section分组圆角效果1（没有分区头、尾的情况） Swift - 给tableView中的单元格设置左右边距（margin left、margin right） Swift - 去除tableView在编辑模式下的自动缩进（单元格头部不留空白） Swift - 通过代码让tableview左滑出现的删除按钮消失 Swift - 在单元格里的按钮点击事件中获取对应的cell以及indexPath Swift - 在TableViewCell中获取父TableView（附：获取任意类型的父View） Swift - 时间轴效果的实现（附样例） Swift - 实现tableView静态单元格与动态单元格混合使用（附样例） Swift - 使用xib自定义表格中分组section的header和footer Swift - 修改tableView分组（section）头部、尾部的字体颜色和大小 Swift - tableView单元格高度自适应1（默认单元格，只有1个Label标签） Swift - tableView单元格高度自适应2（自定义单元格，有2个Label标签） Swift - tableView单元格高度自适应3（图片宽度固定，高度自适应） Swift - tableView的单元格多选功能的实现（获取多选值、多选删除） Swift - 可编辑表格样例（可直接编辑单元格中内容、移动删除单元格） Swift - 修改表格选中单元格（Cell）的样式（背景色，文字颜色） Swift - 在ViewController中表格使用静态单元格（Static Cell） Swift - 表格图片加载优化（拖动表格时不加载，停止时只加载当前页图片） Swift - 实现点击UITableView单元格时自动展开单元格 Swift - 给表格UITableView添加索引功能（快速定位） Swift - 给表格TableView添加页眉和页脚 Swift - 给表格添加移动单元格功能（拖动行） Swift - 动态添加删除TableView的单元格（以及内部元件） Swift - 使用TableView的静态单元格进行页面布局 Swift - 列表项尾部附件点击响应（感叹号，箭头等） Swift - 给表格添加Cell的显示动画（3D缩放） Swift - 给表格添加编辑功能（删除，插入） Swift - 将表格UITableView滚动条移动到底部 Swift - 自定义单元格实现微信聊天界面 Swift - 给表格的单元格UITableViewCell添加图片，详细文本标签 Swift - 使用表格组件（UITableView）实现分组列表 Swift - 使用表格组件（UITableView）实现单列表 UICollectionView 网格视图 Swift - 使用网格（UICollectionView）进行流布局 Swift - 使用网格（UICollectionView）的自定义布局实现复杂页面 Swift - 让CollectionView里的Section分别设置不同的背景色 Swift - tableView与collectionView联动功能的实现（左侧大分类，右侧小分类） Swift - 实现表格tableViewCell里嵌套collectionView（附样例） Swift - 使用CollectionView实现图片Stack层叠效果 Swift - 使用CollectionView实现图片Gallery画廊效果（左右滑动浏览图片） Swift - 实现UICollectionView中元素的环形布局 Swift - 动态切换UICollectionView的layout布局（附样例） Swift - 带有多section分区的collectionView的使用样例 Swift - 实现UICollectionView分组头悬停效果（方法1：使用自定义布局） Swift - 实现UICollectionView分组头悬停效果（方法2：使用iOS9新特性） Swift - 多列表格组件的实现（样例1：基本功能的实现） Swift - 多列表格组件的实现（样例2：带排序功能） Swift - 多列表格组件的实现（样例3：表头、列头固定） Swift - 多列表格组件的实现（样例4：表格样式美化） Swift - 实现内边框为1像素的collectionView（内间距为1px） Swift - 异步加载表格数据，内容不能及时显示的问题解决 Swift - 设置网格UICollectionView的单元格间距 UIScrollView wift - 调整UIScrollView的滑动速度（适用于tableView、collectionView） Swift - 滚动视图（UIScrollView）的用法 StackView Swift - UIStackView使用详解 滑块 Swift - 实现自定义的Slider滑块组件（轨道上带有刻度标记） 地图、定位 Swift - 使用CoreLocation实现定位（经纬度、海拔、速度、距离等） Swift - 使用CoreLocation获取设备方向（真实方向，磁极方向） Swift - 经纬度位置坐标与真实地理位置相互转化 Swift - 使用MapKit显示地图，并在地图上做标记 Swift - 百度静态地图的使用样例（显示当前位置地图，可调整缩放级别） Swift - 获取、设置MKMapView的地图缩放级别（zoomlevel） Swift - 百度地图SDK的配置和使用（附样例） Swift - 集成百度地图的周边雷达功能（附样例） 分享 Swift - 腾讯官方SDK的配置及使用（分享到QQ空间、分享到好友） Swift - 使用友盟实现应用的统计分析 Swift - 发送消息（文本,图片,文件等）给微信好友或分享到朋友圈 Swift - 自定义UIActivity分享 二维码、条形码 Swift - 二维码QRCode的读取（从图片读取 ，或通过摄像头扫描） Swift - 使用AVFoundation实现条形码扫描（附：拉近镜头改善读取） Swift - 使用CIFilter生成二维码图片（QRCode） 电话、短信、邮件、通讯录 Swift - 实现拨打电话 Swift - 邮件发送功能的实现 Swift - 短信发送功能的实现 Swift - 添加、修改、删除通讯录联系人 Swift - 访问通讯录联系人（使用纯代码实现） Swift - 访问通讯录联系人（使用系统提供的通讯录交互界面） 设备信息、传感器、网络连接状态、系统声音服务、震动 Swift - 手机摇晃的监测和响应 Swift - 加速传感器（CoreMotion）的用法，小球加速运动并反弹样例 Swift - 判断设备方向（或监听设备方向的改变） Swift - 判端网络连接状态，连接类型（3G还是Wifi） Swift - 系统声音服务的使用（播放声音，提醒，震动） Swift - 使用CoreTelephony获取运营商信息、网络制式（4G、3G、2G） Swift - 获取应用名称、应用版本、设备型号、系统版本等信息 图表 Swift - 第三方图表库AAInfographics使用详解 Swift - 第三方图表库Charts使用详解 侧滑菜单 Swift - 第三方侧栏菜单组件SideMenu使用详解 Swift - 侧滑菜单的实现（样例2：仿QQ，菜单带缩放效果） Swift - 侧滑菜单的实现（样例1：主页向右滑动，露出下方菜单页） 国际化、打包、发布 Swift - iOS应用的国际化与本地化 Swift - 在fir.im上发布程序（免费的应用内测托管平台） Swift - 企业账号进行IPA的打包、分发、下载安装的详细流程 Swift - 真机调试正常，打包成IPA安装后一启动就闪退的问题解决 UI控件、组件、界面搭建、画界面 Swift - XIB结合UIView制作自定义组件（xib加载绘制UIView） Swift - 继承UIView实现自定义可视化组件（附记分牌样例） Swift - 在StoryBoard中添加使用自定义组件（自定义进度条组件为例） Swift - 通过UIView对象找到其所在的UIViewController Swift - UIViewController生命周期详解（附：VC相关方法介绍） Swift - 使用addSubview()方法将StoryBoard中的视图加载进来 Swift - iOS中各种视图控制器（View Controller）的介绍 Swift - 生成各种控件的工厂类（包含标签，按钮，输入框等） Swift - 字体图标的使用及样例（使用Font Awesome字体库，非图片） 其他待分类 Swift - 异步编程库PromiseKit使用详解 Swift - 使用Highlightr库实现语法高亮、代码高亮展示（支出实时编辑渲染） Swift - 正则表达式的使用（附用户名、邮箱、URL等常用格式验证） Swift - 封装一个正则表达式工具类（附：正则替换、正则匹配样例） Swift - 判断UILabel文字是否被截断（是否有多余文字被省略） Swift - 日志框架XCGLogger的使用详解 Swift - 实现日志输出的封装1（显示出调用的文件名、方法、行号） Swift - 实现日志输出的封装2（同步记录到文件中去） Swift - 使用Carthage来安装管理第三方库 Swift - 使用EventKit操作\"提醒事项\"（1、查询出所有提醒） Swift - 使用EventKit操作\"提醒事项\"（2、新增、修改、删除提醒） Swift - 使用OpenWeatherMap获取天气的实时数据、预测数据 Swift - 实现毛玻璃效果（Blur、模糊、虚化背景元素） Swift - URL schemes的使用样例（如：在Safari中打开App） Swift - 打开第三方应用，并传递参数（附常用App的URL Scheme） Swift - QQ授权登录，并获取个人信息（用户资料） Swift - 使用AirPrint进行打印 Swift - 使用AirPrint打印报表（表格） Swift - 代码设置AirPrint打印的纸张大小（打印尺寸） Swift - UIPasteboard剪贴板的使用详解（复制、粘贴文字和图片） Swift - 使用Segmented Control进行多个视图View的切换 Swift - 使用LINQ操作数组/集合（附Swift的LINQ扩展、及替代方法） Swift - 人脸检测，以及人脸打码的功能实现（附样例） Swift - 使用HTML5进行iOS开发（将HTML5打包成iOS应用） Swift - 重写UIKit框架类的init初始化方法（以UITabBarController为例） Swift - 触摸事件（点击，移动，抬起等）说明及用例 Swift - 各种手势检测大全（UIGestureRecognizer及其子类） Swift - 项目部署配置（支持的系统，设备和状态条样式等） Swift - 二进制，八进制，十六进制的表示方法 Swift - 下标脚本方法介绍及实例 Swift - Framework的制作与使用教程1（纯Swift实现） Swift - Framework的制作与使用教程2（引用第三方库） Swift - Framework的制作与使用教程3（与Objective-C混合编程） "},"知识库/iOS 知识点/常用功能和第三方库/XLForm.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/XLForm.html","title":"表单 - XLForm","keywords":"","body":"XLForm 将要显示表单的视图控制器设置为XLForm的子类 创建表 设置表标题 创建组 设置组标题 创建行 设置行标题和行值 取行标题和输入的值 行为按钮 row = [XLFormRowDescriptor formRowDescriptorWithTag:@\"submitButton\" rowType:XLFormRowDescriptorTypeButton title:@\"提交\"]; row.action.formSelector = @selector(submitTapped); [section addFormRow:row]; 取表单中所有行的值 formVC.formValues 设置行高 设置表单背景颜色 - (void)viewDidLoad { [super viewDidLoad]; self.tableView.backgroundColor = UIColor.whiteColor; } 设置组头自定义视图 设置组头高度 设置组尾自定义视图 设置组尾高度 自定义Row的cell 步骤 自定义cell要继承自XLFormBaseCell类 重写三个方法 +(void)load 【非必须】可以在这里，在主表单中注册此自定义cell以及对应的ID - (void)configure 【必须】在这里进行UI搭建和配置 - (void)update 【必须】外面给控件赋值以后就会调用这个？可以在这里进行赋值后的操作 在创建row时 必须使用自定义cell的ID(type) row = [XLFormRowDescriptor formRowDescriptorWithTag:@\"phone\" rowType:kInputInfoCellType]; 必须设置row的cellClass为自定义cell，否则会出现错误 row.cellClass = [ECInputInfoCell class]; 从自定义的cell中将 控件的值 传出去 在需要将值传出去的地方，将值存到self.rowDescriptor.value中，value应该是id类型的，所以可以直接赋值传一个值，也可以以数组或者字典的形式传出去多个值。 从自定义的cell中将 点击事件 传出去 使用 代理 的方式 为cell创建代理协议，在其中声明要传出去的事件方法 为cell设置 weak 的 delegate属性 在需要传递点击事件的时候，调用 delegate 中声明的相应方法 在创建row的时候，通过 [row.cellConfig setObject:self forKey:@\"delegate\"]; 将formVC设置为自定义cell的代理 在 formVC 中实现自定义 cell 中的代理方法 这样自定义cell中的事件就能传递出来了 自定义cell代码片段 ``` // 自定义cell.h文件 @class ECInputInfoCell; @protocol ECInputInfoCellDelegate /// 用户点击按钮(验证码按钮回调) /// @param cell cell /// @param btn 按钮 (void)ECInputInfoCell:(ECInputInfoCell )cell verifyCodeButtonTapped:(UIButton )btn; /// 输入框中文字变化时调用 /// @param cell cell /// @param textField 输入框 (void)ECInputInfoCell:(ECInputInfoCell )cell textFieldEditingChanged:(UITextField )textField; /// 输入框输入完毕，释放了第一响应者以后调用 /// @param cell cell /// @param textField 输入框 (void)ECInputInfoCell:(ECInputInfoCell )cell textFieldDidEndEditing:(UITextField )textField; @end // 自定义cell.m文件 @interface ECInputInfoCell () @property (nonatomic, strong) UILabel leftLabel; // 左边的文本框 @property (nonatomic, strong) UITextField rightTextField; // 右边的输入框 @property (nonatomic, strong) UIButton btn; // 按钮 @property (nonatomic, strong) UIView separatorView; // 分割线 @property (nonatomic, weak)id delegate; // 代理 @end @implementation ECInputInfoCell +(void)load { // 在主表单中注册此自定义cell以及对应的ID [XLFormViewController.cellClassesForRowDescriptorTypes setObject:[ECInputInfoCell class] forKey:kInputInfoCellType]; } // 这个方法是用来设置属性的 必须重写 类似于初始化的属性不变的属性进行预先配置 - (void)configure { [super configure]; self.selectionStyle = UITableViewCellSelectionStyleNone;// 取消选中时cell为灰色 [self setupUI]; // 搭建UI } /// 搭建界面 - (void)setupUI { // 添加文本框 [self.contentView addSubview:self.leftLabel]; // 添加按钮 [self.contentView addSubview:self.btn]; // 添加输入框 [self.contentView addSubview:self.rightTextField]; self.rightTextField.delegate = self; // 添加分割线 [self.contentView addSubview:self.separatorView]; // 设置约束 [self setupConstraints]; } /// 设置约束 - (void) setupConstraints { [self.leftLabel mas_makeConstraints:^(MASConstraintMaker *make) { make.leading.mas_equalTo(30); make.bottom.mas_equalTo(-4); make.width.mas_equalTo(80); }]; [self.rightTextField mas_makeConstraints:^(MASConstraintMaker *make) { make.leading.equalTo(self.leftLabel.mas_trailing).offset(12.5); make.trailing.equalTo(self.btn.mas_leading); make.bottom.mas_equalTo(-4); }]; [self.btn mas_makeConstraints:^(MASConstraintMaker *make) { make.size.mas_equalTo(CGSizeMake(76, 23)); make.trailing.mas_equalTo(-30); make.bottom.mas_equalTo(-4); }]; [self.separatorView mas_makeConstraints:^(MASConstraintMaker *make) { make.leading.mas_equalTo(30); make.height.mas_equalTo(0.5); make.trailing.mas_equalTo(-30); make.bottom.mas_equalTo(0.5); }]; } // 这个方法是用来进行更新的，外面给唯一的字段Value设定值就好了 通过self.rowDescriptor.value的值变化来进行更新 - (void)update { [super update]; // 接收值并赋给控件 self.leftLabel.text = self.rowDescriptor.title; // leftLabel 接到值以后，可以用来判断 if ([self.leftLabel.text isEqualToString:@\"短信验证码\"]) { [self.btn setHidden:NO]; } if ([self.leftLabel.text isEqualToString:@\"手机号码\"]) { self.rightTextField.keyboardType = UIKeyboardTypeNumberPad; } if ([self.leftLabel.text isEqualToString:@\"登录密码\"]) { self.rightTextField.secureTextEntry = YES; } } /// 用户点击验证码按钮 /// @param sender 验证码按钮 - (void)btnTapped:(UIButton *)sender { [self.delegate ECInputInfoCell:self verifyCodeButtonTapped:self.btn]; } /// 文本框中的文字变化时调用 - (void)textFieldValueDidChanged:(UITextField *)textField { // 在这里把自定义cell获取到用户输入的信息传递出去【去除空格和回车】 self.rowDescriptor.value = [self.rightTextField.text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceAndNewlineCharacterSet]]; [self.delegate ECInputInfoCell:self textFieldEditingChanged:textField]; } /// 文本框已经结束编辑(已经释放第一响应者) - (void)textFieldDidEndEditing:(UITextField *)textField { [self.delegate ECInputInfoCell:self textFieldDidEndEditing:textField]; } - (UILabel *)leftLabel { if (!_leftLabel) { _leftLabel = [UILabel new]; _leftLabel.font = FONT15; _leftLabel.textColor = OWNER_HOMEVIEW_CELL_TITLE; } return _leftLabel; } - (UITextField *)rightTextField { if (!_rightTextField) { _rightTextField = [UITextField new]; _rightTextField.font = FONT15; [_rightTextField addTarget:self action:@selector(textFieldValueDidChanged:) forControlEvents:UIControlEventEditingChanged]; } return _rightTextField; } - (UIView *)separatorView { if (!_separatorView) { _separatorView = [UIView new]; _separatorView.backgroundColor = QUOTATION_SPEC_GRAY; } return _separatorView; } - (UIButton *)btn { if (!_btn) { _btn = [UIButton new]; [_btn setTitle:@\"验证码\" forState:UIControlStateNormal]; _btn.backgroundColor = UIColorFromRGB(0x326EF0); _btn.layer.cornerRadius = 3.0; _btn.titleLabel.font = FONT12; [_btn setHidden:YES]; [_btn addTarget:self action:@selector(btnTapped:) forControlEvents:UIControlEventTouchUpInside]; } return _btn; } @end ``` formVC ``` // // ECModifyPhoneNumViewController.m // cloudExchange // // Created by Joya Wang on 2020/6/2. // Copyright © 2020 高武. All rights reserved. // import \"ECModifyPhoneNumViewController.h\" import \"ECInputInfoCell.h\" import \"ECBaseRequest.h\" import \"ECBaseResponse.h\" import \"NSString+PJR.h\" @interface ECModifyPhoneNumViewController () { ECBaseRequest *_verifyCodeRequest; ECBaseRequest *_modifyPhoneNumRequest; } @end @implementation ECModifyPhoneNumViewController (instancetype)initWithNibName:(NSString )nibNameOrNil bundle:(NSBundle )nibBundleOrNil { self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; if (self){ [self initializeForm]; } return self; } (id)initWithCoder:(NSCoder *)aDecoder { self = [super initWithCoder:aDecoder]; if (self){ [self initializeForm]; } return self; } (void)initializeForm { // Implementation details covered in the next section. XLFormDescriptor form; // 列表 XLFormSectionDescriptor section; // 分组 XLFormRowDescriptor * row; // 列 form = [XLFormDescriptor formDescriptorWithTitle:@\"\"]; // 设置标题 // 第一组 section = [XLFormSectionDescriptor formSection]; // section.title = @\"更改手机号\"; [form addFormSection:section]; // 手机号码 row = [XLFormRowDescriptor formRowDescriptorWithTag:@\"phone\" rowType:kInputInfoCellType]; row.cellClass = [ECInputInfoCell class]; row.title = @\"手机号码\"; row.height = 30.f; [row.cellConfigAtConfigure setObject:@\"请输入新的手机号码\" forKey:@\"rightTextField.placeholder\"]; [row.cellConfig setObject:self forKey:@\"delegate\"]; [section addFormRow:row]; // // // 短信验证码 row = [XLFormRowDescriptor formRowDescriptorWithTag:@\"mobileCode\" rowType:kInputInfoCellType]; row.cellClass = [ECInputInfoCell class]; row.title = @\"短信验证码\"; row.height = 60.f; [row.cellConfigAtConfigure setObject:@\"请输入验证码\" forKey:@\"rightTextField.placeholder\"]; [row.cellConfig setObject:self forKey:@\"delegate\"]; [section addFormRow:row]; // 登录密码 row = [XLFormRowDescriptor formRowDescriptorWithTag:@\"oldPwd\" rowType:kInputInfoCellType]; row.cellClass = [ECInputInfoCell class]; row.title = @\"登录密码\"; row.height = 60.f; [row.cellConfigAtConfigure setObject:@\"请输入原登录密码\" forKey:@\"rightTextField.placeholder\"]; [row.cellConfig setObject:self forKey:@\"delegate\"]; [section addFormRow:row]; // 身份证号 row = [XLFormRowDescriptor formRowDescriptorWithTag:@\"cardNo\" rowType:kInputInfoCellType]; row.cellClass = [ECInputInfoCell class]; row.title = @\"身份证号\"; row.height = 60.f; [row.cellConfigAtConfigure setObject:@\"请输入身份证号\" forKey:@\"rightTextField.placeholder\"]; [row.cellConfig setObject:self forKey:@\"delegate\"]; [section addFormRow:row]; self.form = form; } // MARK: - 方法监听 /// 点击提交 (void)submitTapped:(UIButton )sender { // 获取表单所有的值 NSDictionary values = [self formValues]; NSLog(@\"%@\", values); NSString phone = values[@\"phone\"]; // 手机号 NSString oldPwd = values[@\"oldPwd\"]; // 密码 NSString mobileCode = values[@\"mobileCode\"]; // 验证码 NSString cardNo = values[@\"cardNo\"]; // 身份证号 if (phone.length == 0 || phone.length [MBProgressHUD showTipMessageInWindow:@\"请输入正确的手机号\"]; }else if (oldPwd.length == 0) { [MBProgressHUD showTipMessageInWindow:@\"请输入登录密码\"]; }else if (oldPwd.length [MBProgressHUD showTipMessageInWindow:@\"密码错误\"]; }else if (mobileCode.length != 4) { [MBProgressHUD showTipMessageInWindow:@\"请输入正确的验证码\"]; }else if (cardNo.length [MBProgressHUD showTipMessageInWindow:@\"请输入正确的身份证号\"]; } else{ // 提交修改 [self doModifyPhoneNumRequestWithUID:[ECUserSingleton shareInstance].getUserUid]; } } /// 输入框中文字变化时调用 (void)ECInputInfoCell:(ECInputInfoCell )cell textFieldEditingChanged:(UITextField )textField { // if (cell.rowDescriptor.title isEqualToString:@\"\") // NSLog(@\"正在输入: %@\", textField.text); } /// 输入框输入完毕时调用，即释放第一响应者时 (void)ECInputInfoCell:(ECInputInfoCell )cell textFieldDidEndEditing:(UITextField )textField { // NSLog(@\"%@ 输入了: %@\", cell.rowDescriptor.title,textField.text); } /// 点击获取验证码 (void)ECInputInfoCell:(ECInputInfoCell )cell verifyCodeButtonTapped:(UIButton )btn { WS(weakSelf); [self doSendCodeRequestPhone:self.formValues[@\"phone\"] type:9 uid:[ECUserSingleton shareInstance].getUserUid withCompletionBlock:^(BOOL isSuccess) { if (isSuccess) { // 按钮变灰，120s后恢复蓝色 [weakSelf sentPhoneCodeTimeMethodWithButton:btn]; } }]; } /// 发送验证码 (void)doSendCodeRequestPhone:(NSString )phoneNumber type:(NSInteger)type uid:(NSString )uid withCompletionBlock:(void (^) (BOOL isSuccess))completionBlock{ NSMutableDictionary *params = [NSMutableDictionary new]; [params setValue:phoneNumber forKey:@\"phone\"]; [params setValue:@(type) forKey:@\"type\"]; _verifyCodeRequest = [[ECBaseRequest alloc]initWithinterfaceName:sendSmsInterFace andmethod:REQUEST_TYPE_POST andPhotos:nil andParams:params andResult:^(ECBaseResponse response, NSError error) { if (kRequestSuccess) { completionBlock(YES); [MBProgressHUD showTipMessageInWindow:[NSString stringWithFormat:@\"验证码发送%@\", response.msg]]; }else { [MBProgressHUD showTipMessageInWindow:[NSString stringWithFormat:@\"验证码发送%@\", response.msg]]; } }]; } /// 提交进行手机修改 (void)doModifyPhoneNumRequestWithUID:(NSString )uid { NSMutableDictionary params = [[NSMutableDictionary alloc] initWithDictionary:self.formValues]; // 取出密码 NSString *oldPwd = params[@\"oldPwd\"]; // 密码 // 加密后存入 params[@\"oldPwd\"] = [oldPwd getRSAEncryptor]; // 存入加密后的密码 _modifyPhoneNumRequest = [[ECBaseRequest alloc]initWithinterfaceName:modifyPhoneNumberWithID(uid) andmethod:REQUEST_TYPE_PUT andPhotos:nil andParams:params andResult:^(ECBaseResponse response, NSError error) { if (kRequestSuccess) { [MBProgressHUD showTipMessageInWindow:[NSString stringWithFormat:@\"更改手机号%@\", response.msg]]; // 返回到主界面 [self.navigationController popViewControllerAnimated:YES]; }else { [MBProgressHUD showTipMessageInWindow:[NSString stringWithFormat:@\"%@\", response.msg]]; } }]; } - (void)sentPhoneCodeTimeMethodWithButton:(UIButton *)btn { //倒计时时间 - 120S __block NSInteger timeOut = 119; //执行队列 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //计时器 -》 dispatch_source_set_timer自动生成 dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); dispatch_source_set_event_handler(timer, ^{ if (timeOut "},"知识库/iOS 知识点/常用功能和第三方库/AFNetworking.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/AFNetworking.html","title":"网络 - AFNetworking","keywords":"","body":"AFNetworking 使用 获取请求信息和响应信息 ```objc [manager GET:requestUrl parameters:request.requestParams progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { [request requestCompletionCallback:task responseObject:responseObject]; self.infoDict[@\"请求URL\"] = task.originalRequest.URL; self.infoDict[@\"请求出错信息\"] = error; self.infoDict[@\"响应体\"] = responseObject; self.infoDict[@\"请求方式\"] = task.originalRequest.HTTPMethod; NSHTTPURLResponse *rp = (NSHTTPURLResponse *)task.response; self.infoDict[@\"响应状态码\"] = @([rp statusCode]); self.infoDict[@\"请求头信息\"] = task.originalRequest.allHTTPHeaderFields; self.infoDict[@\"请求正文信息\"] = task.originalRequest.allHTTPHeaderFields; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { [request requestFailedCallback:task error:error]; }]; - **AFURLSessionManager** - **AFHTTPSessionManager** - GET登录 - POST登录 - 下载 > 返回存储文件的路径URL > > 获取进度：对progress的fractionCompleted进行KVO > > 断点续传 - 上传 - 当从网络获取数据时，显示菊花 ```objc [[AFNetworkActivityIndicatorManager sharedManager] setEnabled:YES]; 设置缓存文件夹名称和缓存大小 // 设置缓存 /* 内存缓存: 5M 磁盘缓存: 10M 缓存文件夹名称: joyaImages */ NSURLCache *cache = [[NSURLCache alloc] initWithMemoryCapacity:1024*1024*5 diskCapacity:1024*1024*10 diskPath:@\"joyaImages\"]; [NSURLCache setSharedURLCache:cache]; NSURLSessionDataTask responseSerializer AFJSONResponseSerializer 默认初始化器是JSON [AFHTTPResponseSerializer serializer] 而百度返回的是HTML，所以需要设置为AFHTTPResponseSerializer responseObject requestSerializer AFJSONRequestSerializer serializer 设置请求头 // // ViewController.m // Day06 - AFNetworking演示 // // Created by Joya Wang on 2020/1/28. // Copyright © 2020 Joya Wang. All rights reserved. // #import \"ViewController.h\" #import \"AFHTTPSessionManager.h\" #import \"JLVideo.h\" @interface ViewController () @property (nonatomic, strong) JLVideo *video; @property (nonatomic, copy) NSMutableString *mString; @property (nonatomic, strong) NSMutableArray *videos; @end @implementation ViewController - (NSMutableString *)mString { if (!_mString) { _mString = [NSMutableString string]; } return _mString; } - (NSMutableArray *)videos { if (!_videos){ _videos = [NSMutableArray arrayWithCapacity:10]; } return _videos; } - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event { [self getXML]; } // 发送GET请求，获取JSON文件响应 - (void) get1 { [[AFHTTPSessionManager manager] GET:@\"http://127.0.0.1/Vocabularies.json\" parameters:nil headers:nil progress:^(NSProgress * _Nonnull downloadProgress) { } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@\"%@\", responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if (error) { NSLog(@\"发送GET请求出错: %@\", error); } }]; } // 发送GET请求，获取JSON文件响应(将用户名和密码以URL参数形式传入登录) - (void) get2 { [[AFHTTPSessionManager manager] GET:@\"http://127.0.0.1/php/login.php\" parameters:@{@\"username\":@\"admin\", @\"password\" : @\"123\"} headers:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@\"%@\", responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if (error) { NSLog(@\"发送GET请求错误: %@\", error); } }]; } // 发送POST请求，获取JSON文件响应(将用户名和密码以参数形式传入请求体登录) - (void) post { [[AFHTTPSessionManager manager] POST:@\"http://127.0.0.1/php/login.php\" parameters:@{@\"username\":@\"admin\", @\"password\":@\"123456\"} headers:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@\"%@\", responseObject); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if (error) { NSLog(@\"发送POST请求失败: %@\", error); } }]; } // 下载 - (void) download { NSURL *url = [NSURL URLWithString:@\"http://127.0.0.1/v.mp4\"]; NSURLRequest *request = [NSURLRequest requestWithURL:url]; [[[AFHTTPSessionManager manager] downloadTaskWithRequest:request progress:^(NSProgress * _Nonnull downloadProgress) { NSLog(@\"%@\", downloadProgress); // 使用KVO实时观察downloadProgress的属性的变化 /* 参数1: 被观察的属性属于的对象 参数2: 要被观察的属性 参数3 context: 要传给观察的方法的参数 */ [downloadProgress addObserver:self forKeyPath:@\"fractionCompleted\" options:NSKeyValueObservingOptionNew context:nil]; } destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) { NSLog(@\"文件临时路径: %@\", targetPath); // 创建要保存文件的地址 NSString *filePath = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:response.suggestedFilename]; // 创建FileURL并返回 NSURL *url = [[NSURL alloc] initFileURLWithPath:filePath]; return url; } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) { if (filePath) { NSLog(@\"下载成功: %@\", filePath); } if(error) { NSLog(@\"下载文件出错: %@\", error); } }] resume]; } // 观察某对象的属性变化调用的方法 /* 参数keyPath: 观察的对象被观察的属性 参数object: 观察的对象 参数change: 观察的属性发生的变化 参数context: 对应上面的context，传过来的参数 */ - (void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if ([object isKindOfClass:[NSProgress class]]) { NSProgress *progress = object; NSLog(@\"%@\",progress.localizedDescription); NSLog(@\"%@\", progress.localizedAdditionalDescription); NSLog(@\"completedUnitCount : %lld\", progress.completedUnitCount); NSLog(@\"totalUnitCount: %lld\", progress.totalUnitCount); NSLog(@\"fractionCompleted: %f\", progress.fractionCompleted); } } // 发送HTTP中的GET请求，获取HTML格式的字符串数据响应【须修改默认的响应初始化器】 -(void) getBaidDu { // 创建Manager AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; // 因为默认初始化器是JSON的(AFJSONResponseSerializer)，而百度返回的是HTML，所以需要设置为AFHTTPResponseSerializer manager.responseSerializer = [AFHTTPResponseSerializer serializer]; // 发送HTTP请求 [manager GET:@\"https://www.baidu.com\" parameters:nil headers:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSString *str = [[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]; NSLog(@\"获取到网页: %@\", str); } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { if (error) { NSLog(@\"获取网页出错: %@\", error); } }]; } -(void) getXML { AFHTTPSessionManager *manager = [AFHTTPSessionManager manager]; manager.responseSerializer = [AFXMLParserResponseSerializer serializer]; [manager GET:@\"http://127.0.0.1/videos.xml\" parameters:nil headers:nil progress:nil success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { NSLog(@\"%@\", responseObject); NSXMLParser *parser = (NSXMLParser *)responseObject; parser.delegate = self; [parser parse]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { NSLog(@\"%@\", error); }]; } // 开始解析XML文档 - (void)parserDidStartDocument:(NSXMLParser *)parser { NSLog(@\"开始解析XML\"); } // 开始解析节点 - (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName attributes:(NSDictionary *)attributeDict { NSLog(@\"Start Element: %@\", elementName); if ([elementName isEqualToString:@\"video\"]) { self.video = [JLVideo new]; self.video.videoId = @([attributeDict[@\"videoId\"] intValue]); } } // 开始解析节点之间的内容 - (void)parser:(NSXMLParser *)parser foundCharacters:(NSString *)string { NSLog(@\"内容: %@\", string); [self.mString appendString:string]; } // 解析节点完毕 - (void)parser:(NSXMLParser *)parser didEndElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI qualifiedName:(NSString *)qName { NSLog(@\"End Element: %@\", elementName); if ([elementName isEqualToString:@\"video\"]) { [self.videos addObject:self.video]; } else if (![elementName isEqualToString:@\"videos\"]){ [self.video setValuesForKeysWithDictionary:@{elementName : self.mString}]; self.mString = nil; } } // 结束解析XML文档 - (void)parserDidEndDocument:(NSXMLParser *)parser { NSLog(@\"XML文件解析完毕\"); NSLog(@\"%@\", self.videos); } @end "},"知识库/iOS 知识点/常用功能和第三方库/SDWebImage.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/SDWebImage.html","title":"网络图片下载 - SDWebImage","keywords":"","body":"SDWebImage 常用功能: 图片下载图片缓存 下载进度监听 gif处理 默认缓存时间: 1周 使用的缓存对象: NSCache SDImageCache内处理内存警告，以通知的方式，clearMemory cleanDisk的执行过程 先遍历所有的缓存文件，记录过期的文件，计算缓存文件的总大小 删除过期的文件 判断macCacheSize的值是否>0,如果大于0再判断缓存文件总大小是否大于maxCacheSize 如果缓存文件的总大小超过maxCacheSize，删除最早的文件 最大并发数: 6 支持gif 怎么判断图片文件的类型的 NSData + ImageContentType.m中 根据文件头的第一个字节判断的 case 0xFF (jpg) case 0x89 (png) case 0x47 (gif) case 0x4D (tiff) SDWebImage缓存文件的名称 为了防止缓存的图片名称冲突，根据md5计算的 md5重复的几率很小很小很小 终端测试echo -n '图片路径' | md5 maxMemoryCost 内存缓存的最大空间 maxMemoryCountLimit 内存缓存的最大数量 maxCacheAge 磁盘缓存存储的最长时间。默认值为1周 maxCacheSize 磁盘缓存的最大空间。默认值为0，不限制占用磁盘大小 1) loadImage 是 SDWebImage 的核心方法 2) 图像下载完成后，会自动保存在沙盒中，文件路径是 URL 的 md5 3) 如果沙盒中已经存在缓存的图像，后续使用 SD 通过 URL 加载图像，都会加载本地沙盒的图像 4) 不会发起网络请求，同时，回调方法，同样会调用！ 5) 方法还是同样的方法，调用还是同样的调用，不过内部不会再次发起网络请求！ 注意 如果缓存的图像累计很大，要找后台要接口！ "},"知识库/iOS 知识点/常用功能和第三方库/IM即时聊天/环信客服云、七鱼客服集成.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/IM即时聊天/环信客服云、七鱼客服集成.html","title":"客服集成 - 环信和七鱼","keywords":"","body":" 环信客服云、七鱼客服集成 环信客服云 七鱼客服 环信客服云、七鱼客服集成 环信客服云 可以不注册 APNs 的，不获取 APNs 推送证书 在集成环信的 UI 框架时，可能会出现它的依赖类库与你自己的依赖类库冲突的情况，这时候你就要进入蛋疼的合并冲突类库的过程了，用好git，删除旧的类库，导入最新的，编译、报错、更改。 完了以后，继承客服云最基本的只需要下面两步即可 在你的App用户注册的地方，注册环信客服云的账户，账户就用你App当前用户的账户，比如手机号，密码随便写 HDError *error = [[HDClient sharedClient] registerWithUsername:@\"username\" password:@\"password\"]; error.code: HDErrorNetworkUnavailable 网络不可用 HDErrorUserAlreadyExist 用户已存在 HDErrorUserAuthenticationFailed 无开放注册权限（后台管理界面设置[开放|授权]） HDErrorUserIllegalArgument 用户名非法 在用户点击进入客服时，登录并且显示与客服的会话界面 HDClient *client = [HDClient sharedClient]; if (client.isLoggedInBefore != YES) { HDError *error = [client loginWithUsername:@\"username\" password:@\"password\"]; if (!error) { //登录成功 } else { //登录失败 return; } } // 进入会话页面 HDMessageViewController *chatVC = [[HDMessageViewController alloc] initWithConversationChatter:@\"IM 服务号\"]; // 获取地址：kefu.easemob.com，“管理员模式 > 渠道管理 > 手机APP”页面的关联的“IM服务号” [self.navigationController pushViewController:chatVC animated:YES]; 七鱼客服 网易七鱼文档参考) 在网易七鱼管理端创建应用 下载 SDK 动态库集成 目前 QYSDK 的动态库版本暂未正式发布至 CocoaPods，对于使用 CocoaPods 管理第三方库的项目，若需要使用 V5.10.0 以上版本的动态库 SDK，可暂时使用本地 pod 导入 NIMSDK.framework 及 QYSDK.framework 进行依赖管理，步骤如下： 项目根目录下新建文件夹 frameworks，将前面下载得到的文件夹 NIMSDK 及文件夹 QYSDK 拷贝至 frameworks 目录下，确保文件夹中包含有 podspec 文件。 Podfile 文件中加入： pod 'NIMSDK', :path => './frameworks/NIMSDK' pod 'QYSDK', :path => './frameworks/QYSDK' Terminal 执行 pod install 即可完整集成 QYSDK 及其依赖的 NIMSDK。 开始使用 在程序启动的时候初始化 SDK,在AppDelegate中注册 [[QYSDK sharedSDK] registerAppId:QiYuAppKey appName:@\"信企贵交-iOS\"]; AppKey 可在 管理端-应用-在线系统-设置-在线接入-APP-2.App Key 找到，请确保填写完整及正确，无空格，否则可能导致功能异常。 AppName 对应管理端添加 App 时填写的 App名称。如需使用访客分流等功能，请及时在管理端添加 App，并填写正确的 bundleID 用于区分不同 App；如需使用推送功能，请选择相应环境上传对应推送证书，请自行确保证书有效性。 一般在application: didFinishLaunchingWithOptions:方法中调用初始化方法，如需在其他地方调用，请确保时机在启动客服功能前，且应预留一段初始化时间；尽量保证在整个软件运行期间仅调用一次。 显示客服聊天界面 /// 点击客服按钮 - (void)customerService{ // 0. 创建客服源(客服服务器地址?)? QYSource *source = [[QYSource alloc] init]; source.title = @\"客服\"; source.urlString = @\"https://qiyukf.com/\"; // 1. 创建客服会话视图控制器 QYSessionViewController *sessionViewController = [[QYSDK sharedSDK] sessionViewController]; // 设置导航栏返回按钮 sessionViewController.navigationItem.leftBarButtonItem = [[UIBarButtonItem alloc] initWithImage:[ECImage(@\"back_black_icon\") imageWithRenderingMode:UIImageRenderingModeAlwaysOriginal] style:UIBarButtonItemStylePlain target:self action:@selector(onBack:)]; // 设置导航栏标题 sessionViewController.sessionTitle = @\"客服\"; // 设置客服服务器地址? sessionViewController.source = source; // 嵌入一个导航控制器 ECNavigationController *nav = [[ECNavigationController alloc] initWithRootViewController:sessionViewController]; // 2. 显示 带导航控制器的 客服会话视图控制器 [self presentViewController:nav animated:YES completion:nil]; } "},"知识库/iOS 知识点/常用功能和第三方库/Bugly.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/Bugly.html","title":"异常上报 - Bugly","keywords":"","body":" Bugly SDK 集成 通过CocoaPods集成 手动集成 初始化SDK 导入头文件 初始化Bugly 配置符号表 自动配置：XCode + sh脚本【需要手动配置的话点这里】 1. 上传方式【可以啥都不弄，即选默认，直接进行第二步?】 2. 配置Xcode编译执行脚本 手动配置 Bugly SDK 集成 Bugly提供两种集成方式供iOS开发者选择： 通过CocoaPods集成 手动集成 如果您是从Bugly 2.0以下版本升级过来的，请查看iOS SDK 升级指南 Bugly iOS SDK 最低兼容系统版本 iOS 7.0 通过CocoaPods集成 在工程的Podfile里面添加以下代码： pod 'Bugly' 保存并执行pod install,然后用后缀为.xcworkspace的文件打开工程。 注意: 命令行下执行pod search Bugly,如显示的Bugly版本不是最新的，则先执行pod repo update操作更新本地repo的内容 关于CocoaPods的更多信息请查看 CocoaPods官方网站。 手动集成 下载 Bugly iOS SDK 拖拽Bugly.framework文件到Xcode工程内(请勾选Copy items if needed选项) 添加依赖库 SystemConfiguration.framework Security.framework libz.dylib 或 libz.tbd libc++.dylib 或 libc++.tbd 初始化SDK 导入头文件 在工程的AppDelegate.m文件导入头文件 #import 如果是Swift工程，请在对应bridging-header.h中导入 初始化Bugly 在工程AppDelegate.m的application:didFinishLaunchingWithOptions:方法中初始化： Objective-C - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [Bugly startWithAppId:@\"此处替换为你的AppId\"]; return YES; } Swift func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -> Bool { Bugly.startWithAppId(\"此处替换为你的AppId\") return true } 如果您需要上报iOS Watch2 App或iOS App Extension的异常，请参见 Bugly iOS Extension SDK 接入指南。 配置符号表 每次Build都会生成一个App和其对应的dSYM文件，每个dSYM文件都有自己的UUID，每一次crash对应的App都有自己特定UUID的dSYM文件。 默认debug模式不生成dSYM文件，可通过以下两步开启 自动配置：XCode + sh脚本【需要手动配置的话点这里】 自动配置请首先下载和解压自动配置符号表工具包，然后选择上传方式并配置Xcode的编译执行脚本。 1. 上传方式【可以啥都不弄，即选默认，直接进行第二步?】 使用脚本自动配置支持两种上传方式： 方式一：直接上传dSYM文件（默认方式 ） 方式二：提取dSYM文件的符号表文件并上传 其中，使用方式二需要额外操作以下几步： 下载符号表提取工具依赖的Java运行环境（JRE或JDK版本需要>=1.6） 把工具包buglySymbolIOS.jar保存在用户主目录（Home）的bin目录下（没有bin文件夹,请自行创建）: 2. 配置Xcode编译执行脚本 在Xcode工程对应Target的Build Phases中新增Run Scrpit Phase 打开工具包中的dSYM_upload.sh，复制所有内容，在新增的Run Scrpit Phase中粘贴 修改新增的Run Scrpit中的 为您的App ID，为您的App Key， 为App的Bundle Id 脚本默认在Debug模式及模拟器编译情况下不会上传符号表，在需要上传的时候，请修改下列选项 Debug模式编译是否上传，1＝上传 0＝不上传，默认不上传 UPLOAD_DEBUG_SYMBOLS=0 模拟器编译是否上传，1＝上传 0＝不上传，默认不上传 UPLOAD_SIMULATOR_SYMBOLS=0 至此，自动上传符号表脚本配置完毕，Bugly 会在每次 Xcode 工程编译后自动完成符号表配置工作。 手动配置 首先看那次crash的对应的app的dSYM文件的uuid 在配置好debug模式下可生成dSYM文件后，在生成的app的文件夹中找到dSYM文件。 用下面代码可查看此dSYM文件的uuid 查看dSYMs文件的UUID dwarfdump --uuid 【路径】 dwarfdump --uuid /Users/joyawang/Library/Developer/Xcode/Archives/2020-06-12/cloudExchange\\ 2020-6-12\\,\\ 10.09\\ PM.xcarchive/dSYMs/信企贵交.app.dSYM uuid匹配的话，用bugly提供的工具将dSYM文件生成bugly需要的格式，是个zip包 Bugly iOS符号表工具 java -jar 【jar文件地址/buglySymboliOS.jar】 -i 【dSYM文件地址/xxx.dSYM】 java -jar buglySymboliOS.jar -i /Users/joyawang/Library/Developer/Xcode/Archives/2020-06-12/cloudExchange\\ 2020-6-12\\,\\ 10.09\\ PM.xcarchive/dSYMs/信企贵交.app.dSYM 在bugly页面上传生成的zip包 "},"知识库/iOS 知识点/常用功能和第三方库/推送通知/推送 - 极光.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/推送通知/推送 - 极光.html","title":"推送通知 - 极光推送","keywords":"","body":" 极光推送 代码 极光推送 极光官方文档 在极光应用管理创建App 在推送设置 iOS 模块上传 APNs 证书 在Podfile中添加无idfa版本的SDK，在提交苹果审核时，就选否 pod 'JCore', '2.1.4-noidfa' // 必选项 pod 'JPush', '3.2.4-noidfa' // 必选项 在Capabilities中 添加 Push Notifications Access WIFI Information Background Modes 中的 Remote notifications 在info.plist中添加ATS，允许http访问 在 AppDelegate 中 // 引入 JPush 功能所需头文件 #import \"JPUSHService.h\" // iOS10 注册 APNs 所需头文件 #ifdef NSFoundationVersionNumber_iOS_9_x_Max #import #endif // 遵守 协议 初始化APNs //Required //notice: 3.0.0 及以后版本注册可以这样写，也可以继续用之前的注册方式 JPUSHRegisterEntity * entity = [[JPUSHRegisterEntity alloc] init]; entity.types = JPAuthorizationOptionAlert|JPAuthorizationOptionBadge|JPAuthorizationOptionSound|JPAuthorizationOptionProvidesAppNotificationSettings; if ([[UIDevice currentDevice].systemVersion floatValue] >= 8.0) { // 可以添加自定义 categories // NSSet *categories for iOS10 or later // NSSet *categories for iOS8 and iOS9 } [JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; 初始化 JPush // 请将以下代码添加到 -(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions // Optional // 获取 IDFA // 如需使用 IDFA 功能请添加此代码并在初始化方法的 advertisingIdentifier 参数中填写对应值 NSString *advertisingId = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; // Required // init Push // notice: 2.1.5 版本的 SDK 新增的注册方法，改成可上报 IDFA，如果没有使用 IDFA 直接传 nil [JPUSHService setupWithOption:launchOptions appKey:appKey channel:channel apsForProduction:isProduction advertisingIdentifier:advertisingId]; 注册 APNs 成功并上报 DeviceToken - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { /// Required - 注册 DeviceToken [JPUSHService registerDeviceToken:deviceToken]; } - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error { //Optional NSLog(@\"did Fail To Register For Remote Notifications With Error: %@\", error); } 添加处理 APNs 通知回调方法 请在 AppDelegate.m 实现该回调方法并添加回调方法中的代码 #pragma mark- JPUSHRegisterDelegate // iOS 12 Support - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(UNNotification *)notification{ if (notification && [notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { //从通知界面直接进入应用 }else{ //从通知设置界面进入应用 } } // iOS 10 Support - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(NSInteger))completionHandler { // Required NSDictionary * userInfo = notification.request.content.userInfo; if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { [JPUSHService handleRemoteNotification:userInfo]; } completionHandler(UNNotificationPresentationOptionAlert); // 需要执行这个方法，选择是否提醒用户，有 Badge、Sound、Alert 三种类型可以选择设置 } // iOS 10 Support - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler { // Required NSDictionary * userInfo = response.notification.request.content.userInfo; if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { [JPUSHService handleRemoteNotification:userInfo]; } completionHandler(); // 系统要求执行这个方法 } - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { // Required, iOS 7 Support [JPUSHService handleRemoteNotification:userInfo]; completionHandler(UIBackgroundFetchResultNewData); } - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo { // Required, For systems with less than or equal to iOS 6 [JPUSHService handleRemoteNotification:userInfo]; } 添加处理 JPush 自定义消息回调方法 如需使用 JPush 的自定义消息功能，请参考文档来实现自定义消息的处理回调方法。 成功运行 真机调试该项目，如果控制台输出以下日志则代表您已经集成成功。 2016-08-19 17:12:12.745823 219b28[1443:286814] | JPUSH | I - [JPUSHLogin] ----- login result ----- uid:5460310207 registrationID:171976fa8a8620a14a4 如果调试运行中遇到问题请参考：iOS SDK 调试指南 代码 // // AppDelegate.m // 极光推送Demo // // Created by Joya Wang on 2020/6/8. // Copyright © 2020 Joya Wang. All rights reserved. // #import \"AppDelegate.h\" // 引入 JPush 功能所需头文件 #import \"JPUSHService.h\" // iOS10 注册 APNs 所需头文件 #ifdef NSFoundationVersionNumber_iOS_9_x_Max #import #endif @interface AppDelegate () @end @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // 初始化 APNs [self initializeAPNs]; // 初始化 JPush // Required // init Push // notice: 2.1.5 版本的 SDK 新增的注册方法，改成可上报 IDFA，如果没有使用 IDFA 直接传 nil /* appKey 选择 Web Portal 上 的应用 ，点击“设置”获取其 appkey 值。请确保应用内配置的 appkey 与 Portal 上创建应用后生成的 appkey 一致。 channel 指明应用程序包的下载渠道，为方便分渠道统计，具体值由你自行定义，如：App Store。 apsForProduction 1.3.1 版本新增，用于标识当前应用所使用的 APNs 证书环境。 0（默认值）表示采用的是开发证书，1 表示采用生产证书发布应用。 注：此字段的值要与 Build Settings的Code Signing 配置的证书环境一致。 */ [JPUSHService setupWithOption:launchOptions appKey:@\"8a473ea188fb641a66e62b3f\" channel:@\"AppStore\" apsForProduction:0 advertisingIdentifier:nil]; return YES; } - (void)initializeAPNs { //Required //notice: 3.0.0 及以后版本注册可以这样写，也可以继续用之前的注册方式 JPUSHRegisterEntity * entity = [[JPUSHRegisterEntity alloc] init]; entity.types = JPAuthorizationOptionAlert|JPAuthorizationOptionBadge|JPAuthorizationOptionSound|JPAuthorizationOptionProvidesAppNotificationSettings; if ([[UIDevice currentDevice].systemVersion floatValue] >= 8.0) { // 可以添加自定义 categories // NSSet *categories for iOS10 or later // NSSet *categories for iOS8 and iOS9 } [JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; } // MARK: - 注册 APNs 成功并上报 DeviceToken - (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken { /// Required - 注册 DeviceToken [JPUSHService registerDeviceToken:deviceToken]; } - (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error { //Optional NSLog(@\"注册远程通知出错: %@\", error); } // MARK: - JPUSHRegisterDelegate // iOS 12 Support - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(UNNotification *)notification{ if (notification && [notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { //从通知界面直接进入应用 NSLog(@\"从通知界面直接进入应用\"); }else{ //从通知设置界面进入应用 NSLog(@\"从通知设置界面进入应用\"); } } // iOS 10 Support - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(NSInteger))completionHandler { // Required NSDictionary * userInfo = notification.request.content.userInfo; if([notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { [JPUSHService handleRemoteNotification:userInfo]; } completionHandler(UNNotificationPresentationOptionAlert); // 需要执行这个方法，选择是否提醒用户，有 Badge、Sound、Alert 三种类型可以选择设置 } // iOS 10 Support - (void)jpushNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler { // Required NSDictionary * userInfo = response.notification.request.content.userInfo; if([response.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) { [JPUSHService handleRemoteNotification:userInfo]; } completionHandler(); // 系统要求执行这个方法 } - (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult))completionHandler { // Required, iOS 7 Support [JPUSHService handleRemoteNotification:userInfo]; completionHandler(UIBackgroundFetchResultNewData); } @end "},"知识库/iOS 知识点/常用功能和第三方库/授权登录/OAuth.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/授权登录/OAuth.html","title":"授权登录 - OAuth","keywords":"","body":"OAuth 打开门户网站提供的登录页面进行登录 登录成功后，再次发送请求，将 授权码 和 应用程序信息 发送给服务器后获取 AccessToken "},"知识库/iOS 知识点/常用功能和第三方库/授权登录/SSO.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/授权登录/SSO.html","title":"授权登录 - SSO","keywords":"","body":"SSO 跳到第三方应用进行授权再跳回来 更加人性化 在真机上，如果用户安装了门户应用，可以直接跳转到门户应用进行授权 授权完毕后自动返回到应用程序 如果用户没有安装门户应用，会以 OAuth 的方式登录 "},"知识库/iOS 知识点/常用功能和第三方库/打企业版ipa包和七牛云分发流程.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/打企业版ipa包和七牛云分发流程.html","title":"打包、分发测试","keywords":"","body":"打企业版ipa包七牛云分发流程 打企业包前准备 用企业开发者账号，生成以下三个文件 in_house_profile.mobileprovision 描述文件 ios_distribution-3.cer 发布证书文件?【在要打包的电脑上双击打开】 证书.p12 文件【在要打包的、但未登录此企业开发者账号的电脑上双击打开】 要修改的信息 环境更新 Display Name Bundle Identifier【Targets-MyApp-General-Identity】 Version【Targets-MyApp-General-Identity】 Build【Targets-MyApp-General-Identity】 Targets-MyApp-Signing & Capbilities 取消 Automatically manage signing Provisioning Profile 项选择准备好的 in house profile 文件 如果出现private key相关的问题，则是.p12文件的问题 Targets-MyApp-Build Setting Signing Code Signing Identity 全部选择准备好的.cer文件 Provisioning Profile 选择准备好的 in house profile文件 配置Bugly 将Bugly启动的appId换成自己的 在Targets-MyApp-BuildPhases-Run Script 中修改 Bugly的App_ID, APP_KEY, BundleID 取消所有的断点 在Edit Scheme那里改为Release模式 Shift + Command + k 清理一下 选择 Generic iOS Device，Product - Archive, 开始打包 备份App对应的dSYM文件 分发 配置一个plist文件 url外链 【ipa文件的下载地址】 bundle-identifier 【BundleID】 bundle-version 【App版本】 title 【App名称】 在后台配置一下要更新的版本信息，这样iOS端才能检测到要更新 http://res.zhongsgx.com/package/1/cloudExchange.ipa http://res.xinqgj.com/xqgj/1/xqgj_operation.html https://www.xinqgj.com/downapp https://xinqgj.com/down/zwy-ios.plist http://res.xinqgj.com/package/1/cloudExchange.ipa // https://xinqgj.com/down/zwy-ios.plist dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ UIApplication *application = [UIApplication sharedApplication]; [application openURL:[NSURL URLWithString:[NSString stringWithFormat:@\"itms-services://?action=download-manifest&url=https://你的plist外链接地址.plist\"]]]; exit(0); }); items assets kind software-package url ipa文件的外链，这个外链可以不是https的，也就是说http即可 kind full-size-image needs-shine url kind display-image needs-shine url metadata bundle-identifier 你的bundleID bundle-version 1.2.0 kind software subtitle App title app名称 "},"知识库/iOS 知识点/常用功能和第三方库/七牛云上传包.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/七牛云上传包.html","title":"七牛云","keywords":"","body":"七牛云上传包，并获取下载链接 传完后，还要进行“刷新预取”，将原来的路径更新 "},"知识库/iOS 知识点/常用功能和第三方库/RxSwift.html":{"url":"知识库/iOS 知识点/常用功能和第三方库/RxSwift.html","title":"RxSwift","keywords":"","body":"RxSwift Swift - RxSwift的使用详解1（基本介绍、安装配置） Swift - RxSwift的使用详解2（响应式编程与传统式编程的比较样例） Swift - RxSwift的使用详解3（Observable介绍、创建可观察序列） Swift - RxSwift的使用详解4（Observable订阅、事件监听、订阅销毁） Swift - RxSwift的使用详解5（观察者1： AnyObserver、Binder） Swift - RxSwift的使用详解6（观察者2： 自定义可绑定属性） Swift - RxSwift的使用详解7（Subjects、Variables） Swift - RxSwift的使用详解8（变换操作符：buffer、map、flatMap、scan等） Swift - RxSwift的使用详解9（过滤操作符：filter、take、skip等） Swift - RxSwift的使用详解10（条件和布尔操作符：amb、takeWhile、skipWhile等） Swift - RxSwift的使用详解11（结合操作符：startWith、merge、zip等） Swift - RxSwift的使用详解12（算数&聚合操作符：toArray、reduce、concat） Swift - RxSwift的使用详解13（连接操作符：connect、publish、replay、multicast） Swift - RxSwift的使用详解14（其他操作符：delay、materialize、timeout等） Swift - RxSwift的使用详解15（错误处理） Swift - RxSwift的使用详解16（调试操作） Swift - RxSwift的使用详解17（特征序列1：Single、Completable、Maybe） Swift - RxSwift的使用详解18（特征序列2：Driver） Swift - RxSwift的使用详解19（特征序列3：ControlProperty、 ControlEvent） Swift - RxSwift的使用详解20（调度器、subscribeOn、observeOn） Swift - RxSwift的使用详解21（UI控件扩展1：UILabel） Swift - RxSwift的使用详解22（UI控件扩展2：UITextField、UITextView） Swift - RxSwift的使用详解23（UI控件扩展3：UIButton、UIBarButtonItem） Swift - RxSwift的使用详解24（UI控件扩展4：UISwitch、UISegmentedControl） Swift - RxSwift的使用详解25（UI控件扩展5：UIActivityIndicatorView、UIApplication） Swift - RxSwift的使用详解26（UI控件扩展6：UISlider、UIStepper） Swift - RxSwift的使用详解27（双向绑定：） Swift - RxSwift的使用详解28（UI控件扩展7：UIGestureRecognizer） Swift - RxSwift的使用详解29（UI控件扩展8：UIDatePicker） Swift - RxSwift的使用详解30（UITableView的使用1：基本用法） Swift - RxSwift的使用详解31（UITableView的使用2：RxDataSources） Swift - RxSwift的使用详解32（UITableView的使用3：刷新表格数据） Swift - RxSwift的使用详解33（UITableView的使用4：表格数据的搜索过滤） Swift - RxSwift的使用详解34（UITableView的使用5：可编辑表格） Swift - RxSwift的使用详解35（UITableView的使用6：不同类型的单元格混用） Swift - RxSwift的使用详解36（UITableView的使用7：样式修改） Swift - RxSwift的使用详解37（UICollectionView的使用1：基本用法） Swift - RxSwift的使用详解38（UICollectionView的使用2：RxDataSources） Swift - RxSwift的使用详解39（UICollectionView的使用3：刷新集合数据） Swift - RxSwift的使用详解40（UICollectionView的使用4：样式修改） Swift - RxSwift的使用详解41（UIPickerView的使用） Swift - RxSwift的使用详解42（[unowned self] 与 [weak self]） Swift - RxSwift的使用详解43（URLSession的使用1：请求数据） Swift - RxSwift的使用详解44（URLSession的使用2：结果处理、模型转换） Swift - RxSwift的使用详解45（结合RxAlamofire使用1：数据请求） Swift - RxSwift的使用详解46（结合RxAlamofire使用2：结果处理、模型转换） Swift - RxSwift的使用详解47（结合RxAlamofire使用3：文件上传） Swift - RxSwift的使用详解48（结合RxAlamofire使用4：文件下载） Swift - RxSwift的使用详解49（结合Moya使用1：数据请求） Swift - RxSwift的使用详解50（结合Moya使用2：结果处理、模型转换） Swift - RxSwift的使用详解51（MVVM架构演示1：基本介绍、与MVC比较） Swift - RxSwift的使用详解52（MVVM架构演示2：使用Observable样例） Swift - RxSwift的使用详解53（MVVM架构演示3：使用Driver样例） Swift - RxSwift的使用详解54（一个用户注册样例1：基本功能实现） Swift - RxSwift的使用详解55（一个用户注册样例2：显示网络请求活动指示器） Swift - RxSwift的使用详解56（结合MJRefresh使用1：下拉刷新） Swift - RxSwift的使用详解57（结合MJRefresh使用2：上拉加载、以及上下拉组合） Swift - RxSwift的使用详解58（DelegateProxy样例1：获取地理定位信息 ） Swift - RxSwift的使用详解59（DelegateProxy样例2：图片选择功能 ） Swift - RxSwift的使用详解60（DelegateProxy样例3：应用生命周期的状态变化） Swift - RxSwift的使用详解61（sendMessage和methodInvoked的区别） Swift - RxSwift的使用详解62（订阅UITableViewCell里的按钮点击事件） Swift - RxSwift的使用详解63（通知NotificationCenter的使用） Swift - RxSwift的使用详解64（键值观察KVO的使用） Swift - RxSwift的使用详解65（表格图片加载优化） Swift - RxSwift的使用详解66（检测当前值与初始值是否相同：isEqualOriginValue） Swift - RxSwift的使用详解67（重复执行某个操作序列：repeatWhen） Swift - RxSwift的使用详解68（监听滚动条滚动到底部的行为：reachedBottom） Swift - RxSwift的使用详解69（RxFeedback架构1：安装配置、基本用法） Swift - RxSwift的使用详解70（RxFeedback架构2：一个用户注册样例） Swift - RxSwift的使用详解71（RxFeedback架构3：GitHub资源搜索样例） Swift - RxSwift的使用详解72（ReactorKit架构1：安装配置、基本用法） Swift - RxSwift的使用详解73（ReactorKit架构2：一个用户注册样例） Swift - RxSwift的使用详解74（ReactorKit架构3：GitHub资源搜索样例） "},"知识库/iOS 知识点/iOS 知识点.html":{"url":"知识库/iOS 知识点/iOS 知识点.html","title":"iOS 基础知识点","keywords":"","body":" iOS知识点 架构 UI 数据读取解析存储 内存管理 Block / Closure / 函数指针 多线程、Runloop、自动释放池 网络 Runtime 原理及应用 生命周期 OC 语言特性 常用功能集成 支付 地图 音频、视频 IM 分享 崩溃收集 第三方库的源码 其他 iOS知识点 架构 MVC MVVM 从 0 到 1 实现一个 app 的思路 对于项目从 main 函数执行之前到之后启动优化，卡顿优化和界面优化 UI UICollectionView 瀑布流 UITableView 相关的优化，底层原理等 页面布局 layoutSubviews 和 drawRect 等的区别 自己实现一个 UIScrollView 事件的传递链和响应链 界面非常卡顿怎么定位到具体的类和方法 UIView 和 CALayer 区别 页面跳转的方法和区别 页面传值的方法和区别 数据读取解析存储 JSON 生成和解析 PropertyList 生成和解析 XML 生成和解析 NSFileManager 沙盒 UserDefaults 用户偏好 NSCache 钥匙串 本地数据库 FMDB CoreData Realm Firebase iCloud 内存管理 ARC 和 MRC 的区别 @property 属性的关键字 / 修饰符 他们具体的底层实现以及区别，被问烂的知识点包括 copy 浅拷贝和深拷贝的区别 weak 的底层实现 assgin 和 weak，assgin是否可以用来修饰对象 unsafe_unretained 具体有什么区别 Autorelease pool的底层实现原理，与 Runloop 的关系， autoreleasing 关键字 Block / Closure / 函数指针 本质，基础概念 使用时要注意的地方 block的实现，如何截获自动变量的，如何修改自动变量的值的，block的几种形式 __block的本质 forwarding 指针 block怎么避免循环引用。是不是所有的block都会产生循环引用，block里面怎么避免被提前释放 多线程、Runloop、自动释放池 iOS 中多线程的几种方式，区别，使用场景，基本概念，同步异步，串行并行的区别。 GCD，写一个死锁，并行和串行队列，同步和异步的区别，GCD怎么控制最大并发数 怎么让子线程定时执行一个方法，具体的实现方法 如何控制线程的最大并发数为10，然后加载十个图片最后展示出来，具体方法 子线程的runloop是怎么执行的，它里面的 autoreleasepool 是怎么执行的。 NSMutableArray 怎么保证线程安全的。 GCD怎么避免block中的变量被提前释放 runloop实现原理 source 类型 线程保活的方式 runloop和多线程的关系，以及timer的关系 网络 浏览器输入url到网页显示经历了什么过程? TCP三次握手：具体是怎么握手？为什么要三次握手？两次行不行？为什么不行？三次握手，第二次和第三次分别因为什么? TCP是如何保持可靠传输的（拥塞控制，慢启动等等概念的理解） TCP为什么要四次挥手，TIME_WAIT为什么至少设置两倍的MSL时间？ TCP三次握手的详细数据传递，四次挥手详细数据内容，数据包组成、TIME_WAIT状态，2MSL，RTT，重传、滑动窗口、拥塞原理等等 TCP、UDP面向连接、无连接具体理解，他们的区别，如何将 UDP 改造成和 TCP 功能相似 TCP/IP四层协议，OSI七层协议，每层都有啥对应的协议，原理是啥 http报文结构，http中超文本超是啥意思，http请求的组成 http 报文头部含有什么，multipart了解吗 http的状态码，200，304，301，http请求报文，响应报文 get和post请求的区别？什么情况下用到？POST传输的数据都有哪些格式呢（这里需要搞定http各种请求传输的数据格式） 描述一次完整的http请求 什么是cookie，什么是session，区别联系，cookie的本质是什么 http1.0，1.1，2.0的区别 https有几次握手和挥手？https的原理。http有几次挥手和握手？TLS在哪一网络层，基本原理是什么？ https与中间人攻击 HTTPS，安全层除了SSL还有，最新的？ 参数握手时首先客户端要发什么额外参数 HTTPS是什么？握手过程，SSL原理，非对称加密了解多少 证书是干什么用的 弱网优化 Runtime 原理及应用 KVO 的底层原理，自己实现 KVC 的底层原理，自己实现 NSNotification 的底层原理，是同步还是一部，如何实现一个，如果在子线程接收一个通知能不能接收到 消息的动态转发 给 Category 添加属性，关联对象都有几种形式 method swizzling 怎么获取已上架app崩溃日志？ 怎么为系统类添加存储属性？ 说一说类的结构，运行时中的class都有什么属性，property都有什么属性 说一说isa指到NSObject的那个过程 Category的本质，load方法什么时候加载，Category重写了父类的方*怎样，底层源码 ，如果两个Category和一个基类，都有同名方法，先执行哪个 property会自动生成什么，如果此时已经有下划线_name的实例变量了那会生成什么 load 和 initialize 生命周期 app 的声生命周期 控制器的生命周期 视图的生命周期 OC 语言特性 OC 和 C 的区别， OC 和 Java、C++ 的区别 iOS 中的协议 OC 动态性 C 语言如何动态的交换两个方法的实现 常用功能集成 支付 支付宝 微信 银联 Apple Pay 地图 百度地图 高德地图 苹果地图 音频、视频 AVPlayer AVMediaPlayer 直播 点播 IM XMPP 融云 分享 友盟 崩溃收集 bugly 第三方库的源码 其他 一个 int 类型的值，被 @ 包装成 NSNumber 类型，传递到一个接受 id 类型的方法参数中，这个值能不能保持正确 在 iPad 上面，分屏功能，拖拽 wps 的文件到 qq 的过程是怎么实现的 (进程间通信的方法) 如何实现 dispatch_once Instrument 的使用 热修复用过吗，平时版本怎么迭代，线上 bug 怎么修复？ "},"知识库/iOS 知识点/OC和Swift混编.html":{"url":"知识库/iOS 知识点/OC和Swift混编.html","title":"OC和Swift混编","keywords":"","body":" OC和Swift混编 OC项目中使用Swift类 OC项目中使用Swift第三方库 OC和Swift混编 OC项目中使用Swift类 创建一个 Swift 类，同时系统自动提示创建桥接文件，\"项目名称-Bridging-Heade\", 比如cloudExchange-Bridging-Header 如果想更改创建的桥接文件的位置，则在 build settings中搜索 bridging，在 Objective-C Bridging Header 后面双击更改位置，如$(SRCROOT)/cloudExchange-Bridging-Header.h 在 target 的 build settings 中 Product Module Name 中设置一个名字，到时会生成一个叫”Product Module Name-Swift.h”的文件 Defines Module : YES 【?】 Always Embed Swift Standard Libraries : YES 【?】 Install Objective-C Compatibility Header : YES 【?】 调用Swift类，我们想要调用Swift类的方法里面引入生成的头文件：”Product Module Name-Swift.h”，比如 #import \"cloudExchange-Swift.h\" 要让 OC 可用的 Swift 类，要么自己继承自 NSObject，要么它的父类继承自 NSObject class YourSwiftClassName: NSObject 要让 OC 可调用的 属性，必须在 属性声明 前面加 @objc 要在Swift文件中使用的OC类需要在桥接文件中引入头文件，暴露给Swift OC项目中使用Swift第三方库 Podfile中添加 use_frameworks! 添加这句代码是因为Apple不允许build包含swift的静态库了，而cocoapod使用了framework动态框架的方式来集成swift库 重新pod install 重新打开项目 如果需要的话，找到pod-->build setting->swift-language-version设置为4.0 编译的话，有可能报找不到.h文件的错，试着重新import一下 如果项目中有剔除x86_64, i386这两个架构的shell script，可能会报lipo相关的错误，改为下面改良过的脚本 #改良过的，剔除掉x86_64, i386这两个架构的shell代码 #!/usr/bin/env bash APP_PATH=\"${TARGET_BUILD_DIR}/${WRAPPER_NAME}\" # This script loops through the frameworks embedded in the application and # removes unused architectures. find \"$APP_PATH\" -name '*.framework' -type d | while read -r FRAMEWORK do FRAMEWORK_EXECUTABLE_NAME=$(defaults read \"$FRAMEWORK/Info.plist\" CFBundleExecutable) FRAMEWORK_EXECUTABLE_PATH=\"$FRAMEWORK/$FRAMEWORK_EXECUTABLE_NAME\" if [ ! -f \"${FRAMEWORK_EXECUTABLE_PATH}\" ]; then continue fi if xcrun lipo -info \"${FRAMEWORK_EXECUTABLE_PATH}\" | grep --silent \"Non-fat\"; then echo \"Framework non-fat, skipping: $FRAMEWORK_EXECUTABLE_NAME\" continue fi echo \"Thinning framework $FRAMEWORK_EXECUTABLE_NAME\" EXTRACTED_ARCHS=() for ARCH in $ARCHS do echo \"Extracting $ARCH from $FRAMEWORK_EXECUTABLE_NAME\" xcrun lipo -extract \"$ARCH\" \"$FRAMEWORK_EXECUTABLE_PATH\" -o \"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\" EXTRACTED_ARCHS+=(\"$FRAMEWORK_EXECUTABLE_PATH-$ARCH\") done echo \"Merging extracted architectures: ${ARCHS}\" xcrun lipo -o \"$FRAMEWORK_EXECUTABLE_PATH-merged\" -create \"${EXTRACTED_ARCHS[@]}\" rm \"${EXTRACTED_ARCHS[@]}\" echo \"Replacing original executable with thinned version\" rm \"$FRAMEWORK_EXECUTABLE_PATH\" mv \"$FRAMEWORK_EXECUTABLE_PATH-merged\" \"$FRAMEWORK_EXECUTABLE_PATH\" done "},"知识库/iOS 知识点/APP开发步骤、流程.html":{"url":"知识库/iOS 知识点/APP开发步骤、流程.html","title":"APP开发步骤、流程","keywords":"","body":" APP开发步骤、流程 分析功能需求 流程 画界面 数据处理 逻辑处理(用户交互) APP开发步骤、流程 分析功能需求 流程 画界面 -- 对接口(获取数据) -- 展示数据 -- 用户交互 -- 数据处理 -- 保存数据 画界面 创建UI控件并布局【在View类中进行】 纯代码形式 storyboard【中创建的是一个个UIKit类的单例对象，可以自定义UIKit的子类“绑定”它来添加更多自定义控制】 xib【单独创建一个UIKit类的单例对象，可以跟这个UIKit类“绑定”来实现更多自定义控制】 SwiftUI 数据处理 获取 网络(对接口) 使用AFN封装网络工具单例，传入参数访问接口地址，从网络获取到JSON、XML、pList等格式的Data(二进制数据) 本地 在bundle的话，用bundle的urlForResource获取到路径URL 在沙盒的话，找到沙盒路径URL 用data的contentsOfUrl创建Data(二进制数据) 解析(反序列化，字典转模型) 分析要获取的数据，根据其属性创建对应的model(数据模型类),必须有两个符合规范的构造方法，可以从字典直接转换为数据模型（可使用YYModel快速实现） 在视图控制器中设置字典数组属性，并且重写其getter方法，让其可以在懒加载时直接将把从存储介质获得的字典数组，通过遍历将其元素(数据字典)转换为数据模型，并存储到此字典数组中返回。 使用JSONSerialization、JSONDecoder、PropertyListSerialization、SAX或DOM等将获取到的二进制数据解析为数组或字典 将数据数组或字典转换成数据模型数组 展示 创建自定义view的类(创建一个model属性，和与model属性的属性对应的用来显示其内容的控件属性，重写model属性的setter方法setModel，在其中将数据赋值给相应控件来显示, 必须有两个符合规范的构造方法, 如果视图需要从文件获取数据，则创建一个同名构造方法，在其中直接获取好数据赋值给视图属性，然后返回此视图，记得控制器中只需得到一个已经fully ready，只需和数据模型相结合的视图了) 创建xib文件，将view size设置为freeform，然后设置view的尺寸，为所有子控件添加好尺寸 将model数据和view相结合，调用视图的setModel方法即可 展示数据【在Controller类中进行】 直接将模型传递给View类 在set方法中为控件赋值来展示数据 生成(序列化) 将模型数据数组转换为json、xml、plist等二进制形式data 存储(持久化) 存储在bundle, 沙盒, iCloud等地方 逻辑处理(用户交互) 用户交互【】 监听屏幕事件(用户交互) 为屏幕控件注册事件add target 屏幕控件通过调用代理协议的方法名通知遵守了代理协议，即实现了代理协议方法的对象 通过函数指针、block、closure等方式回调 处理屏幕事件 做相应的反应 获取到用户的数据，生成一定格式并保存 做动画 跳转到下个场景 进行网络连接 展示某些数据 ... ... "},"知识库/iOS 知识点/项目/项目简介.html":{"url":"知识库/iOS 知识点/项目/项目简介.html","title":"项目","keywords":"","body":" 项目简介 项目组 项目文档 项目架构 分配任务 项目简介 项目组 移动开发组 (Android 和 iOS) 服务器(web)开发组 产品需求组 测试组 美工组 ... 项目文档 需求文档 接口文档 开发文档 产品文档 ... 项目架构 UI 界面层 业务类层 网络处理层 工具类层 ... 分配任务 按照功能和模块分 按照项目架构的层次分 ... "},"知识库/iOS 知识点/项目/项目部署.html":{"url":"知识库/iOS 知识点/项目/项目部署.html","title":"项目部署","keywords":"","body":" 项目部署 开源中国社区 官方网站 与 GitHUB 对比 使用 项目部署 开源中国社区 官方网站 https://git.oschina.net 开源中国社区成立于2008年8月，其目的是为中国的IT技术人员提供一个全面的、快捷更新的用来检索开源软件以及交流使用开源经验的平台 目前国内很多公司将项目部署在OSChina 与 GitHUB 对比 服务器在国内，速度更快 免费账户同样可以建立 私有 项目，而 GitHUB 上建立私有项目要付费【已免费】 使用 注册账号 建议使用网易的邮箱，使用其他免费邮箱可能收不到验证码 添加 SSH 公钥 Public Key SSHKey 示意图如下 开源中国帮助文档地址: https://git.oschina.net/oschina/git-osc/wikis/帮助#ssh-keys 进入终端，并输入以下命令 # 生成 RSA 密钥对 # 1> \"\" 中输入个人邮箱 # 2> 提示输入存储密钥对的文件夹名称，直接回车 # 3> 提示输入密码，可以随便输入，只要本次能够记住即可 $ ssh-keygen -t rsa -C \"xxx@126.com\" # 查看公钥内容 $ cat ~/.ssh/id_rsa.pub 将公钥内容复制并粘贴到 https://git.oschina.net/profile/sshkeys 测试公钥 # 测试 SSH 连接 $ ssh -T git@git.oschina.net # 终端提示 `Welcome to Git@OSC，刀哥` 书名连接成功 新建项目 克隆项目 # 切换至项目目录 $ cd 项目目录[从finder拖拽] # 克隆项目，地址可以在项目首页复制 $ git clone git@git.oschina.net:xxx/ProjectName.git 添加 gitignore 1> 将 Swift.gitignore 复制到项目目录 2> 进入终端 # cd 项目目录目录[从finder拖拽] $ mv Swift.gitignore .gitignore 提示: 从 http://github.com/github/gitignore 获取最新版本的 gitignore 文件 添加 .gitignore 文件之后，每次提交时不会将个人的项目设置信息 (例如：上次代开的文件，调试断点等) 提交到服务器，在团队开发中非常重要 提示: 是否知道 .gitignore 是是否有团队开发经验的重要特征 "},"知识库/iOS 知识点/项目/项目架构.html":{"url":"知识库/iOS 知识点/项目/项目架构.html","title":"项目架构","keywords":"","body":" 架构 项目架构的重要性 项目架构 项目架构中的技术点 代码加载根控制器 通过反射机制使用字典加载各分控制器 架构 项目架构的重要性 走向工作岗位之后，一般会遇到两种工作情况： 新项目开发 通常在项目开始之前，公司的产品经理会提供完整的产品原型图，或功能设计文档 通过对这些文档的解读，能够梳理出目标项目的整体架构，从而协助项目框架的搭建 旧项目维护 很多老项目是缺乏文档的，这种情况在一些小公司中表现尤为突出 要想快速上手一个老项目，首先运行项目，并且整理项目整体框架结构 然后用整理出的框架结构与代码结构相互印证，无疑可以对了解项目的整体架构起到重要的辅助 综上所述，无论是新项目，还是老项目，在开发之前确定项目的主题架构都是非常重要，也是十分必要的！ 项目架构 UI 界面层 业务类层 网络处理层 工具类层 ... 项目架构中的技术点 代码加载根控制器 实例应用 JL微博_SceneDelegate 通过反射机制使用字典加载各分控制器 实例应用 JL微博_JLMainViewController "},"知识库/iOS 知识点/项目/MVC 和 MVVM.html":{"url":"知识库/iOS 知识点/项目/MVC 和 MVVM.html","title":"MVC 和 MVVM","keywords":"","body":" MVVM MVC 回顾 MVVM MVVM 的优点 MVVM MVVM 是 Model-View-ViewModel 的简写，MVVM 和 MVC 一样，主要目的是分离视图 (View) 和模型 (Model) 用一个 viewModel 为整个视图中所有控件提供数据，控制器只负责刷新一下就行，大大减少了控制器中的代码 V 视图【View + Controller】 VM 视图模型【viewModel】 字典转模型 加载数据【调用 JLNetworkTool 方法】 下拉刷新 上拉刷新 M 数据模型【Model】 MVC 回顾 MVC 存在的问题 模型的代码很少 控制器的代码一不小心就越来越多 不好测试 MVVM MVVM 结构图 MVVM 概念 在 MVVM 中，view 和 view controller 正式联系在一起，我们把它们视为一个组件 view 和 view controller 都不能直接引用 model，而是引用视图模型 view model 是一个放置用户输入验证逻辑，视图显示逻辑，发起网络请求和其他代码 MVVM 使用事项 view 引用 view model ，但反过来不行 view model 引用了 model，但反过来不行 如果破坏了这些规则，便无法正确的使用 MVVM MVVM 的优点 低耦合: View 可以独立于 model 变化和修改，一个 ViewModel 可以绑定到不同的 View上 可重用性: 可以把一些试图逻辑放在一个 ViewModel 里，让很多 view 重用这段视图逻辑 独立开发: 开发人员可以专注于业务逻辑和数据开发 ViewModel，设计人员可以专注于页面设计 可测试: 通常界面是比较难于测试的，而 MVVM 模式可以针对 ViewModel 来进行测试 "},"知识库/iOS 知识点/UI/UI 界面 搭建.html":{"url":"知识库/iOS 知识点/UI/UI 界面 搭建.html","title":"UI","keywords":"","body":"UI 界面搭建 搭建方式 XIB Storyboard 纯代码 SwiftUI 如何选择 看界面的自定义程度，如果有许多自定义效果，定制程度比较高，就使用代码搭建。 如果界面是由普通的控件组成，则用storyboard。 XIB 搭建界面 加载视图控制器时，如果 XIB 和 视图控制器类重名，默认构造函数会优先加载 XIB 文件 XIB 中拖的是 View 不是 ViewController XIB 的创建 加载控制器 +(instancetype)viewControllerFromXib { return [[JLRecoverPwdViewController alloc] initWithNibName:@\"JLRecoverPwdViewController\" bundle:[NSBundle mainBundle]]; } 加载 View + (instancetype)rotationView { return [[NSBundle mainBundle] loadNibNamed:@\"JLTopImageRotationView\" owner:nil options:nil][0]; } - 当 XIB 中的 根视图是控制器的根视图时 > - 给此 XIB 设置 视图控制器类 > > 将 File's Owner 中的类设置为 XIB 的类 > > - 将 视图控制器类 的 根视图 view 设置为 XIB 的 view > > 在 File's Owner 上右键将 view 与 Xib 中的 view 连接 > > - 否则会报错 > > -[UIViewController _loadViewFromNibNamed:bundle:] loaded the \"JLComposeViewController\" nib but the view outlet was not set.' - 当 XIB 中的根视图 不是控制器的根视图则不需要设置 File Owner - 如果 Xib 文件对应的是 view， 不是 控制器，那么 fileOwner 不需要设置 - Xib 中的 collectionView 不像 Storyboard 中一样，不能添加 item，创建自定义 UICollectionViewCell - 如果 collectionView 的superView 是从 Xib 中加载的，设置 itemSize 和 superView 相关的话，要在 layoutSubviews 中设置，因为 awakeFromNib 中 superView 的 size 还是 xib 中的size - 创建 Cocoa Touch 类时，只有 Controller 的子类，可以直接自动创建 Xib，view 则不行 纯代码搭建界面 直接在控制器类中自己用代码创建View，创建各种控件添加到View中，并设置frame、自动布局等 "},"知识库/iOS 知识点/UI/SwiftUI.html":{"url":"知识库/iOS 知识点/UI/SwiftUI.html","title":"SwiftUI","keywords":"","body":" SwiftUI UI搭建 在SwiftUI中使用 UIKit 类视图 List 列表，表格 Make the List Dynamic 页面间跳转 页面间传值 Ways to set the device for previewing your views @State 状态 binding 绑定 ForEach observable object 可观察对象 @EnvironmentObject 环境对象 Group 组 SwiftUI UI搭建 当创建一个SwiftUI视图时，在它的 body 属性中描述它的内容、布局和行为。 然而，body 属性只返回一个单一的视图。 你可以在 stacks 中组合或者嵌套多个视图，它可以将视图水平、垂直或者从后到前组合在一起。 在SwiftUI中使用 UIKit 类视图 将 UIKit 创建的 view 嵌套到遵守 UIViewRepresentable协议的 SwiftUI view中。 makeUIView(context:) 创建并返回一个UIKit View updateUIView(_:context:) 配置这个view，并且对变动做出响应\f import SwiftUI import MapKit /// 地图视图 struct MapView: UIViewRepresentable { /// 数据模型 var coordinate: CLLocationCoordinate2D // 创建并返回UIKit的view func makeUIView(context: Context) -> MKMapView { MKMapView(frame: .zero) // 创建并返回一个MKMapView空对象 } // 配置 这个空对象，并且对变动做出响应 func updateUIView(_ uiView: MKMapView, context: Context) { // 1. 创建 经纬度坐标 let coordinate = CLLocationCoordinate2D(latitude: 34.011286, longitude: -116.166868) // 2. 创建 范围 let span = MKCoordinateSpan(latitudeDelta: 2.0, longitudeDelta: 2.0) // 3. 创建 要显示的地图区域 (坐标+范围) let region = MKCoordinateRegion(center: coordinate, span: span) // 4. 给 地图设置显示区域 uiView.setRegion(region, animated:true) } } List 列表，表格 相当于 UITableView When you use SwiftUI’s List type, you can display a platform-specific list of views. The elements of the list can be static, like the child views of the stacks you’ve created so far, or dynamically generated. You can even mix static and dynamically generated views. 当你使用SwiftUI的 List 类型时，你可以显示一个因平台而异的视图列表。列表的元素可以是静态的，就像目前堆中你创建的那些子视图一样，也可以是动态生成的。你还可以混合静态视图和动态生成的视图。 Make the List Dynamic 相比于一个个创建列表的元素，你可以直接将一个集合生成一个有多行视图的列表 你可以创建一个显示某个集合中元素的列表，通过传递你存有数据的集合和一个可以为此集合中每个元素创建相应视图的闭包 列表通过提供的闭包将集合中的每个元素转换成它的一个组成视图 Lists work with identifiable data. You can make your data identifiable in one of two ways: by passing along with your data a key path to a property that uniquely identifies each element, or by making your data type conform to the Identifiable protocol. 列表需要可唯一识别的数据。你可以通过以下两种方式使你的数据唯一话，在传递你的数据给List时，一起传递一个属性路径，这个属性可以准确唯一地识别每一个元素，或者使你的数据类型遵守Identifiable协议。 Identifiable 是List视图要求的，List的每个模型元素必须有其唯一的标识符 id You can create a List of views from a collection of Identifiable elements. What approach do you use to adapt a collection of elements that don’t conform to the Identifiable protocol? 你可以从包含可被唯一标识的元素的集合，直接创建视图列表。如果元素不遵守Identifiable协议的情况下，在创建列表List时，通过与数据一起传递一个可唯一标识这个元素的属性路径作为第二个参数给 List(_:id:) 页面间跳转 Set Up Navigation Between List and Detail NavigationView 和 NavigationLink 页面间传值 Pass Data into Child Views Ways to set the device for previewing your views Change the simulator selected in the active scheme. Specify one or more devices using the previewDevice(_:) method. Connect your development device and click the Device Preview button. @State 状态 State is a value, or a set of values, that can change over time, and that affects a view’s behavior, content, or layout. You use a property with the @State attribute to add state to a view. State 是会随时间变化的一个值，或者多个值，并且这种变化会影响一个视图的行为，内容或者布局。用@State修饰符标记一个属性，将它作为视图的一个State binding 绑定 To give the user control over the list’s filter, you need to add a control that can alter the value of showFavoritesOnly. You do this by passing a binding to a toggle control. A binding acts as a reference to a mutable state. When a user taps the toggle from off to on, and off again, the control uses the binding to update the view’s state accordingly. It’s a value and a way to change that value. A binding controls the storage for a value, so you can pass data around to different views that need to read or write it. Add a Toggle view as the first child of the List view, passing a binding to showFavoritesOnly. You use the $ prefix to access a binding to a state variable, or one of its properties. 如果要让用户可以对列表进行过滤，你需要添加一种可以改变showFavoritesOnly的控制，你可以通过 绑定 一个控制开关来实现。 当用户点击开关时，开关会通过绑定功能相应更新视图的状态。它是一个值，也是一种改变这个值的方式。 绑定控制着一个值的存储，所以你可以通过 绑定 向需要读写这个值的不同的视图传递数据。 添加一个开关与showFavoritesOnly绑定，来控制它的值变化 你可以使用$前缀获取状态变量的绑定，或者它的某个属性 // 1. 静态行 - 开关 Toggle(isOn: self.$showFavoritesOnly) { Text(\"Favorites only\") } ForEach ForEach operates on collections the same way as the list, which means you can use it anywhere you can use a child view, such as in stacks, lists, groups, and more. When the elements of your data are simple value types — like the strings you’re using here — you can use \\.self as key path to the identifier. ForEach 像列表一样可以用在集合上，这意味着你可以在任何有子视图的地方使用它，比如在stacks, lists, groups等。当你的数据元素是简单的值类型时，比如字符串，你可以使用 \\.self作为标识符的路径。 struct LandmarkList_Previews: PreviewProvider { static var previews: some View { ForEach([\"iPhone SE\", \"iPhone XS Max\"], id: \\.self) { deviceName in LandmarkList() .previewDevice(PreviewDevice(rawValue: deviceName)) .previewDisplayName(deviceName) } } } To combine static and dynamic views in a list, or to combine two or more different groups of dynamic views, use the ForEach type instead of passing your collection of data to List. 要在list中混合静态和动态视图时，或者混合两个及以上的不同组的动态视图时，使用ForEach类型来实现，不需要将数据集合传递给List // 地标列表 (静态行 + 动态行) List{ // 1. 静态行 - 开关 Toggle(isOn: self.$showFavoritesOnly) { Text(\"Favorites only\") } // 2. 动态列表 (行的数据可动态设置) ForEach(landmarkData) { landmark in // 只有在全部显示状态下，或者只显示收藏时，此地标属于被收藏时显示 if !self.showFavoritesOnly || landmark.isFavorite { // 这里相当于map函数，为地标数组中的每个元素创建了一个地标视图并返回 NavigationLink(destination: LandmarkDetail(landmark: landmark)) { // 地标行视图 (外包一层导航链接，可跳到目的地视图) LandmarkRow(landmark: landmark) } } } } observable object 可观察对象 To prepare for the user to control which particular landmarks are favorites, you’ll first store the landmark data in an observable object. An observable object is a custom object for your data that can be bound to a view from storage in SwiftUI’s environment. SwiftUI watches for any changes to observable objects that could affect a view, and displays the correct version of the view after a change. Declare a new model type that conforms to the ObservableObject protocol from the Combine framework. SwiftUI subscribes to your observable object, and updates any views that need refreshing when the data changes. An observable object needs to publish any changes to its data, so that its subscribers can pick up the change. Add the @Published attribute to each property in the model. 为了可以使用户能对地标进行收藏，你需要先将地标的数据存储在一个可观察对象中。 可观察对象是一个你数据的自定义对象，在SwiftUI的环境中，可以从内存中绑定到一个视图上。SwiftUi监听可观察对象的任何可以影响一个视图的变动，并且在变动之后相应地更新视图。 声明一个新的模型类型，使其遵守Combine框架中的可观察对象协议 SwiftUI视图会订阅可观察数据对象，当可观察数据对象发生变化时，SwiftUI视图也会随之变化 可观察对象会把自己的数据中标记为@Published的所有变动发布给它的订阅者, 所以把发生变动后会影响SwiftUI视图的属性(数据)用@Published标记 import SwiftUI import Combine /// 可观察数据对象 /* SwiftUI视图会订阅可观察数据对象，当可观察数据对象发生变化时，SwiftUI视图也会随之变化 */ final class UserData: ObservableObject { /* 可观察对象会把自己的数据中标记为@Published的所有变动发布给它的订阅者, 所以把发生变动后会影响SwiftUI视图的属性(数据)用@Published标记 */ /// 是否只显示收藏地标标记 - 会影响视图变化的数据1 @Published var showFavoritesOnly = false /// 地标数据数组 - 会影响视图变化的数据2 @Published var landmarks = landmarkData } @EnvironmentObject 环境对象 环境对象，某个对象本身的变化会导致视图和其子视图变化，也就是导致此视图整体环境变化，就叫做这个视图的环境对象 包含数据源以及一些会导致视图变化的变量 创建视图时，需要传递环境对象进去 /// 主视图 列表视图 struct LandmarkList: View { /// 可观察对象，此视图的数据模型，包含数据源以及一些会导致视图变化的变量 @EnvironmentObject var userData: UserData var body: some View { // 可导航(跳转)视图 NavigationView { // 地标列表 (静态行 + 动态行) List{ // 1. 静态行 - 开关 Toggle(isOn: $userData.showFavoritesOnly) { Text(\"Favorites only\") } // 2. 动态列表 (行的数据可动态设置) ForEach(landmarkData) { landmark in // 只有在全部显示状态下，或者只显示收藏时，此地标属于被收藏时显示 if !self.userData.showFavoritesOnly || landmark.isFavorite { // 这里相当于map函数，为地标数组中的每个元素创建了一个地标视图并返回 NavigationLink(destination: LandmarkDetail(landmark: landmark)) { // 地标行视图 (外包一层导航链接，可跳到目的地视图) LandmarkRow(landmark: landmark) } } } } // 本页面的导航栏标题 .navigationBarTitle(Text(\"Landmarks\")) } } } Which of the following passes data downward in the view hierarchy? 在视图层次结构中，向下传递数据的是environmentObject(_:) 修饰符 You apply this modifier so that views further down in the view hierarchy can read data objects passed down through the environment. 使用environmentObject(_:) 修饰符，可以使视图层次结构中下面的视图读取在环境中传递下来的数据对象 // 创建视图时，需要传递环境对象进去 // 主视图入口 let contentView = LandmarkList() .environmentObject(UserData()) // 传递一个可观察数据对象进去，即就是这个视图的数据模型 // Use a UIHostingController as window root view controller. if let windowScene = scene as? UIWindowScene { let window = UIWindow(windowScene: windowScene) window.rootViewController = UIHostingController(rootView: contentView) self.window = window window.makeKeyAndVisible() } Group 组 Group is a container for grouping view content. Xcode renders the group’s child views as separate previews in the canvas. A view’s children inherit the view’s contextual settings, such as preview configurations. Group是用来组合视图内容的容器。Xcode在画布中将组中的子视图渲染成单独的预览。视图的子视图集成它的一些环境设置，比如预览配置。 只能在画布中使用? "},"知识库/iOS 知识点/UI/UI 界面间 传值.html":{"url":"知识库/iOS 知识点/UI/UI 界面间 传值.html","title":"UI 界面间 传值","keywords":"","body":"UI 界面间 传值 如果要传的值有2个以上，封装数据模型传送 传值方式 顺传值 Storyboard 拖线的话，prepareForSegue 手动 push 或 present 的话，在当时传 逆传值 代理模式 一对一，代理只能设置一次，如多次设置，只最后一次设置的起作用 block / closure 实例：私人通讯录_新建修改 通知 一对多 AddTarget "},"知识库/iOS 知识点/UI/UI 界面间 跳转.html":{"url":"知识库/iOS 知识点/UI/UI 界面间 跳转.html","title":"UI 界面间 跳转","keywords":"","body":"UI 界面间[控制器间]跳转的方式[转场] 跳转方式 控制器间拖线1：自动型segue 控制器间拖线2：手动型segue 纯代码：使用navigationController的push方法 Modal present 如何选择 如果两个控制器有业务关系用push，否则用modal push需要外包一个navigationController，modal不需要 Modal是谁负责跳转谁负责关闭 在storyboard中，连接两个控制器时依然选show，如果有导航控制器，系统会进行push跳转，即从右往左过来，否则会modal跳转，即从下往上出来。 Storyboard 控制器间拖线1：自动型segue 使用场景： 不需要做任何逻辑条件判断，一点就跳转 步骤： 从A控制器要跳转的控件拖线到B控制器 Storyboard 控制器间拖线2：手动型segue 使用场景： 点击后需要进行一些逻辑判断才能确定要不要跳转 步骤： 从A控制器上面控制器图标拖线到B控制器 给此线(segue)添加identifier 在A控制器的类文件中合适的地方调用performSegueWithIdentifier进行跳转 注意： 只要是在storyboard拖线进行的跳转，无论手动还是自动型，都会调用 prepareForSegue 这个方法，所以可以在这里做传值、设置代理等方法。(纯代码方式不调用) 纯代码: navigationController的push // 显示 let vc = JLDemoViewController() navigationController?.pushViewController(vc, animated: true) // 退出 popViewController(animated: true) 纯代码: Modal present // 显示 let vc = JLOAuthViewController() let nav = UINavigationController(rootViewController: vc) self.present(nav, animated: true, completion: nil) // 退出 dismiss(animated: true, completion: nil) "},"知识库/iOS 知识点/UI/自动布局.html":{"url":"知识库/iOS 知识点/UI/自动布局.html","title":"自动布局","keywords":"","body":"自动布局 autoResizing 和 autolayout 不能共存，用纯代码写默认是 autoresizing，用 xib 默认是 autolayout 实例应用 UI基础10 _JL微博_JLVisitorView UI基础_Day09自动布局 autoresizing【纯代码】 translatesAutoresizingMaskIntoConstraints 此属性如果设置为 true ​ 自动将它的 autresizing mask 转换为相应的约束 ​ 可以修改 frame、bounds、center 等属性来静态控制控件的位置 ​ 而 autresizing mask 完全设定了视图的位置和尺寸，所以不能再添加其它额外的约束 ​ 如果需要“自动布局”来动态计算控件的位置和尺寸，则需要将此属性设置为false，并且为此控件添加一个不冲突的约束 ​ 如果用纯代码创建控件，则此属性被系统自动设置为 true ​ 如果在 Interface Builder 中创建控件，则此属性被系统自动设置为 false If this property’s value is true, the system creates a set of constraints that duplicate the behavior specified by the view’s autoresizing mask. This also lets you modify the view’s size and location using the view’s frame, bounds, or center properties, allowing you to create a static, frame-based layout within Auto Layout. Note that the autoresizing mask constraints fully specify the view’s size and position; therefore, you cannot add additional constraints to modify this size or position without introducing conflicts. If you want to use Auto Layout to dynamically calculate the size and position of your view, you must set this property to false, and then provide a non ambiguous, nonconflicting set of constraints for the view. By default, the property is set to true for any view you programmatically create. If you add views in Interface Builder, the system automatically sets this property to false. autolayout【XIB、Storyboard】 SizeClasses 纯代码自动布局 // 自动布局 - 设置 xib 控件的自动布局，需要指定宽高约束 // 禁用 autoResizing (因为会以 autolayout 冲突) refreshView.translatesAutoresizingMaskIntoConstraints = false // 设置 中心点 X 约束 addConstraint(NSLayoutConstraint(item: refreshView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0)) // 设置宽度约束 refreshView.addConstraint(NSLayoutConstraint(item: refreshView, attribute: .width, relatedBy: .equal, toItem: nil, attribute: .notAnAttribute, multiplier: 1.0, constant: refreshView.bounds.width)) Snapkit Xib 和 Storyboard 中的控件自动布局 (动态高度) Frame 中 x, y, height, width (autoResizing) 和 autoLayout 中 leading, top, trailing, bottom 是两个系统的 需要动态高度的控件，比如微博正文的 Label，使用内建默认高度，将 leading, top, trailing 设好就行，将父容器的 bottom 设置始终 >= label bottom，也可加 constant 来设定间距 上面的做法，对于 UIView 还需要先设置一个高度，因为没有内建的默认高度，而且，label 只要设置了多行(0)，会随着文字增多而撑开，但是 UIView 貌似不行，所以需要把它的 height Constraint 连线到 code中，用 code 动态改变来达到动态高度的效果 "},"知识库/iOS 知识点/UI/苹果原生代码自动布局.html":{"url":"知识库/iOS 知识点/UI/苹果原生代码自动布局.html","title":"苹果原生代码自动布局","keywords":"","body":"苹果原生代码自动布局 自动布局核心公式 view.attr1 = view2.attr2 * multiplier + constant 自动布局构造函数 NSLayoutConstraint(item: iconView, 视图 attribute: .centerY, 约束属性 relatedBy: .equal, 约束关系 toItem: **self**, 参照视图 attribute: .centerY, 参照属性 multiplier: 1.0, 乘积 constant: -60) 约束数值 如果指定 宽 高 约束 参照视图设置为 nil 参照属性选择 .notAnAttribute 自动布局类函数 NSLayoutConstraint.constraints(withVisualFormat: , VFL公式 options: [], metrics: , 约束数值字典 [String:数值] views: ) 视图字典 [String:子视图] VFL 可视化格式语言 H 水平方向 V 垂直方向 | 边界 () 包含控件的名称字符串，对应关系在 views 字典中定义 () 定义控件的宽/高，可以在 metrics 中指定 提示: VFL 通常用于连续参照关系，如果遇到居中对齐，通常直接使用参照 // 6> 遮罩图像 let dict = [\"maskIconView\":maskIconView, \"registerButton\":registerButton] let metrics = [\"spacing\":-60] addConstraints(NSLayoutConstraint.constraints( withVisualFormat: \"H:|-0-[maskIconView]-0-|\", options: [], metrics: nil, views: dict)) addConstraints(NSLayoutConstraint.constraints( withVisualFormat: \"V:|-0-[maskIconView]-spacing-[registerButton]\", options: [], metrics: metrics, views: dict)) "},"知识库/iOS 知识点/UI/UIScrollView中子控件的布局.html":{"url":"知识库/iOS 知识点/UI/UIScrollView中子控件的布局.html","title":"UIScrollView中子控件的布局","keywords":"","body":"ScrollView 中 子控件的布局 设置 有导航控制器时, scrollView 不自动调整自己的原点 self.edgesForExtendedLayout = UIRectEdgeNone; self.automaticallyAdjustsScrollViewInsets = YES; 使用 containerView 如果只有一个子视图, 且scrollView高度由子视图确定的话. // MARK: - 布局子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局 scrollView [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 布局 容器视图 [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // 已保证scrollView 的contentSize 随着 containerView 的size 变化, 但是 container的高度未确定 }]; // 布局 imgView [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.leading.top.trailing.mas_equalTo(0); }]; // 最后, 通过设置 container 的底部与最后一个子控件图片框的底部相同, 从而设置了 container 的高度与图片相同, 从而使得 scrollView 的高度与 图片相同 [self.containerView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.imgView.mas_bottom); }]; } 如果有多个子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局子控件 // 设置scrollView约束 [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 设置参照视图的约束 [self.contentView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // make.height.greaterThanOrEqualTo(@0.0f); }]; // 第一个测试view的约束 [self.oneView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.contentView).offset(30); make.left.equalTo(self.contentView); make.width.mas_equalTo(200); make.height.mas_equalTo(300); }]; // 第二个测试view的约束 [self.twoView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.oneView.mas_bottom).offset(50); make.right.equalTo(self.contentView); make.width.mas_equalTo(400); make.height.mas_equalTo(500); }]; // 第三个测试view的约束 [self.threeView mas_makeConstraints:^(MASConstraintMaker *make) { make.top.equalTo(self.twoView.mas_bottom).offset(70); make.left.right.equalTo(self.contentView); make.height.mas_equalTo(300); }]; // 最后设置最后一个view的与参照容器view的约束 [self.contentView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.threeView.mas_bottom).offset(-10); }]; } 不使用 containerView 如果只有一个子视图, 且scrollView高度由子视图确定的话. Edges都为0, 只是说明它的大小会随着父控件变化, 并不意味着它的 contentSize 就确定了, 只有父控件的大小确定了才行 将 scrollView 的edges 都equal to 它的父控件, 或者要显示的大小. 布局 scrollView 的子控件, 如果是动态高度的话, 只先布局它除去高度外的约束 最后, 设置 scrollView 的 bottom 与最后一个子控件的bottom 相等, 相当于确定了 scrollView 的高度 // MARK: - 布局子控件 - (void)viewDidLayoutSubviews { [super viewDidLayoutSubviews]; // 布局 scrollView [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.view); }]; // 布局 imgView [self.imgView mas_makeConstraints:^(MASConstraintMaker *make) { make.edges.equalTo(self.scrollView); make.width.equalTo(self.scrollView); // 已保证scrollView 的contentSize 随着 imgView 的size 变化, 但是 scrollView contentSize的高度仍未确定 }]; // 最后, 通过设置 scrollView 的底部与最后一个子控件imgView的底部相同,从而使得 scrollView 的高度与 图片相同 [self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) { make.bottom.equalTo(self.imgView.mas_bottom); }]; } "},"知识库/iOS 知识点/UI/事件的传递链、响应链.html":{"url":"知识库/iOS 知识点/UI/事件的传递链、响应链.html","title":"事件的传递链、响应链","keywords":"","body":" 事件的产生和传递 如何找到最合适的控件来处理事件（hitTest） UITouch 在iOS 中不是任何对象都能处理事件，只有继承了 UIResponder 的对象才能接收并处理事件，我们称之为\"响应者对象\" UIApplication、UIViewController、UIView都继承自 UIResponder，因此它们都是响应者对象，都能够接收并处理事件 事件分类 触摸事件 加速剂事件 远程控制事件 UIResponder 内部提供以下方法处理事件 触摸事件 touchesBegan touchesMoved touchesEnded touchesCancelled 加速计事件 motionBegan motionEnded motionCancelled 远程控制事件 remoteControlReceivedWithEvent 事件的产生和传递 发生触摸事件后，系统会将该事件加入到一个由 UIApplication 管理的事件队列中 UIApplication 对象会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口 (keyWindow) 主窗口会在视图层次结构中 找到一个最合适的视图来处理触摸事件 ，但这仅仅是整个事件处理过程的第一步 找到合适的视图控件后，就会调用视图控件的touchesBegan等方法来做具体的事件处理 触摸事件的传递是从父控件传递到子控件 所以，如果父控件不能接收触摸事件，那么子控件就不能接收到触摸事件 一个View不接收触摸事件的三种情况 不接收用户交互 userInteractionEnabled = NO 隐藏 hidden = YES 透明 alpha = 0.0-0.01 UIImageView 的userInteractionEnabled默认为NO，所以UIImageView和它的子控件默认不能接收触摸事件 如何找到最合适的控件来处理事件（hitTest） 自己是否能接收触摸事件？否，事件传递到此结束 触摸点是否在自己身上？否，事件传递到此结束 从后往前遍历子控件，重复前面的两个步骤 如果没有符合条件的子控件，那么就自己最适合处理 当事件传递给一个控件的时候就会调用它的hitTest，目的是为了找最合适的view hitTest return nil，说明在自己的子控件中没有找到最合适的处理此次点击事件的view 用pointInside 判断点在不在(方法调用者)当前view的坐标系上 // 上面步骤的代码实现 @implementation JLView /// 找最合适的view /// point 是当前 view 的坐标系上的点 - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { // 1. 判断自己能否接收事件 if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha = 0; i--) { // 获取子控件 UIView *childView = self.subviews[i]; // 转换坐标系 // 把自己的坐标系上的点转换成子控件坐标系上的点 CGPoint childPoint = [self convertPoint:point toView:childView]; UIView *fitView = [childView hitTest:childPoint withEvent:event]; // 如果找到更合适的来处理此次事件的subView，就将其返回 if (fitView) { return fitView; } } // 如果没有比自己更合适的view，将自己返回 return self; } UITouch 一个手指对应一个UITouch对象，保存跟手指相关的信息，比如触摸的位置、时间、jieduan "},"知识库/iOS 知识点/UI/UIDevice.html":{"url":"知识库/iOS 知识点/UI/UIDevice.html","title":"UIDevice","keywords":"","body":"UIDevice 如何监听设备旋转、电池电量改变、贴近脸部(近距离传感器)等事件？ UIDevice类提供了一个单例对象，它代表着设备，通过它可以获得一些设备相关的信息，比如电池电量值(batteryLevel)、电池状态(batteryState)、设备的类型(model, 比如iPod、iPhone等)、设备的系统(systemVersion) UIDevice对象会不断地发布一些通知，下列是UIDevice对象所发布通知的名称常量： 设备旋转 UIDeviceOrientationDidChangeNotification 电池状态改变 UIDeviceBatteryStateDidChangeNotification 电池电量改变 UIDeviceBatteryLevelDidChangeNotification 近距离传感器(比如设备贴近了使用者的脸部) UIDeviceProximityStateDidChangeNotification UIDevice *dev = [UIDevice currentDevice]; NSNotificationCenter *center = [NSNotificationCenter defaulterCenter]; [center addObserver:self selector:@selector(m1:) name:UIDeviceOrientationDidChangeNotification object:dev]; "},"知识库/iOS 知识点/UI/UIView.html":{"url":"知识库/iOS 知识点/UI/UIView.html","title":"UIView","keywords":"","body":" UIView 和 CALayer UIView CALayer UIView 和 CALayer UIView 负责监听和响应事件 圆角相关 圆角 layer.cornerRadius 圆角以后非圆角的地方截掉 layer.masksToBounds 布局子控件大小、位置 frame 控件所在矩形框在其父控件中的位置和尺寸 以父控件的左上角为坐标原点 frame.origin即可修改控件位置，就修改它的frame的左上角的位置坐标 frame.size又可修改控件大小，修改它的frame的矩形的长宽(左上角左边不变，中心点会变化) bounds 控件所在矩形框的位置和尺寸 bounds.size只可以修改控件大小，放大尺寸时，中心点不变 center 控件中点的位置（以父控件的左上角为坐标原点） 可以通过center的坐标改变控件的位置 -sizeToFit (command + =) 根据里面的内容设置自己UIView适应大小，不改变x,y setNeedsLayout layoutIfNeeded 每调用一次，系统会立即在绘图之前进行一次自动布局，比如当cell刚创建好时，我们在layoutSubview里面的code之前需要对某子控件先进行布局，得到它合适的尺寸之后才能进行code的布局，就可以这样 layoutSubviews (在layoutIfNeeded中调用)当控件的frame改变时会调用，怎样重新布局它的子控件，需要重写此方法，在此方法中规定如何根据父控件的frame计算子控件的frame。 绘图相关 setNeedsDisplay 如何重绘 理解成tableView的刷新，当绘图的path中的坐标或其他数据改变时，如果不刷新重新显示的话，view显示的还是原来的绘图 (1)调用某个需要重绘的view对象的setNeedsDisplay。 (2)调用某个需要重绘的view对象的setNeedsDisplayInRect rect:参数表示需要重绘的区域 为什么不能手动调用drawRect 因为手动调用时可能获取不到正确的上下文，画也是白画。 如果需要重新画一些东西的话，调用setNeedsDisplay，系统会自动在适当的时候调用drawRect 坐标转换 将自己的子控件的坐标，转换为另一个视图的坐标 convert 动画相关 view.transform (transform是个结构体类型)控件的形变属性(可设置旋转角度、比例缩放、平移等属性) 平移 CGAffineTransformTranslation 缩放 CGAffineTransformScale 旋转 CGAffineTransformRotation 动画开始的地方 +beginAnimations context 设置动画持续时间 +setAnimationDuration 提交动画(动画结束的地方) +commitAnimations 形式使用动画 +animateWithDuration: animation block 视图生命周期相关 init?(coder: NSCoder) 从 XIB，Storyboard 加载时的构造函数 只是刚从 XIB 的二进制文件将视图数据加载完成，还没有和代码连线建立起关系，所以开发时不能在此处理 UI，控件还是 nil init(frame:) 纯代码创建视图的入口 awakeFromNib 在这里处理 UI, UIView从xib文件中创建好时会自动调用这个方法，这个时候这个view的子控件也都创建好可以访问了 willMoveToSuperview:newSuperview; addSubview 时会调用 willMove 当添加到父视图的时候， newSuperview 是 父视图 当父视图被移除，newSuperview 是 nil didMoveToSuperview; willMoveToWindow:newWindow; 当视图从界面上删除，同样会调用此方法， newWindow == nil didMoveToWindow; removeFromSuperview viewWithTag 其他 viewWithTag 返回对应tag标识的子控件 bringSubviewToFront 将此子控件放置到所有子控件的最上方(若某个子控件被挡住无法显示) CALayer CALayer负责视图中显示内容和动画 UIView负责监听和响应事件 UIView之所以能够显示在屏幕上，完全是因为它内部的一个图层 在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层 当UIView需要显示到屏幕上时，会调用drawRect方法进行绘图，并且会将所有内容绘制在自己的图层上，绘制完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。 也就是说，UIView本身不具备现实的功能，是它的内部的层才有显示功能 CoreAnimation动画是直接作用在CALayer上的，并非UIView position 用来设置在父层中的位置 以父层的左上角为原点(0,0) position属性和view.center的关系 anchorPoint 称为”定位点“、”锚点“ 决定着CALayer的position属性所指的是哪个点 以自己的左上角为原点(0,0) 它的x, y取值范围都是0~1，默认值为(0.5, 0.5) contents设置内容(图片) 需要桥接bridge，bridge后面直接跟要从C转为OC的类，比如id，就用(bridge id) 获取图片 圆角 cornerRadius 形变 transform 阴影 阴影颜色 shadowColor 阴影透明度? shadowOpacity 从要加阴影的控件的左上角偏移的量 shadowOffset 阴影半径? shadowRadius "},"知识库/iOS 知识点/UI/UITabBarController.html":{"url":"知识库/iOS 知识点/UI/UITabBarController.html","title":"UITabBarController","keywords":"","body":" UITabBarController 实例应用 UITabBarController 实例应用 JL微博_JLMainViewController 是否将要切换到某个视图 shouldSelectViewController "},"知识库/iOS 知识点/UI/UINavigationController.html":{"url":"知识库/iOS 知识点/UI/UINavigationController.html","title":"UINavigationController","keywords":"","body":" UINavigationController 实例应用 Navigation Controller NavigationBar NavigationItem UIBarButtonItem 导航栏颜色相关 设置 有导航控制器时, scrollView 不自动调整自己的原点 UINavigationController 实例应用 JL微博_JLNavigationController 通讯录 Navigation Controller 负责跳转 push pop 避免系统的覆盖，需要隐藏默认的 Bar 两种隐藏方式 一个支持手势返回 一个不支持 需要在每个子控制器添加 Bar NavigationBar ​ 一个控制器只有一个 ​ bar 的背景颜色 ​ bar.barTintColor ​ 负责管理 NavigationItem ​ 手势返回的时候，前后的导航条会覆盖 ​ 可以自定义 NavigationBar 解决融合？ NavigationItem ​ 管理条目 ​ 中间的标题 ​ 标题字体颜色 ​ bar.titleTextAttributes ​ 左侧按钮 ​ 右侧按钮 ​ 返回按钮 UIBarButtonItem ​ 具体的按钮 ​ 按钮标题字体颜色 ​ bar.tintColor 导航栏颜色相关 // 设置导航栏的 背景颜色【渲染颜色】 navigationBar.barTintColor = UIColor.cz_color(withHex: 0xF6F6F6) // 设置导航栏 标题的字体颜色 navigationBar.titleTextAttributes = [NSAttributedString.Key.foregroundColor : UIColor.darkGray] // 设置导航栏 按钮文字颜色 navigationBar.tintColor = UIColor.orange 导航栏底部隐藏线条 [[UINavigationBar appearance] setShadowImage:[[UIImage alloc] init]]; 设置 有导航控制器时, scrollView 不自动调整自己的原点 self.edgesForExtendedLayout = UIRectEdgeNone; self.automaticallyAdjustsScrollViewInsets = YES; "},"知识库/iOS 知识点/UI/UIScrollView.html":{"url":"知识库/iOS 知识点/UI/UIScrollView.html","title":"UIScrollView","keywords":"","body":" UIScrollView 实例应用 使用步骤 属性 常用代理协议方法 注意事项 UIScrollView 实例应用 Cassini UI基础喜马拉雅 UI基础_图片轮播器 使用步骤 添加 UIScrollView 到视图 设置 frame 设置 contentSize 添加 子视图 并设置 frame 要放大缩小的话 设置 viewForZoom 设置 最大、最小 缩放比 属性 UIScrollView自己本身的大小，即可视区域的大小 frame.size UIScrollView中所包含的内容的大小(要滚动的实际内容的大小) contentSize 设置UIScrollView是否能滚动 scrollEnabled 设置分页效果是否开启，scrollView框架的大小就是每页的大小 pagingEnabled 是否允许用户交互 userInteractionEnabled 滚动偏移 contentOffset 进行偏移时有动画效果 setContentOffset 内容内边距 contentInset 显示水平滚动(条)指示器 showsHorizontalScrollIndicator 显示垂直滚动(条)指示器 showsVerticalScrollIndicator 设置表格滚动指示器缩进 scrollIndicatorInsets 设置UIScrollView是否有弹簧效果 bounces 最大放大到多少倍 maximumZoomScale 最小缩放到多少倍 minimumZoomScale 常用代理协议方法 滚动 滚动过程中调用 scrollViewDidScroll 滚动停止后调用 scrollViewDidEndDecelerating 拖拽 即将开始拖拽时调用 scrollViewWillBeginDragging 拖拽完毕时调用 scrollViewDidEndDragging 放大缩小 用户使用捏合手势时调用，在此返回要进行缩放的子控件，此方法在缩放之前调用 viewForZoomingInScrollView 即将开始缩放的时候调用 scrollViewWillBeginZooming 正在缩放的时候调用 scrollViewDidZoom 缩放完毕的时候调用 scrollViewDidEndZooming 注意事项 scrollView出现在在导航控制器中，会自动加上64的偏移 self.automaticallyAdjustScrollViewInsets = NO;【已废弃】 self.scrollView.contentInsetAdjustmentBehavior = UIScrollViewContentInsetAdjustmentNever;【现用】 设置 有导航控制器时, scrollView 不自动调整自己的原点 self.edgesForExtendedLayout = UIRectEdgeNone; self.automaticallyAdjustsScrollViewInsets = YES; "},"知识库/iOS 知识点/UI/UITableView.html":{"url":"知识库/iOS 知识点/UI/UITableView.html","title":"UITableView","keywords":"","body":" UITableView 实例应用 UITableViewController 常见问题 表格的性能优化 UITableView 实例应用 网络新闻新闻列表 UI基础汽车品牌展示 UI基础团购案例 彩票_设置界面 UITableViewController 表格种类 UITableViewStylePlain 在上拉的时候，把组头顶在顶部。 UITableViewStyleGrouped 每个 section 之间有间距 单元格种类 dynamic 动态：数量可以根据数组元素的数量动态变化，样式可以变化 static 静态：数量固定，样式固定？ 使用静态单元格，必须使用UITableViewController控制器 在控制器中需设置自定cell的高度，因为tableView继承自UIScrollView，所以必须知道自己的contentSize来确定可滚多远，它要通过每个cell的高度来计算 背景色相关 设置整个表的背景色 tableView.backgroundColor 设置单元格的背景颜色 cell.backgroundColor 设置单元格的背景视图 cell.backgroundView 高度相关 统一设置整个表所有单元格的高度 tableView.rowHeight 【每行 行高相同时】 统一设置整个表所有组标题的高度 tableView.sectionHeaderHeight 统一设置整个表所有组尾的高度 tableView.sectionFooterHeight 动态设置每个单元格的行高 heightForRowAtIndexPath 【Delegate方法，每行行高不同时】 动态设置行的高度（代理协议中的方法），根据单元格中最底下的控件的maxY和margin计算出行高 heightForRowAtIndexPath比cellForRowAtIndexPath中的layoutSubviews提前调用，也就意味着那时根据子控件的frame计算行高就晚了，所以行高必须在heightForRowAtIndexPath调用之前计算，可以将这个数据作为model的一个属性储存在model中。 在Table View Cell 的尺寸检查器中设置的Row Height只是改变了storyboard里面的cell的高度，程序实际运行起来以后，如果不在tableView.rowHeight或者heightForRowAtIndexPath中设置行高的话，则会使用系统的默认行高。 分割线相关 分割线的颜色 tableView.separatorColor 分割线的样式 tableView.separatorStyle 分割线的内边距 [tableView setSeparatorInset]; 在 Cell 中设置分割线内边距 IOS设置TableView的分割线左右边距 cell.separatorInset = UIEdgeInsetsMake(0, 0, 0, 0) cell.layoutMargins = UIEdgeInsetsMake(0, 0, 0, 0) 没有数据时不显示tableView的分割线 _tableView.tableFooterView = [[UIView alloc]initWithFrame:CGRectZero]; content相关 设置表格内容缩进，即内容内边距 contentInset 设置内容偏移 - 滚动到表格视图某个位置【最顶部】 [tableView setContentOffset]; 表头表尾，组头组尾相关 表头，一般可以放广告 tableView.tableHeaderView 表尾，一般可以放加载更多 tableView.tableFooterView 组标题显示文字 titleForHeaderInSection 【dataSource】 组尾/脚显示文字(组描述) titleForFooterInSection 【dataSource】 组标题显示view，可以是任何控件 viewForHeaderInSection【dataSource】 组尾显示view，可以是任何控件 viewForFooterInSection【dataSource】 选中单元格 是否允许单元格被选中 tableView.allowSelection 监听单元格被选中事件的方法 didSelectRowAtIndexPath【Delegate】 监听单元格取消选中事件的方法 didDeselectRowAtIndexPath【Delegate】 获取被选中(点击)cell的位置(indexPath) tableView.indexPathForSelectedRow 设置选中cell时的样式，可取消灰色 cell.selectionStyle 设置选中单元格时要展示的view，也可设置颜色 cell.selectedBackgroundView 刷新表格 刷新整个列表 [tableView reloadData] 刷新指定的组 [tableView reloadSections]; 刷新指定的行 [tableView reloadRowsAtIndexPaths] 当数据总行数发生变化时不能使用 滚动 将tableView滚到指定的某行 [tableView scrollToRowAtIndexPath] 设置表格滚动指示器缩进 tableView.scrollIndicatorInsets 单元格样式 styleDefault 左边一张图、一个标题 styleSubtitle 左边一张图、一个标题，标题下面一个副标题 styleValue1 左边一张图、一个标题，右边一个副标题 styleValue2 一个标题和一个副标题紧挨着 创建单元格 Xib 创建 与 自定义Cell 类名 相同的 Xib 文件 添加控件，在 Xib 中做好自动布局，宽度和高度需要动态变化的 label，固定好Leading、Trialling，设置动态 trailing 和 bottom，label trailing 小于等于 Cell Trailing, 可设 constant 来设置与Cell Trailing 的间距 设置 Xib 文件的 class 为 自定义类 将 Xib 控件连线到自定义类 注册 Xib cell class 必须使用 tableView.register(nib,forIndexPath) 创建 Xib cell 实例 直接 tableView.dequeReusableCell (withIdentifier forIndexPath) as! XibCellClass Xib Cell 好像不用再显式设置 cell 的高度了，就已经是动态高度了。 如果需要显式设置的话，设置这俩 tableView?.rowHeight = UITableView.automaticDimension，tableView?.estimatedRowHeight = 300 Storyboard 纯代码 单元格编辑模式左滑、右滑、删除 进入编辑模式 commitEditingStyle: forRowAtIndexPath: 【Delegate】 删除指定行的单元格 deleteRowsAtIndexPaths: withRowAnimation:【Delegate】 右滑单元格出现的按钮定制 leadingSwipeActionsConfigurationForRowAtIndexPath 左滑单元格出现的按钮定制 trailingSwipeActionsConfigurationForRowAtIndexPath 单元格重用 声明一个重用ID static 后，ID局部变量就不会每次重复创建重复销毁了，一旦创建就会一直保留直到程序结束 根据这个重用ID去“缓存池”中查找对应的cell 判断是否找到了可用的cell，如果没有，则需要重新创建一个(如果使用tableView自带的cell，设置reuse identifier后就不需要判断和创建了，storyboard自动做这些工作) 标题、文字、图片相关 图片框 cell.imageView 大文字标签 cell.textLabel 小文字标签 cell.detailTextLabel 列表右侧的索引栏，目录 sectionIndexTitlesForTableView 单元格右边的小控件枚举 (disclosureIndicator, detailDisclosure) cell.accessaryType cell.accessoryView 常见问题 代码添加子控件的话，添加在 contentView 中 滚动到表格视图最顶部 setContentOffset 表格的性能优化 尽量少计算，所有需要的素材提前计算好！ 控件上不要设置圆角半径，所有图像渲染的属性，都要注意！ 图像尺寸不合适时进行的拉伸要避免，用 CoreGraphics 画 不要动态创建控件，所有需要的控件，都要提前创建好，在显示的时候，根据数据 隐藏 / 显示！ Cell 中的控件的层次越少越好，数量越少越好！ 用内存换取 CPU 要测量，不要猜测 "},"知识库/iOS 知识点/UI/UICollectionView.html":{"url":"知识库/iOS 知识点/UI/UICollectionView.html","title":"UICollectionView","keywords":"","body":" UICollectionView 实例应用 使用方法 注意问题 UICollectionView 实例应用 网络新闻_图片轮播 使用方法 必须设置 flowLayout，必须注册 cell 设置 cell 的大小 flowLayout.itemSize 如果设置itemSize不起作用，则将collectionView的Estimate Size设置为none 设置滚动的方向 flowLayout.scrollDirection 每行之间的最小间距 flowLayout.minimumLineSpacing 每个item之间的最小间距 flowLayout.minimumInteritemSpacing 设置分页 pagingEnabled 设置滚动条显示 showsHorizontalScrollIndicator 设置弹簧效果 bounces 注册 cell 从 storyboard 加载 cell 手动注册 自定义 cell 注册 xib 注意，如果从storyboard中加载cell就不要手动注册cell了，否则cell不显示 应用 新特性页面 图片无限轮播功能的实现【详见网络新闻app】 始终显示第二个cell 在用户结束滑动时，通过contenOffset判断出是向上一个还是下一个滑动了 然后计算出滑动后要显示的图片的index，用全局属性currentImageIndex记录，再reloadData？ 在cellForItemAt中 因为在从当前滑动到下一个图片的过程中，要开始显示下个图片了，会调用cellForRowAt，但是此时还没有滑动结束 所以新的currentImageIndex还没有计算出来，如果不在cellForItemAt中计算下个要显示的图片索引的话，下个要显示的图片将和当前相同，因为currentImageIndex没有变化。 注意问题 safeArea 可能会导致 bounds 和 frame 变化，造成布局问题 代码添加子控件的话，添加在 contentView 中 "},"知识库/iOS 知识点/UI/UIImageView 和 UIImage.html":{"url":"知识库/iOS 知识点/UI/UIImageView 和 UIImage.html","title":"UIImageView 和 UIImage","keywords":"","body":"UIImageView 和 UIImage [[UIImageVIew alloc] initWithImage:image] 会根据图像大小设置图像视图的大小！ 图片切片拉伸 在 Assets 中切片拉伸 用代码切片拉伸 // 拉伸图片 let size = bgImage?.size ?? CGSize.zero let insets = UIEdgeInsets(top: size.height * 0.5, left: size.width * 0.5, bottom: size.height * 0.5, right: size.height * 0.5) bgImage = bgImage?.resizableImage(withCapInsets: insets) bgImageSL = bgImageSL?.resizableImage(withCapInsets: insets) "},"知识库/iOS 知识点/UI/UITextField 和 UITextView.html":{"url":"知识库/iOS 知识点/UI/UITextField 和 UITextView.html","title":"UITextField 和 UITextView","keywords":"","body":" UITextField 和 UITextView UITextField 退出键盘 UITextField 和 UITextView UITextField 监听输入框的状态 在第一次点击文本框准备进行输入时调用 textFieldShouldBeginEditing 【UITextFieldDelegate】 只在第一次点击文本框准备进行输入时调用，设置文本框是否能够被编辑，No的话，里面的文字不能被编辑 文本框已经开始编辑(成为第一响应者后) textFieldDidBeginEditing【UITextFieldDelegate】 是否允许此文本框结束编辑(是否允许它释放第一响应者) textFieldShouldEndEditing【UITextFieldDelegate】 文本框已经结束编辑(已经释放第一响应者) textFieldDidEndEditing【UITextFieldDelegate】 是否允许可以改动文本框中的内容 textFieldShouldChangeCharactersInRange: replacementString:【UITextFieldDelegate】 监听键盘回车键被点击时调用 textFieldShouldReturn【UITextFieldDelegate】 监听键盘中文字的变动，用户实时输入，这里实时调用 用add Target 监听 UIControlEventEditingChanged 事件 [_rightTextField addTarget:self action:@selector(textFieldValueDidChanged:) forControlEvents:UIControlEventEditingChanged]; 退出键盘 释放第一响应者 第一响应者：能够叫出键盘的控件，可以切换 [textField resignFirstResponder] 结束可能成为第一响应者的控件的父控件的编辑状态 [self.view endEditing:YES] 判断文本视图是否有文字 hasText 输入视图 inputView 通常设置一个 toolBar 输入助理视图 inputAccessoryView textView.reloadInputViews() 切换键盘视图一定要刷新，否则不成功 "},"知识库/iOS 知识点/UI/UIControl.html":{"url":"知识库/iOS 知识点/UI/UIControl.html","title":"UIControl","keywords":"","body":" UIControl 控制事件 UIControl.Event UIControl 控制事件 UIControl.Event touchDown: 按下? touchDownRepeat: 连续按下? touchDragInside: touchDragOutside: touchDragEnter: touchDragExit: touchUpInside: touchUpOutside: touchCancel: valueChanged: primaryActionTriggered: editingDidBegin: editingChanged: editingDidEnd: editingDidEndOnExit: allTouchEvents: allEditingEvents: applicationReserved: systemReserved: allEvents: 启用 isEnabled 选中 isSelected 高亮 isHighlighted 添加监听控制事件的对象和方法 addTarget(target:action:for controlEvents) 监听控制事件的对象和方法removeTarget(target:action:for controlEvents) 移除 allTargets 发送某个控制事件的行为? sendAction(action: to target: for event) 发送控制事件的行为? sendActions(for controlEvents: ) "},"知识库/iOS 知识点/UI/UIResponder.html":{"url":"知识库/iOS 知识点/UI/UIResponder.html","title":"UIResponder","keywords":"","body":"UIResponder 文本编辑相关? cut copy paste select selectAll 键盘相关 成为第一响应者，调出键盘 becomeFirstResponder 辞去第一响应者，退出键盘 resignFirstResponder 检查是否是第一响应者 isFirstResponder 点击手势相关 touchesMoved touchesEnded touchesCancelled touchesEstimatedPropertiesUpdated 长按手势相关 pressesBegan 移动手势相关 motionBegan "},"知识库/iOS 知识点/UI/UITouch.html":{"url":"知识库/iOS 知识点/UI/UITouch.html","title":"UITouch","keywords":"","body":"UITouch 手指在视图中的坐标位置 现在的位置 location(in view:) 上一个位置 previousLocation(in view:) 现在的精确位置? preciseLocation(in view:) 上一个的精确位置? precisePreviousLocation(in view: ) 点击数 tapCount 时间戳 timestamp "},"知识库/iOS 知识点/UI/UIGestureRecognizer.html":{"url":"知识库/iOS 知识点/UI/UIGestureRecognizer.html","title":"UIGestureRecognizer","keywords":"","body":"UIGestureRecognizer 手指在视图中的坐标位置 手指数量 numberOfTouches 手指在视图中的位置 location(in view: UIView?) 某个手指在视图中的位置 location(ofTouch touchIndex: in view: ) 手势状态 state 添加手势监听对象和方法 addTarget( target: action: ) "},"知识库/iOS 知识点/函数指针、Block、Closure.html":{"url":"知识库/iOS 知识点/函数指针、Block、Closure.html","title":"Block / Closure / 函数指针","keywords":"","body":"函数指针、Block、Closure的使用 函数指针 函数的声明 返回值类型 函数名称([参数列表]) { ​ 写上那段需要被重用的代码； ​ 叫做函数体 } 指向函数的指针 声明 返回值类型 (*指针名) ([参数列表]); void (*pFunction) (); 表示声明了1个指向函数的指针，名字叫做pFunction。 这个指针只能指向没有返回值，并且没有参数的函数。 int (*pFun) (int num1, int num2); 表示声明了1个指向函数的指针，名字叫做pFun. 这个指针只能指向返回值为int类型，并且有两个整型的参数的函数。 初始化 取到符合指针条件的函数的地址 函数的名称就代表函数的地址 将地址赋值给指针变量 直接将符合条件的函数的名称赋值给这个指针。 使用指针间接调用指针指向的函数 void (*pFunc) () = test; // pFunc指针就指向了test函数 pFunc(); (*pFunc)(); Block (OC) OC中 方法 的声明 -(void) demo:(NSString *)name { function body; } OC 中声明 block 类型的 变量 返回值类型 (^block名称)(参数); void (^demo)(); void (^finishedBlock)(UIImage *image); OC 中声明 block 类型的 属性 // Block类型的属性：当网络任务完成时的回调block @property (nonatomic, copy) void (^finishedBlock)(UIImage *image); OC 中声明 block 类型的 函数参数 // 接收block参数的类方法 + (instancetype) operationWithURLString:(NSString *)urlString andFinishedBlock:(void (^)(UIImage *image)) finishedBlock; OC 中 block 的初始化 // 在Xcode中输入inlineblock就会出现 void (^demo)() = ^(参数) { NSLog(@\"快快快\"); }; [self setDemo:^{ NSLog(@\"快快快\"); }]; OC 中 block 的调用 demo(); Closure (Swift) Swift 中 函数/方法 的声明 func demo(_ name: Int) -> Void { 代码 } Swift 中声明 closure 类型的变量 /// 记录显示 VC 的闭包 var competionBlock:((_ clsName:String?)->())? (参数)->(返回值类型) Swift 中声明 closure 类型的函数参数 func tokenRequest(method:JLHTTPMethod = .GET, URLString:String, parameters:[String:Any]?, name:String? = nil, data:Data? = nil, completion: @escaping (_ json:Any?, _ isSuccess:Bool)->()){ } class func loadStatus(since_id:Int64 = 0, max_id:Int64 = 0, completion: @escaping (_ list:[[String:Any]]?, _ isSuccess:Bool)->()){ } Swift 中 closure 的初始化 // 完整写法 alphaAnim.completionBlock = {(anim, isSuccess)->() in // 需要执行回调 print(\"完成回调展现控制器\") self.competionBlock?(sender.clsName) } // 简写 alphaAnim.completionBlock = {_, _ in // 需要执行回调 print(\"完成回调展现控制器\") self.competionBlock?(sender.clsName) } "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时 原理 和 方法的调用.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时 原理 和 方法的调用.html","title":"Runtime 运行时原理及应用","keywords":"","body":" 运行时原理和方法的调用 OC中对象方法和类方法的调用过程 运行时原理和方法的调用 OC中对象方法和类方法的调用过程 对象方法的调用过程 比如，[p1 run]; 调用都是 [receiver selector]; 的形式，本质就是让对象在运行时发送消息的过程。 编译阶段: [receiver selector]; 方法调用被编译器转换为下面的 C 函数: objc_msgSend(receiver, selector) (不带参数) objc_msgSend(receiver, selector, org1, org2,...) （带参数） 运行时阶段: 消息接受者receiver寻找对应的selector。 通过receiver的isa指针找到receiver的Class(类)；isa意思是is a，如jim对象is a Person类。 在Class(类)的cache(方法缓存)的散列表中寻找对应的IMP(Implementation方法实现，IMP是一个指向C函数的指针)； 通过给出的 SEL(方法名) 去找到对应的函数Implementation，即找到该方法名对应的 IMP 函数指针，再通过此指针找到那个函数实现并调用。 如果在cache中没有找到对应的IMP的话，就继续在Class的method list中找对应的selector，如果找到，填充到cache中，并返回selector； 如果在Class中没有找到这个selector，就继续在它的superClass(父类)中寻找； 一旦找到对应的selector，直接执行它所在method结构体中对应的方法实现IMP指针指向的函数？。 若找不到对应的selector，消息被转发或者临时向receiver添加这个selector对应的实现方法，否则会发生崩溃。 类方法的调用过程 和对象方法调用差不多，流程如下： 通过类对象 isa 指针 找到所属的 Meta Class（元类）； 在 Meta Class（元类） 的 method list（方法列表） 中找到对应的 selector; 执行对应的 selector。 "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时 的应用.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时 的应用.html","title":"运行时 的应用","keywords":"","body":"Runtime 运行时 利用 运行时 机制的 KVC KVO 获取属性列表、成员变量列表和方法列表 反射机制 注册监听通知 监听点击事件 代理模式？ 注册监听通知 实例应用 QQ聊天 特点 一对多，可以有多个监听者监听事件，只要有注册的监听者，在注销监听之前，都可以接收到通知！ 发生事件时，将通知发送给通知中心，通知中心再广播通知！，效率相对代理较低 如果层次嵌套太深，可以使用通知传值 使用 // 发布通知 NotificationCenter.default.post(name:Notification.Name.init(rawValue:JLUserShouldLoginNotification), object: \"bad token\") // 注册监听通知 NotificationCenter.default.addObserver(self, selector: #selector(userLogin), name: NSNotification.Name(rawValue: JLUserShouldLoginNotification), object: nil) // 移除通知，防止内存泄漏 NotificationCenter.default.removeObserver(self) 代理模式 特点 一对一，只能有一个监听者监听事件，最后一个设置的代理对象有效！ 发生事件时，直接让代理执行协议方法，效率更高 直接反向传值 如果层次嵌套太深，不利于传值，可以使用通知传值 监听点击事件 btn.addTarget(self, action: #selector(buttonTapped(_:)), for: .touchUpInside) "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVC 和 构造函数.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVC 和 构造函数.html","title":"运行时应用 - KVC 和 构造函数","keywords":"","body":"KVC 构造函数 即字典转模型 KVC 字典转模型 Key - Value - Coding 字典转模型，用字典给对象属性赋值 setValueForKey setValuesForKeys(_keyedValues: dict) dictionaryWithValuesForKeys KVC是利用OC的运行时 使用KVC创建构造函数注意点： 用KVC字典转模型方式创建构造函数时，必须直接或间接继承自NSObject，否则没有setValueForKey等KVC方法 想要用 KVC 赋值的属性，必须在前面使用@objc显式标记(Swift4.0以后)，否则无法成功【或在类名前用@objcMembers标记】 定义模型属性时 如果是对象，通常都是可选的 ( Optional ) 在需要的时候才创建，不需要就不创建，节省内存空间 避免写构造函数，可以简化代码 如果是基本数据类型，不能设置成可选的，而且要设置初始值，否则 KVC 会崩溃 如Int 是一个基本数据类型的结构体，OC 中没有相应的类，只有基本数据类型int，而基本数据类型没有可选一说，一旦设置成可选，KVC就找不到这个key了 如果需要使用 KVC 设置数值，属性(或方法)不能是私有 private 的，否则KVC会崩溃【可以使用@objc private】 在OC中，可以在私有扩展中\"藏\"属性，但是在运行时依然可以获取到 而Swift中，一旦将属性设置为 private ，运行时无法获取到此key，所以 KVC 无法使用 如果子类没有重写父类的 KVC 方法init(dict:) ，调用的时候，会直接调用父类的方法，setValues时，会给子类的属性一并赋值 如果字典中的key比对象的属性多，调用setValueforUndefinedKey并且函数体中不写任何实现，来保证在设置undefinedKey时不崩溃。 // KVC的基本实现 // 因为KVC是OC的东西，所以类必须是NSObject的子类才能使用KVC class Teacher:NSObject { @objc var name:String? // 可空、可选属性【因为在Swift中是结构体，对应OC是NSString对象】 @objc var age:Int = 0 // Int 是一个基本数据类型的结构体，OC 中没有相应的类，只有基本数据类型int，而基本数据类型没有可选一说，一旦设置成可选，KVC就找不到这个key了 init(dict:[String:Any]) { // 在调用self的KVC方法之前，必须保证本类和父类都已初始化 //【先将父类初始化，本类因为只有一个可选属性，可初始化为空，所以相当于本类自动初始化了】 super.init() setValuesForKeys(dict) } // 重写父类的方法 override func setValue(_ value: Any?, forUndefinedKey key: String) { // 没有调用 super，将父类的代码完全覆盖，保证碰见undefined key的时候不会崩溃 } } "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVO.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - KVO.html","title":"运行时应用 - KVO","keywords":"","body":"KVO 监听 NSObject 子类 属性变化 Key - Value - Observer 监听对象属性变化 addObserver(forKeyPath: ) 注册监听者，监听对象的 属性 变化 // KVO 监听父视图的 contentOffset scrollView?.addObserver(self, forKeyPath: \"contentOffset\", options: .new, context: nil) // 所有 KVO 方法会统一调用此方法 func observeValue(forKeyPath keyPath: String?, of object: Any?, change: [NSKeyValueChangeKey : Any]?, context: UnsafeMutableRawPointer?) // 移除监听者，防止内存泄漏 superview?.removeObserver(self, forKeyPath: \"contentOffset\") "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - YYModel.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - YYModel.html","title":"运行时应用 - YYModel","keywords":"","body":"YYModel JSON Object 和 Json Data JSON Object Dictionary 类型 Array 类型 JSON Data Data 类型 其它 转到 模型 字典 -> 模型 model.yy_modelSet(with:[:]) JSONObject -> 模型 model.yy_modelSet(withJSON:Any) 字典数组 转到 模型数组 NSArray.yy_modelArray(with: JLEmoticonPackage.self, json: array) as? [JLEmoticonPackage] 模型 转到 其它 模型 -> 字典 model.yy_modelToJSONObject() 模型 -> JSON data model.yy_modelToJSONData() 用字典键值对给模型设置属性 ​ model.yy_modelSet(with:Dict) "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 命名空间和反射机制.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 命名空间和反射机制.html","title":"运行时应用 - 命名空间和反射机制","keywords":"","body":" 命名空间 & 反射机制 命名空间 反射机制 在 OC 中如何利用反射机制 命名空间 & 反射机制 命名空间 Swift 中有命名空间 在同一个命名空间下，全局共享 第三方框架使用 Swift 如果直接拖拽到项目中，从属于一个命名空间，很可能有冲突！ 尽量使用 cocoapods 管理第三方框架 反射机制 反射机制 的概念 对于任意一个类，都能够知道这个类的所有属性和方法 对于任意一个对象，都能够调用它的任意一个方法和属性 这种动态获取的信息以及动态调用对象的方法的功能称为 java语言的反射机制 Swift 中 NSClassFromString (反射机制) 的写法 反射最重要的目的，就是为了解耦！ 搜索 反射机制和工厂方法！ 提示：第一印象会发现一个简单的功能，写的很复杂 但是，封装的很好，而且弹性很大 在 OC 中如何利用反射机制 利用 NSClassFromString 方法来使用字符串获得类 利用 isMemberOfClass: 判断是否是一个类 利用 isKindOfClass 判断是否是一个类或者它的子类 利用 conformsToProtocol 判断对象是否遵守某个协议，即实现了此协议的方法实现 利用 respondsToSelector 判断是否实现了某一个方法【判断代理是否实现某方法】 利用 performSelector 或者 objc_msgSend 间接调用方法【webView 和 JavaScript 互相调用方法时使用】 Swift中使用反射机制 NSClassFromString ，字符串动态创建类对象 // 根据字符串动态创建类对象 // 本可以从info.plist中使用CFBundleName键取的，但是如果名字中有空格或-等，会被替换，所以用下面方法拿命名空间 // 获取该项目中任意一个类的类名【命名空间.类名】 let nameComponents = (NSStringFromClass(type(of: self)) as String).split(separator: \".\") // 获取该项目的命名空间【好像只有带横线的能创建成功】 guard let nameSpace = nameComponents.first else { return } // 构造创建类的字符串 let cls_name = nameSpace + \".\" + \"ViewController\" // 根据类名字符串创建类 guard let cls = NSClassFromString(cls_name) as? ViewController.Type else { return } // 创建类对象 let vc = cls.init() 修改命名空间、产品名 "},"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 获取成员变量列表、属性列表、方法列表.html":{"url":"知识库/iOS 知识点/Runtime 运行时原理及应用/运行时应用 - 获取成员变量列表、属性列表、方法列表.html","title":"运行时应用 - 获取成员变量列表、属性列表、方法列表","keywords":"","body":"利用运行时获取属性列表和方法列表 用 KVC 字典转模型方式创建构造函数时，必须直接或间接继承自 NSObject，否则没有 setValueForKey 等KVC方法 在 swift4.0 以后要使用 runtime 获取的属性和方法必须显式标记 objc 才可以用 runtime 获取 如果只是获取属性列表的话【懒加载和计算属性都可获取的到】，不需要继承自 NSObject，只需标记@objc或@objcMembers即可 使用类方法获取属性列表时，在class_copyPropertyList(self, &cCount)中，第一个参数必须传入self，不能用object_getClass(self)，否则无法获取 与之相反，用对象方法获取属性列表时，第一个参数只能传入object_getClass(self) @objcMembers 加在类声明前面，那么它、它的子类、扩展里的属性和方法都会隐式的加上 @objc @objc 在属性或方法前加@objc，表示暴露给OC的运行时，在运行时可以用KVC给此属性赋值，也可获取到此属性或方法名 如果在扩展（extension）前加上 @objc，那么该扩展里的属性和方法都会隐式的加上 @objc。 @nonobjc 在属性前加@nonobjc，KVC无法赋值，运行时无法获取到属性或方法列表 如果在扩展（extension）前加上 @nonobjc，那么该扩展里的属性和方法都不会隐式的加上 @objc。 // Swift import Foundation @objcMembers class Person { // 存储属性，类型可在OC中用NSString对象代表，可以被初始化为nil var name:String? // 存储属性，类型不能在OC中用对象代表，不能被初始化为nil，必须设置初始值 @nonobjc var age:Int = 0 // 懒加载属性 lazy var scores = { return 80 + 6 }() // 计算属性 var money:Int { get { return 200 + 300 } } // 计算属性？ var interests:String = { return \"爱好\" }() // 存储属性，closure类型 var finishedCallBack:((_ result:[String])->())? // 类方法利用运行时获取属性列表【懒加载和计算属性都可获取的到】 // 类方法获取属性列表 // class_copyPropertyList(self, &cCount)与对象方法不同 class func propertyList()->[String] { var count:UInt32 = 0 // 用来存储属性的数量, C的类型 // 1. 获取到元素类型为objc_property_t的属性数组 let list = class_copyPropertyList(self, &count) print(\"使用类方法获取属性数量为:\\(count)\") // 2. 遍历数组获取属性名字列表 var propertyNames = [String]() // 用来保存属性名 for i in 0.. 每8位为一组 -> 8位为 1 byte(字节) -> Char占1字节 -> C语言字符串 let c_p_ame = property_getName(prop_t) // 将C字符串转为Swift字符串 let propName = String(cString: c_p_ame) // 添加到属性名数组 propertyNames.append(propName) } // 释放 C 语言对象 free(list) return propertyNames } // 类方法获取方法列表 // class_copyMethodList(self, &cCount)与对象方法不同 class func methodList()->[String] { var count:UInt32 = 0 // 用来存储方法的数量, C的类型 // 1. 获取到元素类型为SEL的数组 let list = class_copyMethodList(self, &count) print(\"使用类方法获取方法数量为:\\(count)\") // 2. 遍历数组获取方法名列表数组 var methodNames = [String]() // 用来保存方法名 // 遍历SEL数组获取方法名 for i in 0..[String] { var count:UInt32 = 0 // 用来存储方法的数量, C的类型 // 1. 获取到元素类型为ivar的属性数组 let list = class_copyIvarList(self, &count) print(\"使用类方法获取成员变量数量为:\\(count)\") // 2. 遍历数组获取成员变量名 var ivarNames = [String]()// 用来保存成员变量名字 for i in 0.. "},"知识库/iOS 知识点/绘图、动画/CoreGraphics 核心绘图.html":{"url":"知识库/iOS 知识点/绘图、动画/CoreGraphics 核心绘图.html","title":"绘图和动画","keywords":"","body":" CoreGraphics 核心绘图 Quartz2D UIBezierPath 在 UIView 的 drawRect 中进行绘图 CGRect CoreGraphics 核心绘图 Quartz2D 二维绘图引擎，包含在 CoreGraphics 中 绘制步骤 以下绘制代码写在 UIView 的 drawRect 中 获取 图形上下文 对象 CGContextRef 相当于草稿纸 ，是layer类型的，和当前view的大小相同 不同的上下文决定着不同的输出目标 主要包含以下信息 绘图路径 (各种各样的图形) 绘图状态 (颜色、线宽、样式、旋转、缩放、平移、图片裁剪区域等) 输出目标 绘制到什么地方去？ UIView、图片、pdf文件、Bitmap或者显示器的窗口上、打印机等 向 图形上下文 对象中添加 路径 渲染 (把 图形上下文 中的图形绘制到对应的设备上) 绘制图形 线条 三角形 矩形 圆 弧 绘制文字 绘制、生成图片 (图像) 读取、生成 PDF 截图、裁剪图片 自定义 UI 控件 通过继承 UIView，重写 drawRect 方法实现在控件上绘制各种内容 通过继承 UIView 实现自定义的 UIImageView 实现自定义的 下载进度条 控件 幸运转盘控件 实际应用 画板涂鸦 手势解锁 将矩形头像裁剪为圆形 报表 折线图 饼状图 柱状图 数据类型和函数基本都以 CG 作为前缀 ​ CGContextRef ​ CGPathRef ​ CGContextStrokePath(ctx) UIBezierPath 矩形 +bezierPathWithRect 圆角矩形 +bezierPathWithRoundedRect: radius: 椭圆 +bezierPathWithOvalInRect 圆弧 +bezierPathWithArcCenter 把笔头提到某坐标 -moveToPoint 从笔头处向某坐标处添加一条线 -addLineToPoint 设置线宽-setLineWidth 设置连接处的样式 -setLineJoinStyle 设置头尾的样式 -setLineCapStyle UIColor对象setStroke、setFill、set(同时设置描边和填充颜色)设置颜色 描边 -stroke 填充 -fill 使用奇偶填充规则 -useEvenOddRule 在 UIView 的 drawRect 中进行绘图 绘图代码为什么要写在drawRect当中 因为在这个方法中可以获取到正确的上下文 rect 参数的含义 当前View的bounds drawRect 什么时候调用 这个方法是系统调用，不能手动调用！！！ (1)当此view第一次显示的时候调用 (2)当此view进行重绘redraw的时候会调用(理解成tableView的刷新) 如何重绘 理解成tableView的刷新，当绘图的path中的坐标或其他数据改变时，如果不刷新重新显示的话，view显示的还是原来的绘图 (1)调用某个需要重绘的view对象的setNeedsDisplay。 (2)调用某个需要重绘的view对象的setNeedsDisplayInRect rect:参数表示需要重绘的区域 为什么不能手动调用drawRect 因为手动调用时可能获取不到正确的上下文，画也是白画。 如果需要重新画一些东西的话，调用setNeedsDisplay，系统会自动在适当的时候调用drawRect CGRect offsetBy 偏移后返回一个 Rect insetBy 向内收缩后返回一个 Rect "},"知识库/iOS 知识点/绘图、动画/动画相关.html":{"url":"知识库/iOS 知识点/绘图、动画/动画相关.html","title":"动画相关","keywords":"","body":"CALayer 图层、形变、核心动画、物理仿真 动画 UIView.animate 属性动画？ UIIMageView 序列帧动画 layer的Transform 形变 核心动画 CAAnimation pop 框架 UIView.animate 属性动画？ UIIMageView 序列帧动画 layer的Transform 形变 位置移动 变大、变小 旋转 iOS 系统中 UIView 封装的旋转动画 - 默认顺时针旋转 - 就近原则，往某个位置旋转的时候，那边弧度小就从哪边转 - 要想实现同方向旋转，需要调整一个 非常小的数字(近) - 如果想实现 360 旋转，需要核心动画 CABaseAnimation 核心动画 CAAnimation 步骤 创建动画对象 (做什么动画) 基本动画 CABasicAnimation (实例应用: JL微博_JLVisitorView) 透明度渐变 自旋转 关键帧动画 CAKeyframeAnimation 比如，走一个特定的路径 绕圆旋转 动画到某些指定的值 组动画 (将各种动画叠加使用) CAAnimationGroup 转场动画 CATransition 设置动画对象属性 (怎么做动画) keyPath 要做动画的属性 fromValue 从哪个值开始 toValue 到哪个值 byValue 在自身 value 的基础上加多少 不希望回到原来位置 anim.fillMode = kCAFillModeForwards; anim.removedOnCompletion = NO duration 每次动画持续时长 repeatCount 重复次数 添加动画到视图的 layer (对谁做动画) pop 框架 和 核心动画 使用方法差不多 实例应用: JL微博中 JLComposeTypeView 显示撰写微博按钮时 使用方法 // 创建动画 let anim:POPSpringAnimation = POPSpringAnimation(propertyNamed: kPOPLayerPositionY) // 设置动画属性 anim.fromValue = btn.center.y anim.toValue = btn.center.y + 400 // 设置动画时间，最后一个 btn 的启动时间最早 anim.beginTime = CACurrentMediaTime() + CFTimeInterval(v.subviews.count - i) * 0.025 // 添加动画 // propertyName 用的 layer 动画就往layer上加，否则往 view 上加 btn.layer.pop_add(anim, forKey: nil) "},"知识库/iOS 知识点/绘图、动画/UIDynamic 物理仿真.html":{"url":"知识库/iOS 知识点/绘图、动画/UIDynamic 物理仿真.html","title":"UIDynamic 物理仿真","keywords":"","body":"UIDynamic 物理仿真 动画者 UIDynamicAnimator 重力行为 UIGravityBehavior 碰撞行为 UICollisionBehavior 甩行为 UISnapBehavior 附着行为 UIAttachmentBehavior 推行为 UIPushBehavior 动力学元素自身属性 弹性 elasticity 密度 density 摩擦力 friction resistance "},"知识库/iOS 知识点/性能优化/性能优化.html":{"url":"知识库/iOS 知识点/性能优化/性能优化.html","title":"性能优化","keywords":"","body":"性能优化 如何做出圆角，不用 CornerRadius ？ "},"知识库/iOS 知识点/其他/常用类.html":{"url":"知识库/iOS 知识点/其他/常用类.html","title":"iOS 其他知识点","keywords":"","body":"常见类 屏幕类 UIScreen 窗口类 UIWindow 视图 UIView 文本框/标签 UILabel 按钮 UIButton 文本输入框 UITextField 文本输入视图 UITextView 能滚动的文字显示控件 图片视图/图片框 UIImageView 图片类 UIImage 视图控制器 UIViewController 导航控制器 UINavigationController 导航条 UINavigationBar 标签控制器 UITabBarController 表格视图 UITableView 表格视图控制器 UITableViewController 集合视图/九宫格视图 UICollectionView 集合视图/九宫格视图控制器 UICollectionViewController滚动视图 UIScrollView 设备 UIDevice 应用程序对象类 UIApplication 应用程序代理类 UIApplicationDelegate 分页控件 UIPageControl 菊花、进度指示器 UIActivityIndicator 网页显示控件 UIWebView 工具条 UIToolBar 数据选择器 UIPickerView 日期选择器 UIDatePicker 对话框(中间弹框) UIAlertViewController 底部弹框 UIActionSheet 进度条 UIProgressView 滑块 UISlider 开关 UISwitch Runloop 运行循环/消息循环 Runtime 运行时 UIControl UIResponder UITouch UIGestureRecognizer 手势类 UIEvent CALayer 图层类 CGRect URL WebKit WKWebView CoreGraphics 核心绘图 CoreAnimation 核心动画 "},"知识库/iOS 知识点/其他/Xcode项目重命名.html":{"url":"知识库/iOS 知识点/其他/Xcode项目重命名.html","title":"Xcode项目重命名","keywords":"","body":"Xcode项目重命名 "},"知识库/iOS 知识点/其他/访问控制 Access Control.html":{"url":"知识库/iOS 知识点/其他/访问控制 Access Control.html","title":"访问控制","keywords":"","body":"访问控制 Access Control private 修饰的属性或者方法只能在本类的作用域且在当前文件（.swift文件中?）内能访问，子类无法使用？ internal 默认访问级别，可写可不写。 修饰的属性和方法在源代码的整个模块都可以访问。 如果是框架或库代码，则在整个框架都可以访问，框架以外是不可以访问的。 如果是App代码，则在整个App内部都是可以访问的。 fileprivate 修饰的属性或者方法只能在当前文件中访问。如果一个文件中含有多个类，也是可以访问的 public 可以被任何代码访问。但其他模块不可以被override和继承，而在模块内是可以被override和继承的。 open 可以被任何模块的代码访问，包括override和继承。 final inal关键字在大多数的编程语言中都存在，表示不允许对其修饰的内容进行继承或者重新操作。Swift中，final关键字可以在class、func和var前修饰。 通常大家都认为使用final可以更好地对代码进行版本控制，发挥更佳的性能，同时使代码更安全。 OC 访问控制关键字 "},"知识库/iOS 知识点/其他/日期时间相关.html":{"url":"知识库/iOS 知识点/其他/日期时间相关.html","title":"日期时间相关","keywords":"","body":" 日期相关 NSDate、NSDateFormatter、NSCalendar 日期格式 日期相关 NSDate、NSDateFormatter、NSCalendar Tue Sep 15 12:12:00 +0800 2015 星期 月 日 时:分:秒 时区 年 要从一个字符串中解析得到准确的时间，必须要指定 正确的格式字符串 ，以及对应的 时区标示 日期格式 年 y 将年份 (0-9) 显示为不带前导零的数字 yy 以带前导零的两位数字格式显示年份 yyy 以三位数字?格式显示年份 yyyy 以四位数字格式显示年份 月 M 将月份显示为不带前导零的数字 (如一月表示为 1) MM 将月份显示为带前导零的数字 (例如 01/12/01) MMM 将月份显示为缩写形式 (例如 Jan) MMMM 将月份显示为完整月份名 (例如 January) 日 d 将日显示为不带前导零的数字 (如 1) dd 将日显示为全名 (例如 Sunday) 星期 EEE 将日显示为缩写形式 (例如 Sun) EEEE 将日显示为全名 (例如 Sunday) 小时 h 使用 12 小时制将小时显示为不带前导零的数字 (例如 1:15:15 PM) hh 使用 12 小时制将小时显示为带前导零的数字 (例如 01:15:15 PM) H 使用 24 小时制将小时显示为不带前导零的数字 (例如 1:15:15) HH 使用 24 小时制将小时显示为带前导零的数字 (例如 01:15:15) 分钟 m 将分钟显示为不带前导零的数字 (例如 12:1:15) mm 将分钟显示为带前导零的数字 (例如 12:01:05) 秒 s 将秒显示为不带前导零的数字 (例如 12:15:5) ss 将秒显示为带前导零的数字 (例如 12:15:05) f 显示秒的小数部分 ff 将精确显示到百分之一秒 ffff 将精确显示到万分之一秒 用户自定义格式中最多可使用七个 f 符号 上午&下午 t 使用 12 小时制 中午之前任意一小时显示大写的 A 中午到 11:59 PM 之间的任一小时显示大写的 P tt 对于使用 12 小时制的区域设置 中午之前任一小时显示大写的 AM 中午到 11:59 PM 之间的任一小时显示大写的 PM 对于使用 24 小时制的区域设置，不显示任何字符 时区 z 显示不带前导零的时区偏移量 zz 显示带前导零的时区偏移量 (例如 -08) zzz 显示完整的时区偏移量 (例如 -0800) 纪元 gg 显示时代/纪元字符串 (例如 A.D.) "},"知识库/iOS 知识点/其他/正则表达式 Regular Expression.html":{"url":"知识库/iOS 知识点/其他/正则表达式 Regular Expression.html","title":"正则表达式 Regular Expression","keywords":"","body":"iOS 中的使用 URL 正则表达式 Pattern let urlPattern = \"[a-zA-Z]*://[a-zA-Z0-9/\\\\.]*\" 正则表达式常用选项 CaseInsensitive 忽略大小写 DotMatchesLineSeparators . 匹配换行符 匹配方案 . 匹配任意字符 * 匹配 0~ 任意 多个字符 ? 尽可能少的重复 匹配函数 matchesInString 重复匹配多次 pattern 如果匹配成功，生成 NSTextCheckingResult 数组 firstMatchesInString 匹配第一个 pattern 如果匹配成功，生成 NSTextCheckingResult 匹配结果 numberOfRanges 匹配的 range 计数 如果匹配成功，是 () 的数量 + 1 rangeAtIndex "},"知识库/iOS 知识点/其他/UITest 界面测试.html":{"url":"知识库/iOS 知识点/其他/UITest 界面测试.html","title":"UITest 界面测试","keywords":"","body":"UITest 界面测试 比如界面有个 TextField 和 button，你想点击 TextField 输入 我爱你，然后点击 button，就这个操作顺序，可能会重复很多次 这时，创建 UITest，录制一次上面的步骤，这个步骤就可以被记录下来，后面自己在调试时就就可直接运行录制的操作顺序，而不用一直重复点击输入了。 "},"知识库/iOS 知识点/其他/UnitTest 单元测试.html":{"url":"知识库/iOS 知识点/其他/UnitTest 单元测试.html","title":"UnitTest 单元测试","keywords":"","body":"UnitTest 单元测试 就像在 playground 中测试 某个函数或者表达式是否正确一样，不需要在模拟器或真机上运行，直接点函数左侧的运行按钮运行。 界面测试 "},"知识库/iOS 知识点/iOS库/iOS库介绍.html":{"url":"知识库/iOS 知识点/iOS库/iOS库介绍.html","title":"iOS库","keywords":"","body":"iOS库的介绍 开源库 闭源库 .a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。.a，要有.h文件以及资源文件配合，.framework文件可以直接使用。总的来说，.a + .h + sourceFile = .framework。所以创建静态库最好还是用.framework的形式。 动态库 动态库即动态链接库（Windows 下的 .dll，Linux 下的 .so，Mac 下的 .dylib/.tbd） 与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。 动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行（Linux 下喜闻乐见的 lib not found 错误）。 系统动态库：链接时不复制，程序运行时由系统动态加载到内存，供程序调用，系统只加载一次，多个程序共用，节省内存 静态库 静态库即静态链接库（Windows 下的 .lib，Linux 和 Mac 下的 .a) 链接时，静态库会被完整地复制到可执行文件中，被多次使用就有多份冗余拷贝 是因为静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。 静态库的好处很明显，编译完成之后，库文件实际上就没有作用了。目标程序没有外部依赖，直接就可以运行。当然其缺点也很明显，就是会使用目标程序的体积增大。 用户拿到的文件有很多头文件.h 和 资源包 和 编译过的二进制文件 .a即没有公开的那些文件被编译进了.a或.framework里面。 iOS Framework 除了上面提到的 .a 和 .dylib/.tbd 之外，Mac OS/iOS 平台还可以使用 Framework。Framework 实际上是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。 在 iOS 8 之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有苹果自家的 UIKit.Framework，Foundation.Framework 等。这种限制可能是出于安全的考虑（见这里的讨论)。换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了。 由于上面提到的限制，开发者想要在 iOS 平台共享代码，唯一的选择就是打包成静态库 .a 文件，同时附上头文件（例如微信的SDK）。但是这样的打包方式不够方便，使用时也比较麻烦，大家还是希望共享代码都能能像 Framework 一样，直接扔到工程里就可以用。于是人们想出了各种奇技淫巧去让 Xcode Build 出 iOS 可以使用的 Framework，具体做法参考这里和这里，这种方法产生的 Framework 还有 “伪”(Fake) Framework 和 “真”(Real) Framework 的区别。 iOS 8/Xcode 6 推出之后，iOS 平台添加了动态库的支持，同时 Xcode 6 也原生自带了 Framework 支持（动态和静态都可以），上面提到的的奇技淫巧也就没有必要了（新的做法参考这里）。为什么 iOS 8 要添加动态库的支持？唯一的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别。系统的 Framework 不需要拷贝到目标程序中，我们自己做出来的 Framework 哪怕是动态的，最后也还是要拷贝到 App 中（App 和 Extension 的 Bundle 是共享的），因此苹果又把这种 Framework 称为Embedded Framework。 "},"知识库/iOS 知识点/iOS库/制作静态库.a和.framework.html":{"url":"知识库/iOS 知识点/iOS库/制作静态库.a和.framework.html","title":"制作静态库.framework","keywords":"","body":" 制作静态库 制作.a静态库 制作.framework 制作静态库 制作.a静态库 制作.a静态库 制作.framework iOS 静态库.a制作以及打包bundle文件 新建工程，创建Framework库工程 往工程中添加文件 设置相关项 TARGETS -> General -> Deployment Info -> Deploymnet Target 调整最低支持的iOS系统 TARGETS -> Build Settings 添加可能缺失的Architectures架构 Build Active Architecture Only 设置为No，意思是当前打包的.framework支持所有设备，否则打包时只支持当前版本的真机或模拟器的架构 搜索linking，设置Dead Code Stripping为No，是编译选项优化，包瘦身(可不改) Mach-O Type 选中 StaticLibrary (静态库)，Xcode默认为动态库 TARGETS -> Build Phases 设置要公开的头文件, 将需要呈现给来的头文件,直接从Project拖到Public中. 不想呈现出来的.h文件不建议拖到Private中. 放在project中即可 在进行编译之前应该设置为release模式 快捷键(command + shift + ,) 编译生成.framework 分别在真机和模拟器状态下按(command + B)编译生成.Framework文件 获取.framework文件夹 右键点击“项目” - \"Products\"文件夹中生成的WeexDCIOSRichAlertFramework.Framework文件，\"Show in Finder\" 打开后会有分别生成的真机Release-iphoneos和模拟器Release-iphonesimulator的.Framework文件 .frame文件夹中的二进制文件才是库文件 真机版本和模拟器版本framework合并 sudo lipo -create 真机framework文件路径 模拟器framework文件路径 -output 要输出的文件路径 sudo lipo -create /Users/joyawang/Desktop/OCAdditions/Release-iphoneos/OCAdditions.framework/OCAdditions /Users/joyawang/Desktop/OCAdditions/Release-iphonesimulator/OCAdditions.framework/OCAdditions -output /Users/joyawang/Desktop/OCAdditions/OCAdditionsFrame 在项目中使用 可能要根据库中类的不同，在Build Settings -> Other Linker Flags使用不同的链接参数 -ObjC -all_load -force_load 库文件路径 -force_load $(PROJECT_DIR)/测试的/Frameworks/OCAdditions.framework/OCAdditions "},"知识库/iOS 知识点/iOS库/库支持的CPU架构、链接库的参数、打印环境变量.html":{"url":"知识库/iOS 知识点/iOS库/库支持的CPU架构、链接库的参数、打印环境变量.html","title":"库支持的CPU架构、链接库的参数、打印环境变量","keywords":"","body":" 库支持的CPU架构、链接库的参数、打印环境变量 iOS的CPU架构 project - target - building setting - Arhitectures 设置 链接库的参数 在Build Settings-Linking-Other Linker Flags 打印所有环境变量 库支持的CPU架构、链接库的参数、打印环境变量 iOS的CPU架构 iOS测试分为模拟器测试和真机测试，处理器分为32位和64位处理器 使用 lipo -info /Users/joyawang/OCAdditionsFrame 查看库支持的架构 模拟器架构 i386架构 模拟器32位处理器测试，（iphone5,iphone5s以下的模拟器） x86_64架构 模拟器64位处理器测试，(iphone6以上的模拟器) 真机架构 armv7,或者armv7s架构 真机32位处理器（iphone4真机/armv7, ipnone5,iphone5s真机/armv7s） arm64架构 真机64位处理器需要。(iphone6,iphone6p以上的真机) project -> target -> building setting -> Arhitectures 设置 debug属性设置为no的时候，会编译支持所有架构的版本，编译的速度会变慢，设置为yes 的时候，只编译当前的architecture版本，编译速度快。 一般情况下，debug 设置为yes，release为no，这样发行版本能适应不同设备。 链接库的参数 在Build Settings-Linking-Other Linker Flags -ObjC 这个flag告诉链接器把库中定义的Objective-C类和Category都加载进来。这样编译之后的app会变大（因为加载了其他的objc代码进来）。但是如果静态库中有类和category的话只有加入这个flag才行。 -all_load 这个flag是专门处理-ObjC的一个bug的。用了-ObjC以后，如果类库中只有category没有类的时候这些category还是加载不进来。变通方法就是加入-all_load或者-force-load。-all_load会强制链接器把目标文件都加载进来，即使没有objc代码。 注意：假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件 -force_load 这个flag所做的事情跟-all_load其实是一样的，只是 -force_load 需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载 ，-force_load在xcode3.2后可用。 -force_load $(BUILT_PRODUCTS_DIR)/MJExtension/libMJExtension.a 打印所有环境变量 在Xcode: View > Navigators > Show Report Navigator查看 在Build phases 中点+创建一个Script，里面写上env，就可打印环境变量出来，可以Command+9去那里看 $(inherited)表示 $(TARGET_NAME) Target project name ${PODS_ROOT} $(SRCROOT) The path to the project file (such as Nuno.xcodeproj) 项目根目录下【cloudExchange Project的根目录，比如qiyu手动添加的frameworks所在的位置】 $(PROJECT_DIR) 整个项目(工程)的根目录 $(BUILT_PRODUCTS_DIR) "},"知识库/iOS 知识点/iOS库/lipo命令.html":{"url":"知识库/iOS 知识点/iOS库/lipo命令.html","title":"lipo命令","keywords":"","body":" lipo命令 lipo -info xxx 查看库支持的CPU架构 lipo -create xxx xxx -output xxx 合成支持不同CPU架构的库 lipo xxx -thin xxx -output xxx 提取支持特定CPU架构的库 lipo -remove xxx -output xxxx 移除掉特定的cpu架构的文件 lipo命令 lipo -info xxx 查看库支持的CPU架构 lipo -info LoginSDK.a lipo -create xxx xxx -output xxx 合成支持不同CPU架构的库 lipo -create /Users/zyh/Desktop/libSyncSDK.i386.a /Users/zyh/Desktop/libSyncSDK.arm.a -output /Users/zyh/Desktop/libSyncSDK.a lipo xxx -thin xxx -output xxx 提取支持特定CPU架构的库 发现有i386 armv7 armv7s，实际安装到真机上我们只需要armv7就可以了，我们就用lipo命令将armv7的提取出来 lipo LoginSDK.a -thin armv7 -output arm/LoginSDK.a 这样在arm文件夹中得LoginSDK.a 就是armv7架构了，大家可以用lipo -info 命令查看 lipo -remove xxx -output xxxx 移除掉特定的cpu架构的文件 lipo -remove armv7 -output arm/LoginSDK.a "},"知识库/iOS 知识点/iOS库/iOS链接编译库的过程中的问题总结.html":{"url":"知识库/iOS 知识点/iOS库/iOS链接编译库的过程中的问题总结.html","title":"iOS链接编译库的过程中的问题总结","keywords":"","body":"iOS链接编译库的过程中的问题总结 库的问题 如果我添加一个分类,并且公开其头文件,然后在项目中调用会出现奔溃的现象,直接报改调用的方法找不到 Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFConstantString documentPath]: unrecognized selector sent to instance 0x100fdc008' 出现原因：由于UNIX的静态库实现、linker和Objective-C的动态结构三者之间的问题引起的。Objective-C并不为每个函数定义linker symbol，它只为每个class生成linker symbol。（objc的动态结构）如果你为一个已存在的class创建了category，那么linker并不知道要将原始class实现和category实现联系起来。这就导致了最终程序中的对象没法响应category中的方法。 解决办法: 在使用库的项目中的Targets中的Build Settings中的Other Linker Flags中添加 -all_load ,然后重新运行。 "},"知识库/iOS 知识点/iOS库/CocoaPods/CocoaPods.html":{"url":"知识库/iOS 知识点/iOS库/CocoaPods/CocoaPods.html","title":"CocoaPods","keywords":"","body":" CocoaPods 用CocoaPods做iOS程序的依赖管理 安装 管理第三方框架 卸载 CocoaPods 用CocoaPods做iOS程序的依赖管理 用CocoaPods做iOS程序的依赖管理 唐巧的博客 安装 先安装ruby运行环境 查看当前 Ruby 源地址 gem source -l 添加 ruby 源 gem sources -a https://gems.ruby-china.com 两个源 https://rubygems.org/ https://gems.ruby-china.com 设置源 sudo gem sources -a https://ruby.taobao.org 删除源 sudo gem sources -r https://rubygems.org/ 删除ruby源 gem sources --remove http://gems.ruby-china.org/ 查看 ruby 版本 ruby -v 升级gem sudo gem update --system 安装CocoaPod sudo gem install cocoapods pod setup sudo gem install -n /usr/local/bin cocoapods 更新 cocoapods sudo gem update cocoapods 查看最新的 cocoapods 版本 gem search cocoapods 查看当前 Cocoapods 的版本pod --version 查看当前项目所安装的所有 Pods 的版本 cat Podfile.lock 管理第三方框架 CocoaPods使用 搜索 pod search SDWebImage 搜索pod search afnetworking --simple 切换到项目的根目录 echo \"pod 'SDWebImage'\" > Podfile 【会把pod 'SDWebImage'添加到pod文件中】 安装 pod install 升级 pod update 删除某框架 从 podfile 中删除，然后 pod install? pod deintegrate 更新pod pod install 同步其他团队成员的修改时，请使用pod install。 注意，pod outdated和pod update都会更新spec仓库，但是pod install不会，所以对于经常使用的pod库，建议经常pod outdated关注更新情况。 pod outdated需要更新依赖库时，先使用pod outdated查看有哪些库有更新，再使用pod update PODNAME有目的的更新指定库 pod update PODNAME 将某个pod库更新到最新版本时 pod update更新所有(Podfile中标明的)pods 效果1：等价于对所有pod库执行一遍pod update PODNAME。 效果2：若有pod库的版本发生变更，则会更新Podfile.lock文件记录当前本地库的状态。 不推荐的原因是所有库只要有新版本，都会发生更新，有可能导致整个工程变得不稳定；另外，由于每个团队成员执行该命令的时间不一样，一旦中间有某个依赖库发布了新版本，这将导致团队内不同成员获得的pod库代码并不相同。 卸载 完全卸载 CocoaPods，删除其主库后重新安装【已测试，很强大，会重新下载主库，一定要使用代理】 rm -rf ~/.cocoapods sudo gem install cocoapods git config --global http.https://github.com.proxy [socks5://127.0.0.1:1080](socks5://127.0.0.1:1080)在终端为 github 设置代理 卸载Cocoapods 【感觉没起什么作用】 sudo gem uninstall cocoapods 更新cocoapods的主库 pod repo update 对主库进行操作，没有尝试成功！ pod repo remove master 如果没有master, 创建 repos 的 master, 并拉取 cd ~/.cocoapods/repos/master git pull git clone --depth=1 https://github.com/CocoaPods/Specs.git "},"知识库/iOS 知识点/iOS库/CocoaPods/pod install, pod update, podfile, podfile.lock.html":{"url":"知识库/iOS 知识点/iOS库/CocoaPods/pod install, pod update, podfile, podfile.lock.html","title":"pod install, pod update, podfile, podfile.lock","keywords":"","body":" pod install, pod update, podfile, podfile.lock, 版本号控制 一、pod install VS pod update 1 pod install 的使用场景： 2 pod update 的使用场景： 3 正确的使用方法 二、对于版本号的控制 pod install, pod update, podfile, podfile.lock, 版本号控制 一、pod install VS pod update 1 pod install 的使用场景： 1.1 新创建工程，第一次引入pod库时。 效果1：此时会按照Podfile中给出的约束条件下载所需要的pod库，获得符合约束条件的最新版本。 效果2：将创建Podfile.lock文件，记录当前使用的所有pod库和版本。 效果3：同时也会创建Pods.xcodeproj和.xcworkspace，不过这不是主要功能。 1.2 修改了Podfile文件，添加或删除了所依赖的pod库时。 效果1：建议此时一定要使用pod install获取新的pod库或删除不要的pod库，若使用pod update其他库也会受到影响。 效果2：Podfile.lock会做相应的修改，记录当前使用的所有pod库和版本。 效果3：对于Podfile.lock中已有记录的其他pod库不会发生任何变化，不去检查是否有更新版本，即使有新的可用版本也不会更新。 1.3 新人加入团队，拉取了主工程之后要获取pod库时。 效果1：按照Podfile文件中的依赖关系获取pod库。 效果2：在满足Podfile文件的情况下，直接获取Podfile.lock中记录的pod库的对应版本，并不去检查是否有更新版本。因此，即使有新的可用版本也会仅获取Podfile.lock中的版本。 1.4 团队合作中，不同开发者之间要同步对pod库的依赖时。 效果1：有人改变依赖关系，修改了Podfile文件时，情况与见场景2相同。 效果2：Podfile文件未变化，但是有人执行了pod update导致Podfile.lock文件发生修改时，pod install会同步获取Podfile.lock中指定的pod库版本，而不是最新的版本。 效果3：如果Podfile与Podfile.lock的记述相冲突，如指定了低于Podfile.lock中记录的版本，会以Podfile为准，并在获取完成后更新Podfile.lock文件。 2 pod update 的使用场景： 2.1 需要将某个pod库更新到最新版本时，使用pod update PODNAME 效果1：检查指定pod库的最新版本，若最新版本满足Podfile中的约束，则更新到最新版本。 效果2：若最新版本不满足Podfile中的约束，则更新到满足约束的最高版本。 效果3：pod update命令不会检查Podfile.lock文件，即使其中有记录也是无效的。 效果4：若Podfile文件已发生变更，pod update命令也会将本地pod库更新为符合Podfile文件的版本（不建议这么做，因为非指定PODNAME的pod库也可能被改动，此处仅写明有此效果而已）。 效果5：若有pod库的版本发生变更，指定pod库版本变化、其他pod库由于Podfile的改动而发生变化、甚至因为Podfile的改动而被移除，都会更新Podfile.lock文件记录当前本地库的状态。 效果6：由于要检查pod库的新版本，会先拉取所有源的podspec文件，第一次做这件事将是个超级费时的操作。 2.2 超级懒人爱做，而官网极其不推荐的做法，直接使用pod update 效果1：等价于对所有pod库执行一遍pod update PODNAME。 效果2：若有pod库的版本发生变更，则会更新Podfile.lock文件记录当前本地库的状态。 不推荐的原因是所有库只要有新版本，都会发生更新，有可能导致整个工程变得不稳定；另外，由于每个团队成员执行该命令的时间不一样，一旦中间有某个依赖库发布了新版本，这将导致团队内不同成员获得的pod库代码并不相同。 3 正确的使用方法 根据这两个命令的功能差异，以及CocoaPods官网的建议，我总结它们的正确用法是： 第一次获取pod库时，应使用pod install。 需要更新依赖库时，先使用pod outdated查看有哪些库有更新，再使用pod update PODNAME有目的的更新指定库。 提交代码时，请注意一定同时提交Podfile.lock文件，以便其他人能同步到与你相同的pod库版本。 同步其他团队成员的修改时，请使用pod install。 注意，pod outdated和pod update都会更新spec仓库，但是pod install不会，所以对于经常使用的pod库，建议经常pod outdated关注更新情况。 官网提到的：为什么直接在Podfile文件中指定版本的方法不够用？ 原因是你所依赖的库可能还依赖于其他的库。 如果指定pod A的版本（如在Podfile中指定pod 'A', '1.0.0'），但是pod A依赖于pod A2（通过在A.podspec中的dependency 'A2', '~> 3.0'声明）。在这种情况下，Podfile的确会强制所有用户使用pod A的1.0.0版本，但是，用户1可能会使用A2的3.4版本，而在这之后A2有新版发布，若无Podfile.lock的帮助，用户2无论使用pod install还是pod update都不可避免的会使用A2的3.5版本。 一般情况下pod A对pod A2依赖关系你是不可见的，或者并不由你维护的。所以，直接在Podfile文件中指定版本的方法并不能保证所有用户都使用相同版本的pod库。 除非你的工程所依赖的所有pod库在对其他库进行依赖时也都采用指定版本的方法，而这只有在所有pod库都由你来维护时才能够得到保证。 二、对于版本号的控制 pod ‘AFNetworking’ //不指定依赖库版本，表示每次都获取最新版本 pod ‘AFNetworking’, ‘2.0’ //只使用2.0版本 pod ‘AFNetworking’, ‘> 2.0’ //使用高于2.0的版本 pod ‘AFNetworking’, ‘>= 2.0’ //使用大于或等于2.0的版本 pod ‘AFNetworking’, ‘ 0.1.2’ //使用大于等于0.1.2但小于0.2的版本 pod ‘AFNetworking’, ‘~>0.1’ //使用大于等于0.1但小于1.0的版本 pod ‘AFNetworking’, ‘~>0’ //高于0的版本，写这个限制与什么都不写是同样效果，皆表示使用最新版本 作者：彭磊PL 链接：https://www.jianshu.com/p/118bbfba5c23 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 "},"知识库/Others/图片视频处理/图片基础知识.html":{"url":"知识库/Others/图片视频处理/图片基础知识.html","title":"图片基础知识","keywords":"","body":" 图片基础知识 分辨率 4K： 1080p： 720p： Aperture光圈： ISO感光度： Shutter快门速度/曝光： 焦距 拍摄模式： 图片基础知识 分辨率 4K： 3840*2160（16:9） 4096*2160 4096*2048 4096*2304 4096*3112 1080p： 1920*1080 720p： 1280*720 30/60/120/240fps HDR White Balance 白平衡： 色温：调节冷暖 色调： 对比度： 高光： 阴影： 白色： 黑色： 清晰度： 自然饱和度： 饱和度： Aperture光圈： 用来控制光线透过镜头进入机身内感光面光量的装置，通常用f值表达光圈大小。快门不变，f后面的数值越小，光圈越大，进光量越多，画面比较亮，景深越浅，主题背景虚化越大。 光圈f值=镜头焦距/镜头通光直径 ISO感光度： 数值越小，画面质量越好，数值越高，感光速度越快，画面质量下降，容易产生躁点。在光照暗的夜晚或者黑的场合提高ISO，但是一般宁可光圈开大一级，ISO尽量用低值，这样最大限度保证照片画质。 不要太高（小于800）与噪点紧密 低ISO 50/100/200 吸光能力低，讯噪非常少，物件边缘清晰，适合在日间风景/夜景脚架长曝拍摄。 中ISO 400/800/1000 吸光能力正常，讯噪小，物件边缘清晰，适合在阴天/明亮的室内拍摄。 高ISO 1600/3200/6400吸光能力高，暗部有可见的讯噪，适合在光线不足/室内/手持夜景拍摄。 超高ISO 56000/128000/512000 吸光能力非常高，讯噪严重，适合在光线严重不足/星空照构图拍摄。 Shutter快门速度/曝光： 就是快门从开启到关闭的瞬间，也就是光线进入相机的曝光时间。一般在光线较差的地方如室内和晚上时就需要慢速度，在光线强烈的环境拍摄是需要较快的快门速度。 快门 速度不超过1秒 焦距 镜头的焦距越长，视角就越窄，反之亦然。例如300mm的超远摄镜头，只有8°的视角，而8mm的超广角镜头，则拥有180°的视角 拍摄模式： P模式：相机自动测光后，按入光量运算出快门和光圈数值。 A/AV模式：光圈优先，用户可自行选择光圈大小，相机会自动运算快门速度。 S/TV模式：快门优先，用户可自行选择快门速度，相机会自动运算光圈大小。 M**模式：**全手动模式，用户可自行选择光圈大小和快门速度。 "},"知识库/Others/图片视频处理/Photoshop.html":{"url":"知识库/Others/图片视频处理/Photoshop.html","title":"Photoshop","keywords":"","body":" Photoshop 视频教程 Get started Quick Tart Photo editing for beginners Photoshop 调色基础： 直方图 色阶 曲线 放大缩小快捷键：找到放大镜后长按option转换。Command+ Change brush tip size: 大括号和小括号 快速查看不同的效果：Shift + Inside layer mask: black conceal, white reveal 视频教程 Get started Get to know Photoshop Open images Get familiar with the work area Learn how to zoom and pan Undo a command Save your work Change the image size Resize an image Set the resolution Corp and straighten an image Expand the canvas Work with layers Understand layers Learn layer basics Resize a layer Add images to a layered design Unlock the background layer Adjust The image quality Adjust brightness and contrast Adjust color vibrance Adjust hue and saturation Learn about adjustment layers Make selections Learn selection basics Learn how to use the Quick Selection and Lasso tools Fine-tune a selection Retouch images Remove small objects Add objects by cloning Remove a large object Use color Work with brushes Use foreground and background colors Choose a color Add text and shapes Add Text Edit Text Create a graphic shape Add a built-in custom shape Combine images Add texture to an image Add an object to an image with a layer mask Replace a background using layer mask Apply filters Browse the Filter Gallery Blur an image with Smart Filter Quick Tart Creat your first design Get to know layers Combine images using layer masks Add text and effects Include vector graphics Export and save design Dream it. Make it. Edit your first photo Crop and straighten Improve lighting and color Remove unwanted content Add creative effects Sharpen and save Jump-start your design with Photoshop Templates Photo editing for beginners Save a photo in the best format for your needs Adjust the intensity of colors in a photo Crop an d straighten a photo to improve composition Correct an unwanted color cast Sharpen a photo to bring out detail "},"知识库/Others/图片视频处理/相机按钮的含义.html":{"url":"知识库/Others/图片视频处理/相机按钮的含义.html","title":"相机按钮的含义","keywords":"","body":"相机按钮的含义 "},"知识库/Others/图片视频处理/Final Cut Pro X.html":{"url":"知识库/Others/图片视频处理/Final Cut Pro X.html","title":"Final Cut Pro X","keywords":"","body":" Final Cut Pro X/ FCPX 将素材导入事件 Import Media to your Event 编辑Editing： 导出片段 声音编辑Audio Edit: 过渡Transitions: 效果 Effects:(Command+5) 颜色校正 Color Correction:(Preview左下角魔术棒） 录音 字幕Titles: 修改分辨率 Final Cut Pro X/ FCPX Library 库 -> Event 事件 -> Project 项目 Browser 浏览器、Preview 预览、Different Inspector 属性检查器、Timeline 时间轴、Storyline 故事线、Playhead 播放头、Transitions 过渡、Effects 效果 将素材导入事件 Import Media to your Event Import: Command I Set In and Out Bring footage to the project: 将视频片段导入项目 E: 将选中片段放到故事线的结尾 (send to end)take out from event to the storyline end. Q: 将选中片段取出放到故事线上，播放头后面，原来视频片段的上面的位置 take out from to the storyline whereafter the playhead and above the clip that was there. W: 将选中片段取出插入到故事线中播放头的位置 take out from to the storyline and cut in where the playhead is. D: 将选中片段放到播放头的位置并且覆盖原来那里的视频 bring to the storyline and overwrite from the playhead Trimming =Click and drag B: Blade 长按B出现刀片，点击裁剪，完后松开B 刀片无法转成箭头，点A，即Arrow就行。 Command+B剪但不进入blade mode，还在A mode A: switch back to arrow Z: 放大 zoom V: 静音 disable/enable or Mute N: snapping 磁吸到特定的storyline P: (position mode)overwrite the original clip M: 设置标记 Set Mark Control + shift + z: detach audio 视频和音频分离 编辑Editing： 变速Command+R(Retiming): Speed up down: 选后可拖拽调整速度 反转Reverse（storyline 右键） Fn+delete=删除一段后用空白代替，后面视频不会往前。 A Mode (arrow): Shots will adjust if moved(移动一段视频后，后面剩余视频整体向前平移) P Mode (position): Shots are pinned down P加Drag(移动一段视频后，被移动位置用空白代替，剩下视频固定在原来位置) 撤销 Undo: Command + z 取消撤销 Redo: Command + shift + z 导出片段 按住R，拖拉选择要导出的片段区间。Command + E 导出片段。 声音编辑Audio Edit: Increase or decrease audio volume: drag 0db up or down. Don’t want Red and Yellow Fade in and out(视频音频都有小点？) Manually Adjusting Audio Levels via Keyframes: Keyframe-move to where you wanna end-keyframe again-transition the volume 声音降噪 1、我们点击选中视频中音频轨道。 2、鼠标移动到音频分析栏目，点击箭头所指的显示。 3、勾选降噪。 4、根据自己的音频具体情况，点击箭头所指的数量按钮进行拖动。 5、试听一下刚刚所调整的音频质量，是否已经达到了降噪的要求 6、我们也可以勾选嗡嗡声消除 7、这实在是听一下声音，看看是否已经达到自己所需要的要求。 过渡Transitions: Cross Dissolve Fade to color Flash 效果 Effects:(Command+5) Video: Audio: Keying: Keyer Effects Vignette Save Effects Preset 保存效果设置，下次使用 颜色校正 Color Correction:(Preview左下角魔术棒） Balance color Match color: 颜色格式刷 Color Inspector: 颜色检查器 Command +6 Color: Saturation: Exposure: 三个点分别代表图片中不同颜色域的像素点，分别调整代表分别使不同色域的像素点变化。 把一个clip的颜色预设复制到其他的（如果是同一个地点、同时、同天气拍摄）： Clone Color Settings 复制颜色配置 Command+C Command option V(所有颜色设置all settings) Command shift V(可以选择部分颜色设置option setting) 变形(放大、裁剪)Transform(预览左下角3个按钮中） Crop: Ken burn Distortion Applying Stabilization: In the Video Inspector 录音 Record Voice：菜单栏Window 字幕Titles: 步骤: 搜索基本Basic，将字幕拖动到时间轴，拉伸到跟视频一样长，然后根据视频中说话长度进行截取，并把字幕添加进去 Face 字体颜色 Outline 外边框 Overlay: drag and put on top of clip 黑色背景Black background: drag between scenes Text float over other background: drag generators to storyline, then drag title over it. 字体Font: 位置Position: in title Inspector 阴影Drop Shadow: if background is the same color 复制字幕设置Hold Option and drag 修改分辨率 MotionVFX.com FCPEFFECTS.com inks to Websites and Products mentioned in this class: David’s Production Gear: https://www.techtalkamerica.com/produ... Need an External Hard drive? bit.ly/ExternalHardDrives2018 MotionVFX - An amazing website that constantly introduces new content for Final Cut Pro X, After Effects, Premier, and Apple Motion. http://motionvfx.com VideoHive- Tons of stock footage, templates, and more. Link: http://bit.ly/VideoHive2018 FCPEffects - A great website for even more effects for Final Cut Pro X: Link here: bit.ly/FCPEffectsLink AGSoundtrax.com - A terrific source for purchasing music for your next video production. Use coupon code DAVIDC25 for 25% off! AudioJungle - Part of the Envato network. They have tons of music and sound effects which you can license for your project. Link: http://bit.ly/AudioJungle2018 "},"知识库/Others/图片视频处理/ffmpeg.html":{"url":"知识库/Others/图片视频处理/ffmpeg.html","title":"ffmpeg","keywords":"","body":"ffmpeg 压缩视频并转换格式 ffmpeg -i 路径/PM.mov -b:v 2048k -s 1920x1080 路径/video.mp4 转换格式【超快速度】 ffmpeg -i 路径/video.m4v -c:v libx264 -preset ultrafast test.mp4 "},"知识库/Others/图片视频处理/gifsicle.html":{"url":"知识库/Others/图片视频处理/gifsicle.html","title":"gif","keywords":"","body":" Gif Gif Brewery 3 gifsicle Gif Gif Brewery 3 在官方教程中，开发者建议用户将 frame delay 设置为 42 ms，什么意思呢？根据公式计算，FPS(frames per second) = (1000) / (frame delay），也就是当你选择 42ms 时，FPS 为 24，如果设置为更高的 100ms，FPS 为 10。 假设你要制作一个长度为 10 秒的动图，frame delay 为 42ms，那么需要的帧数（frame count）就是：10s x 24fps = 240 帧，这样能带来更细腻的画面效果。反过来，如果你关心文件大小，建议更高的 frame delay，也就是 100ms，相当于每秒显示10帧，可以制作更小的 GIF，如果你想要更流畅的播放效果，选择 40ms-50ms 的 frame delay 即可。 总之，颜色数量、图像尺寸和帧数的适当调整才能保证文件的可传播性，根据需求设置即可。 option + cmd + L 循环预览 gifsicle 想要达到这样的压缩优化效果，我推荐使用一款命令行工具 gifsicle，建议通过 homebrew 来安装它。 如果你的电脑里还没有 homebrew，就打开 Terminal，输入这串命令安装 homebrew： /usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 一长串字符闪过之后，接着输入命令安装 gifsicle： brew install gifsicle 使用 gifsicle 压缩 GIF 时，用这个命令： gifsicle -O3 [想要压缩的图片] -o [新图片名] 其实 gifsicle 也有着较为丰富可调节参数，但是最实用的还是用 -O3 让它自动为你选择压缩方案，一般能在画质和体积之间取得平衡，并且第一帧之后的每一帧都能得到优化。 gifsicle --colors 256 -o3 b.gif -o a1.gif -O1 Stores only the changed portion of each image. This is the default. -O2 Also uses transparency to shrink the file further. -O3 Try several optimization methods (usually slower, sometimes better results). Gifsicle是用于创建，编辑和获取有关GIF图像和动画的信息的命令行工具。使用gifsicle制作GIF动画很容易 "},"知识库/Others/历史政治地理/历史.html":{"url":"知识库/Others/历史政治地理/历史.html","title":"历史","keywords":"","body":" 历史 约-2070年 夏朝建立 约-1600年 商汤灭夏，商朝建立 -1046年 周武王灭商，西周开始 -770年 周平王迁都洛邑，东周开始，春秋开始 -403年 战国开始 -221年 秦灭六国，统一中国 -202年 西汉建立 9年 王莽夺取西汉政权 25年 东汉建立 220年 魏国建立，东汉灭亡，进入三国时期 280年 西晋灭吴，统一全国 317年 东晋建立 420年 东晋灭亡，进入宋齐梁陈 439年 北魏统一北方 589年 隋朝统一 618年 隋朝灭亡，唐朝建立 907年 唐朝灭亡，五代十国时期开始 960年 赵匡胤陈桥兵变，建立宋朝（北宋） 1127年 金国灭北宋，南宋建立 1271年 忽必烈改蒙古国号为“大元” 1279年 南宋灭亡 1368年 明朝灭元朝 1644年 清灭明 1912年 中华民国成立、清朝灭亡、中华民国临时约法颁布。 (1940年 奶奶出生) 1949年10月1日 中华人民共和国成立（新民主主义革命胜利） 1966年 “文化大革命”开始。 (1968年 爸爸出生) (1969年 妈妈出生) 1976年 四五运动、毛泽东逝世、江青反革命集团被粉碎，“文化大革命”结束。 1991年 十月，王朝阳先生出生。 历史 距今约170万年 元谋人 距今约70万-20万年 北京人 距今约3万年 山顶洞人 距今约7000年 河姆渡文化 距今约6000年 半坡文化 距今约5000年 传说中的炎帝、黄帝、尧、舜、禹时期 -3500年 两河流域南部出现奴隶制小国。 -3000年左右 统一的古代埃及国家建立。 -2500年 印度河流域出现奴隶制城邦 约-2070年 夏朝建立 -2000年-前12世纪 爱琴文明 -18世纪 古巴比伦王国统一两河流域。 约-1600年 商汤灭夏，商朝建立 -1046年 周武王灭商，西周开始 -841年 国人暴动 -771年 西周结束 -770年 周平王迁都洛邑，东周开始，春秋开始 -8世纪 斯巴达、雅典城邦建立 -6世纪起 印度半岛逐渐统一 -6世纪 佛教产生 -509年 罗马共和国建立 -4世纪晚期 亚历山大帝国昙花一现 -483年 西施送入吴国；范蠡(li)遇到阿青，阿青传越国剑士剑法。 -476年 越国灭掉吴国；范蠡与西施隐居，阿青离去。 -403年 战国开始 -356年 商鞅开始变法 -340年 屈原出生 -278年 楚国郢都被秦军攻破后，屈原自沉于汨罗江，以身殉国。 -221年 秦灭六国，统一中国 -209年 陈胜、吴广起义爆发 -207年 秦朝灭亡 -202年 西汉建立 -138年 张骞第一次出使西域 -73年 罗马共和国爆发斯巴达克起义。 -27年 罗马帝国建立。 -1世纪 基督教产生。 9年 王莽夺取西汉政权 25年 东汉建立 73年 班超出使西域 184年 黄巾起义爆发 192年 曹植出生 200年 官渡之战 208年 赤壁之战 220年 魏国建立，东汉灭亡，进入三国时期 221年 蜀国建立 229年 吴国建立 266年 西晋建立 280年 西晋灭吴，统一全国 316年 西晋灭亡 五胡十六国、北魏、西魏、东魏、北周、北齐 317年 东晋建立 365年 陶渊明出生 383年 淝水之战 395年 罗马帝国分裂 420年 东晋灭亡，进入宋齐梁陈 439年 北魏统一北方 476年 西罗马帝国灭亡 494年 北魏孝文帝迁都洛阳 5世纪末 法兰克王国建立 527年 南北朝时期，印度高僧菩提达摩来到中国，在嵩山少林寺面壁九年，创立中国禅宗。 536年 达摩祖师逝世。 554年 西魏宇文泰公婆江陵城（今荆州），梁元帝萧绎留下宝藏在天宁寺，连城诀宝藏来源于此。 581年 隋朝建立 589年 隋朝统一 7世纪初 伊斯兰教兴起 隋朝末年，李靖将《易筋经》中的武学奥秘尽数领悟。 618年 隋朝灭亡，唐朝建立 622年 穆罕默德从麦加出走麦地那。 627年 - 645年 玄奘西行 640年 侯君集攻破高昌国。 641年 文成公主嫁到吐蕃。 646年 日本大化改新开始。 676年 新罗统一朝鲜半岛大部分地区。 694年 明教传至中土。 701年 王维出生 701年 李白出生 754年 鉴真东渡到达日本。 8世纪中期 阿拉伯国家称为大帝国。 755-763 安史之乱 768 韩愈出生 773年 柳宗元出生 唐朝末年，嘉兴剑术名家改良越女剑法。 877年 丐帮建立。 907年 唐朝灭亡，五代十国时期开始 907年 耶律阿保机建立契丹。 937年 段思平建立大理。 936年 - 946年 少林寺法慧禅师练成了一指禅。 960年 赵匡胤陈桥兵变，建立宋朝（北宋） 1007年 欧阳修出生 1009年 苏洵出生 1019年 曾巩出生 1021年 王安石出生 1030年 慕容博出生。 1037年 苏轼出生 1038年 西夏建立。 1039年 苏辙出生 1047年 慕容博伤黄眉僧。 1051年 扫地僧到少林寺。 11世纪中期 毕昇发明活字印刷术。 1060年 萧峰出生。 1061年 雁门关外乱石谷大战。 1062年 萧远山到少林偷研武功。 1063年 丁春秋暗算师门。 1064年 慕容复出生 1065年 波斯“山中老人”霍山，制圣火令，将平生武功精要，镌刻于圣火令之上。 1071年 段誉出生。 1072年 慕容博伤崔百泉。 1074年 阿朱出生 1077年 慕容博诈死。 1083年 萧峰接任丐帮帮主。 1090年 鸠摩智单挑天龙寺六僧。 1091年 萧峰离开丐帮。 1092年 聚贤庄大战。 1093年 萧峰助耶律洪基平定皇太叔之乱（历史上为1063年）；无崖子去世；虚竹接任逍遥派掌门，同年被西夏召为驸马；少林寺门外混战；扫地僧讲经说法。 1094年 大理段正明禅位侄子段誉；萧峰自尽。 1103年 岳飞出生。 1112年 王重阳出生。 1115年 完颜阿骨打建立金国，黄裳雕版印行万寿道藏。 1120年 黄裳向明教的高手挑战。 1125年 金国灭辽。 1127年 金国灭北宋，南宋建立 1127年 - 1130年 少林寺灵兴禅师花了三十九年练成了一指禅。 1140年 独孤求败创独孤九剑第九式破气式。 1141年 岳飞狱中撰写《武穆遗书》。 1158年 段智兴出生。 1162年 柯镇恶（江南七怪之首）出生。 1163年 周伯通出生。 1164年 黄裳完成九阴真经。洪七公出生。 1168年 欧阳锋出生。 1170年 独孤求败郁寂而终。 1171年 黄药师出生。 1173年 曲灵风出生。 1178年 裘千仞出生。 1183年 金轮法王出生。 1184年 朱子柳出生。 1186年 陈玄风欧阳克出生。 1190年 火工头陀于少林寺中大开杀戒。 1196年 王重阳再入古墓，于棺上刻下部分九阴真经，并留“玉女心经，欲胜全真；重阳一生，不弱于人”的文字，后某日无名僧与王重阳斗酒参阅九阴创九阳；南宋宦官在宫中创葵花宝典。 12世纪末 日本进入幕府统治时期。 1200年 第一次华山论剑。 1203年 重阳真人拜访段皇爷，废了欧阳峰20年蛤蟆功；王重阳仙逝。 1205年 郭靖出生。 1206年 成吉思汗统一草原，建立蒙古汗国。 1206年 裘千仞伤瑛姑幼子。 1208年 黄蓉出生。 1222年 小龙女出生。 1225年 穆念慈比武招亲。 1226年 杨过出生。 1227年 蒙古灭西夏；成吉思汗去世；第二次华山论剑。 1234年 金国灭于蒙古与南宋联合进攻。 1235年 明教高手参考五代十国时期武林高手慕容龙城的“斗转星移”， 创出威力更大的“乾坤大挪移”神功，遂为镇教之宝。 1243年 洪七公、欧阳锋去世。 1243年 杨过小龙女双剑合璧初试锋芒挫败金轮法王；杨过学弹指神通。 1243年 郭襄出生；杨过断臂，初入独孤求败剑冢。 1247年 张三丰出生。 1253年 蒙古灭大理国。 1257年 明教石教主圣火令为丐帮所夺。 1259年 杨过飞石击毙蒙哥大汗；第三次华山论剑。 1262年 郭襄游少林。 1271年 忽必烈改蒙古国号为“大元” 1273年 一代大侠郭靖和黄蓉战死襄阳。 1276年 元攻进南宋都城临安。 1279年 南宋灭亡 1296年 金毛狮王谢逊出生。 14-16世纪 欧洲文艺复兴运动。 1317年 谢逊离开师父成昆，加入明教。 1318年 武当刘弟子殷梨亭出生。 1323年 成昆杀谢逊一家。 1336年 谢逊及张翠山夫妇至冰火岛。 1337年 张无忌出生。 1338年 元兵剿灭袁州明教义军，常遇春、彭莹玉侥幸逃脱。 1339年 周芷若出生。 1340年 汝阳王女儿敏敏特穆尔出生，元帝封其“绍敏郡主”。 1341年 小昭出生。 1346年 张三丰百岁大寿；张翠山殷素素夫妇自尽。 1351年 张无忌得九阳神功。 1357年 六大门派围攻光明顶；张无忌任明教教主；张三丰首创太极神功。 1358年 小昭远走波斯。 1359年 少林屠狮英雄会；白眉鹰王殷天正去世。 1360年 张无忌隐退，光明左使杨逍继任为明教第三十五代教主。 1365年 明教光明右使范遥参考北宋年间的两大神功“北冥神功”及“化功大法”，创出威力极大更为歹毒的“吸星大法”。 1368年 明朝灭元朝 1372年 杨逍去世，明教内部争权夺利，陷入内乱，加上外部朱元璋打压，明教日渐式微。教中高手改组明教，遂为“日月神教”。 1400年 莆田少林寺得葵花宝典。 1401年 岳肃蔡子峰偷录葵花宝典；渡元禅师习辟邪剑法。 1402年 华山派分气宗剑宗。 1405-1433 郑和七次下西洋。 1406年 日月神教十长老破五岳剑派剑法。 1406-1420年 营建北京城。 1420年 日月教袭武当山，张三丰手抄一部《太极拳经》和青年时佩带的真武剑被抢。 1453年 拜占庭帝国灭亡。 1458年 武当派开山祖师张三丰仙逝，享年212岁。（据《古今太极拳谱及源流阐秘》李师融先生考证） 1469年 令狐冲出生。 1479年 华山派气宗剑宗之争。 1486年 任盈盈出生。 1487年-1488年 迪亚士远航非洲南部沿海。 1492年 哥伦布到达美洲。 1493年 东方不败篡日月神教教主之位；任我行被囚地牢。 1503年 余沧海灭福威镖局。 1504年 令狐冲学得独孤九剑。 1505年 任我行重夺日月神教教主。 1506年 任我行去世。 1509年 令狐冲任盈盈喜结良缘。 16世纪中期 戚继光抗倭。 1610年 金蛇郎君夏雪宜惨遭灭门之祸。 1612年 金蛇郎君夏雪宜得到云南五仙教的镇教“三宝”。 1623年 袁承志出生。 1640年 英国资产阶级革命开始。 1643年 袁承志被推举为七省江湖首领，同年率众人摧毁西洋红衣大炮。 1644年 清灭明 1644年 袁承志助阿九挫败成王和曹化淳篡位阴谋；李自成攻入北京，明亡；吴三桂降清；李岩夫妇自杀身亡。同年，袁承志、夏青青率亲友、部属避居海外，即今南洋新加坡之地。 1645年仲夏， 在清兵追击下，李自成率主力部队败退至湖北通城县。一日，李自成带少数亲兵，在县南查勘地形，在九宫山玄帝庙中，因打盹疏忽，被姜姓农民误杀，终年三十九岁。 1655年 韦小宝出生在扬州妓院。 1669年 康熙韦小宝擒鳌拜。 1670年 韦小宝出任天地会青木堂香主。 1688年 英国政变，资产阶级和新贵族的统治确立。 1698年 武当派掌门陆菲青出生。 1711年 雍正帝与海宁陈家掉包刚出生的儿女，爱新觉罗弘历原来是海宁陈家之子。 1733年 陈家洛出生。 1735年 爱新觉罗弘历登基，年号乾隆。 1753年腊月，苗人凤和胡一刀决战；胡斐出生。 1758年 红花会在六和塔囚禁乾隆，回部霍青桐力排众议，大败清军主力。 1759年 香香公主在北京自杀。 18世纪60年代 英国工业革命开始。 1775年-1783年 北美独立战争。 1776年7月4日 北美大陆会议发表《独立宣言》，宣布独立。 1780年 三月十五日，苗人凤与胡斐决战。 1785年 瓦特制成改良蒸汽机，开始用作纺织机的动力。 1789年7月14日 巴黎人民攻占巴士底狱，法国资产阶级革命开始。 1799年11月 拿破仑发动政变、夺取政权。 1804年 法兰西第一帝国建立 18世纪末19世纪初 拉丁美洲独立运动兴起。 1839年 林则徐虎门销烟。 1848年2月 《共产党宣言》发表。 1840-1842 鸦片战争。 1851-1864 太平天国运动。 1856-1860 第二次鸦片战争 1858年 中俄《天津条约》、中美《天津条约》、中英《天津条约》、中法《天津条约》。 1859年 《物种起源》出版。 1860年 中英《北京条约》、中法《北京条约》、中俄《北京条约》签订。 1860-1870年 中国民族资本主义产生 1860-1890年 洋务运动 1861年 俄国农奴制改革。 1861年-1865年 美国内战。 1866年 孙中山出生。 1868年 日本明治维新开始。 19世纪70年代 电力进入生产领域。 19世纪80年代 内燃机研制成功。 1881年 鲁迅（周树人）出生。 1885年 本茨试制汽车成功。 1893年 毛主席出生。 1894-1895年 甲午中日战争。 1895年 中日《马关条约》签订 1898年 戊戌变法 1899年 老舍出生。 1900年 义和团运动高潮、八国联军侵华 1901年 《辛丑条约》签订 1903年 飞机试飞成功 1905年 中国同盟会成立、清政府停止科举考试 1911年 黄花岗起义、武昌起义 1912年 中华民国成立、清朝灭亡、中华民国临时约法颁布。 1913年 二次革命 1914年7月 第一次世界大战爆发。 1915年 护国运动开始、新文化运动开始。 1916年 袁世凯恢复帝制失败。 1917年11月7日 俄国十月社会主义革命。 1918年11月11日 第一次世界大战结束。 1919年1月到6月 巴黎和会 1919年 五四运动。 1921年 中国共产党成立。 1921.11 - 1922.2 华盛顿会议 1922年 中国共产党第二次全国代表大会召开。 1922年10月 墨索里尼在意大利上台。 1922年12月 苏联成立 1923年 京汉铁路工人大罢工。 1924年 二月六日，金庸先生出生。 1926年 国民革命军出师北伐。 1927年 蒋介石发动反革命政变、南京国民政府建立、汪精卫发动反革命政变、国民革命失败、南昌会议、八七会议、秋收起义。 1928年 井冈山会师、张学良宣布东北易帜，国民政府在名义上同意全国。 1929年-1933年 资本主义世界经济危机。 1931年 日本帝国主义侵华九一八事变、中华苏维埃共和国临时中央政府成立。 1932年 伪满洲国成立。 1933年1月 希特勒在德国上台，开始建立法西斯专政。 1933年3月 罗斯福就任美国总统，实行新政。 1934-1936年 红军长征。 1935年 遵义会议、一二九运动。 1936年 西安事变、鲁迅（周树人）逝世。 1937年 七七事变、淞沪会战、第二次国共合作实现、中国全面抗日战争开始、平型关大捷、南京大屠杀。 1938年 台儿庄战役、武汉会战。 1938年9月 慕尼黑会议。 1939年9月1日 第二次世界大战全面爆发。 1940年 汪精卫伪国民政府在南京成立、百团大战、李小龙出生。 (1940年 奶奶出生) 1941年 皖南事变。 1941年6月22日 苏德战争爆发。 1941年底-1942年初 第三次长沙会战。 1942年6月 中途岛战役。 1942年7月-1943年2月 斯大林格勒战役。 1944年6月6日 美英军队在诺曼底登陆，欧洲第二战场开辟。 1945年5月8日 德国签署无条件投降书。 1945年9月2日 日本签署无条件投降书。 20世纪40-50年代 第三次科技革命开始。 1945年10月 联合国建立。 1945年 中共第七次全国代表大会召开、日本宣布投降、重庆谈判、“双十协定”签订。 1946年 国民党发动全面内战、人民解放战争开始。 1947年 人民解放军转入战略进攻、中国共产党颁布《中国土地法大纲》。 1947年3月 美国提出“杜鲁门主义” 1947年8月 印巴分治，印度、巴基斯坦独立。 1948年 以色列建立，第一次中东战争。 1948年 美国开始实施“马歇尔计划” 1948年9月-1949年1月 辽沈战役、淮海战役、平津战役。 1949年 北大西洋公约组织成立。 1949年4月 渡江战役、国民政府覆亡。 1949年 中国人民政治协商会议第一届全体会议召开，《中国人民政治协商会议共同纲领》通过。 1949年10月1日 中华人民共和国成立（新民主主义革命胜利） 20世纪50年代初-70年代初 资本主义经济发展史上的“黄金时期”。 1950年 《中华人民共和国土地改革法》颁布、中国人民志愿军赴朝作战。 1953年 第一个五年计划开始实行、抗美援朝战争结束、和平共处五项原则提出。 1953年 开始进行社会主义工业化建设，三大改造(农业、手工业与资本主义工商业生产资料私有制向社会主义公有制改造)开始，逐步由新民主主义向社会主义过渡。 1954年 第一届全国人民代表大会召开，《中华人民共和国宪法》颁布。 1955年 周恩来率团参加万隆会议。 1955年 华沙条约组织成立。 1956年 三大改造基本完成、社会主义制度建立、计划经济制度确立、中国共产党第八次全国代表大会召开。 1956年 匈牙利事件。 1958年 “大跃进”运动、人民公社化运动。 1959年 古巴革命取得胜利。 1960年 非洲有17个国家独立，这一年被称为“非洲独立年”。 20世纪60年代初 不结盟运动形成。 20世界60年代初-1973年 美国侵略越南的战争。 1964年 中国第一颗原子弹爆炸成功。 1966年 “文化大革命”开始。 1967年 中国第一颗氢弹爆炸成功。 1967年 欧洲共同体成立。 1968年 苏联出兵占领捷克斯洛伐克。 (1968年 爸爸出生) (1969年 妈妈出生) 1970年 中国第一颗人造地球卫星发射成功。 1971年 林彪反革命集团被粉碎、中华人民共和国在联合国的合法席位得到恢复。 1972年 中美《联合公报》发表、中日正式建立外交关系。 1973年 第四次中东战争。 1973年 袁隆平选育杂交水稻成功。 1976年 四五运动、毛泽东逝世、江青反革命集团被粉碎，“文化大革命”结束。 1978年 中共十一届三中全会召开。 1980年 深圳、珠海、汕头和厦门经济特区建立。 1980年初 邓小平提出“一国两制”构想。 1982年 中国共产党第十二次全国代表大会召开。 1985年 开辟沿海经济开放区。 1987年 中国共产党第十三次全国代表大会召开。 20世纪80年代末 东欧剧变。 1991年 十月，王朝阳先生出生。 1991年底 苏联解体。 1992年 邓小平发表南方谈话、中共十四大提出建立社会主义市场经济体制。 1993年 欧洲联盟建立。 1997年 香港回归祖国、中国共产党第十五次全国代表大会召开。 1999年 澳门回归祖国。 1999年 科索沃战争。 2001年 中国加入世界贸易组织。 2002年 中国共产党第十六次全国代表大会召开。 2003年 神舟五号载人飞船成功返回地面。 2007年 中国共产党第十七次全国代表大会召开。 2008年 中国成功举办第29届奥运会、神舟七号载人飞船成功完成出舱任务。 2012年 中国共产党第十八次全国代表大会召开。 "},"知识库/Others/历史政治地理/历史轴.html":{"url":"知识库/Others/历史政治地理/历史轴.html","title":"历史轴","keywords":"","body":"历史轴 "},"知识库/Others/时间管理/Omnifocus 使用流程.html":{"url":"知识库/Others/时间管理/Omnifocus 使用流程.html","title":"时间管理 - OmniFocus","keywords":"","body":" Omnifocus 使用流程 流程 需要设置的接收事项的 可以用来查看跟踪进度的 清空收件箱 特点 Omnifocus 使用流程 流程 将脑子里的事情一股脑全部放进收件箱 清空收件箱 生成一些待办清单 今日待办事项清单(还得排出先后顺序) 被动 - 今天之内必须完成的（due soon和今天做project中available） 被动 - 指定时间今天做的（指定时间project中Defer date在今天的，即就是availiable） 被动 - （有计划地做中今天要做的部分，defer今天） 今天 主动 - 从今天开始可以做的（defer date是今天） 主动检查添加 - 今天具备了条件能做的（前天晚上或第二早检查） 委托给某人的 等待某人消息的 等待事件发生了做的 有啥了再做的 主动检查添加 - 尽快做当中能做的（前天晚上或第二早检查） 主动检查添加 - 闲了做当中想做的（前天晚上或第二早检查） 需要设置的接收事项的 可以用来查看跟踪进度的 项目 透视: 可以系统化地知道我有多少事情在进行 Forecast 透视： 可以看到未来的计划 Completed 透视： 可以看到已经完成的 已完成清单（按照时间group，按照时间sort） 上月已完成清单 上周已完成清单 本周截止目前已完成清单 昨天已完成清单 今天已完成清单 未完成清单（所有推迟至今天以后的事件或所有截止日期在今天以后的事件+所有没有推迟日期和截止日期的事件） 本周待办清单 本月目标清单 本季度目标清单 本年度目标清单 Waiting 透视: 可以跟踪在等待条件的 清空收件箱 从如下几个方面分析事项的特点 现在能做吗 需要定期重复吗 是一次性提醒吗 需要具备某个条件才可以做 一段时间内随时可能发生的（需要在这段时间内定期提醒检查） 需要等待一件自己掌控不了的事情完成以后，才能开始进行的（需要在这段时间内定期提醒检查） 时间 地点 人物 事件 生产工具 紧急程度 精力程度 现在就做/一步 给老李发邮件 -> 现在就做 已经不需要做了 买雨伞、但发现有一把 -> 删除 指定时间做 下周二晚7点谢某咨询 -> 放到日程表，在日历中创建事项，设置开始和结束时间，然后在收件箱中删掉 指定时间必须完成 具备条件做 【等待王先生修改网站标题】 -> 创建Waiting 上下文，并设置到期时间 【回家了给奶奶买膏药】-> 创建 地点 上下文 【买一瓶蜂蜜】-> 创建 网上购物 定期循环 尽快做 闲了做 梦想清单/将来也许【去日本旅游】-> 放进Someday/Maybe 上下文 有计划地做/多步【写一本时间管理的书】 -> 创建一个项目，分解第一步出来 资料【图片保存】-> 现在就做，保存到自己的资料库的相应位置 参考信息 灵光一闪 需要思考 特点 紧要程度 紧急重要 紧急不重要 重要不紧急 不重要不紧急 精力程度 无脑操作 低能量 沉静思考 时间分配 小于5min 5-10min 10-20min 20-30min 30-60min 60-120min 大于120min 地点 南孔头 让义村 外出 人物 "},"知识库/英语/英语时态.html":{"url":"知识库/英语/英语时态.html","title":"英语时态","keywords":"","body":"英语时态 "},"知识库/英语/英语音标.html":{"url":"知识库/英语/英语音标.html","title":"英语音标","keywords":"","body":" 英语音标 48个英语音标分类表 美式英语音标表 美式元音（18个） 英式元音（20个） 26个字母音标表 单元音和双元音 单元音短元音 单元音长元音 双元音 清浊成对辅音 其他辅音 英语音标 48个英语音标分类表 元音20个，辅音28个 美式英语音标表 美式元音（18个） 单元音：/i/ /ɪ/ /e/ /ɛ/ /æ/ /a/ /ʌ/ /ə/ /ɚ/ /ɝ/ /o/ /ɑ/ /ɔ/ /ʊ/ /u/ 双元音：/aɪ/ /aʊ/ /ɔɪ/ 注：有的地方将/a/写作/ɑ/，有时习惯上也将单元音/o/的位置读成双元音/oʊ/，将单元音/e/的位置读成双元音/eɪ/。 英式元音（20个） 单元音：/i:/ /ɪ/ /e/ /æ/ /ɜ/ /ə/ /ʌ/ /ɔ:/ /ɒ/ /u:/ /ʊ/ /ɑ:/ 双元音：/aɪ/ /eɪ/ /aʊ/ /əʊ/ /ɔɪ/ /ɪə/ /eə/ /ʊə/ 注：美式音标中摈弃了英式音标中的长元音符号 /:/，这是英式与美式音标书写上的最大区别！ 26个字母音标表 单元音和双元音 单元音短元音 /ɪ/ [/i/] - 额和诶之间 this hit fill ship sit bit 与/i/ \\ /I:/互为短长音且易混 /ə/ - ago, ability, banana, idea /ɑ/ [/ɒ/ /ɔ/ ] - doctor box chocolate 与 /ɔ/易混 /ʊ/ - book look foot cooking 与/u/ 互为短长音且易混 /ʌ/ - 啊和额之间 but love just /ɛ/ [/e/] - 拜和别之间 bed pet let kept smell /æ/ - cat happy bag black have happy sad and add attack 单元音长元音 /i/ \\ /i:/- feel sheep seat beat 与/ɪ/ 互为长短音 /ɜ/ \\ /ə:/ /ɔ/ [/ɔ:/] dog law /u/ \\ /u:/ school food tooth room 与/ʊ/ 互为长短音 /ɑ/ [/a:/] - father 双元音 /e/ [/eɪ/] - day may name /aɪ/ - smile like skype night /ɔɪ/ - boy oil coin /aʊ/ - now cow down /o/ \\ /əʊ/ /Ir/ \\ /ɪə/ /ɛə/ \\ /eə/ /ʊr/ /ʊə/ 清浊成对辅音 /p/ /b/ /t/ /d/ /k/ /g/ /f/ /v/ - very visitor video /θ/ /ð/ /s/ /z/ /ʃ/ -上下唇翘起，万全露出上下牙 /ʒ/ - 上下唇翘起，万全露出上下牙 television usually pleasure 与/ʃ/互为清浊辅音 /tʃ/ - 上下唇翘起，万全露出上下牙 children cheese China choice /dʒ/ - 上下唇翘起，万全露出上下牙 just 其他辅音 /h/ /m/ - million /n/ - been sixteen thin 前鼻音 /ŋ/ - hang sing song 后鼻音 /l/ - milk will lake /r/ /j/ /w/ - where /dr/ /dz/ /tr/ /ts/ "},"知识库/英语/英语易混音标.html":{"url":"知识库/英语/英语易混音标.html","title":"英语易混音标","keywords":"","body":" 英语易混音标 /s/, /z/ or /IZ/ 音标 /u:/ vs /ʊ/ vs /əʊ/ /ɒ/[ɑ] vs /ɔ:/ vs /ɑʊ/ /ə/ vs /ʌ/ vs /ɛ/[e] vs /æ/ /ɪ/ vs /i:/ 前鼻音/n/ vs 后鼻音/ŋ/ 英语易混音标 /s/, /z/ or /IZ/ 音标 清辅音后A: /s/ after /p/ /k/ /f/ /t/ /θ/ eg: cakes, crisps, suits 浊辅音和元音音素后B: /z/ after /b/, /g/, /v/, /d/, /ð/, /l/, /m/,/n/,/ŋ/ and all vowel sounds. eg: clothes, rings, views C: /IZ/ after /s/,/z/, /ʃ/, /tʃ/, /dʒ/ eg: beaches, places, stages /u:/ vs /ʊ/ vs /əʊ/ /u:/ - room, you, soon, to, two, too, do, school, fool, who, food, tooth, rule, value, boolean, module /ʊ/ (宣菁乌的嘴形发欧) - book, good, look, cool, foot, cook /əʊ/ - whole, cold, soul, drone, no, oh, stroke, know, photo, role /ɒ/[ɑ] vs /ɔ:/ vs /ɑʊ/ /ɒ/ [a, ɔ] - doctor, god, box, chocolate, toggle, property, compound, module /ɒn/ - want /aɪ/ - provide /ɑʊ/ - drown, /ɑʊn/ - down, drown /ɔ:/ - dog, door, law, call, fall, draw, four, conform /ɔ:n/ - dawn /ə/ vs /ʌ/ vs /ɛ/[e] vs /æ/ /ə/ - police, provide, of, ability, idea, banana, original, temporary, error /ən/ - conform, convenient, concise /əʊ/ - whole, cold, soul, drone, no, oh, stroke, know, photo, throw, closure, cocoa /ʌ/- 啊和额之间 but, love, just /ʌn/ - one, son, done /ɛ/ [e] - 拜和别之间 bed, dead, pet, set, let, kept, smell, whether, weather, designate, error, declaration /eə/ - declare /eɪ/ way, wait, alias /æ/ - cat, happy, bag, black, have, happy, sad, add, attack, dad /æn/ - can, and /æŋ/ - hang /ɪ/ vs /i:/ /ɪ/ [i] - 额和诶之间 this, hit, fill, ship, sit, bit, spirit, different, declare, initial, explicit, implicit, equatable与/i/ \\ /I:/互为短长音且易混 /i:/ - convenient 前鼻音/n/ vs 后鼻音/ŋ/ 前鼻音：嘴巴微闭，气流从鼻腔走。 后鼻音：张开嘴巴发前鼻音。 /n/ /ŋ/ /æn/ - can, and /æŋ/ - hang /ɪn/ - sin, insane /ɪŋ/ - sing /eɪn/ - insane /ʌn/ - one, son, done /ʌŋ/ /ɒn/ /ɒŋ/ song "},"知识库/英语/单词收藏.html":{"url":"知识库/英语/单词收藏.html","title":"单词收藏","keywords":"","body":" 词汇收藏 老友记日常用语 水果 化妆品词汇 汽车词汇 英文各种符合单词 词汇收藏 老友记日常用语 9-02 Let that go Be negative See Lie down Lay down Piss at me Technically Put aside You were saying Get past this Turn on each other Get back to Apparently Get out of this Do you have a minute Rapidly This could take a while Freak out Figure out Get over 9-03 just to be sure On the phone Set me up with someone Be used to do Utensils Flattering Humiliating It’s a lot to ask Once-in-a-life opportunity Run into you Embarrassed Stand in the way of sb Go ahead That would be nice 9-04 I didn’t catch it Didn’t until just now Seriously Damn it In horror Hold on a second A lot in common Right before That was close Halfway through Got mad at that part Going along with the lie you made How can you not remember me? I’m not saying A bunch of Ordinarily 通常 9-05 Be polite Happen to know Stuck in terrible traffic Starving Shortly Presently Might as well On hold Pull yourself together For what it’s worth I mean it Over time A couple of Keep up Special request This is for the best Look alive I would like to start celebration and make a toast to Phebe, For god’s sake Give it another try 9-06 Right away Is this a bad time? Who cares Roughly translated Ironic Save it Don’t get me started on the way people talk Look at it in that way Just so you know That’s not the point Take good care of her More than happy Work on in the future 9-07 No idea Awesome That’s all that matters 9-09 That’s not the way to convince you Why don’t we Hear me out Out of curiosity How dare you accuse me of that I’ll be right back/there 9-10 Did I not mention that? This doesn’t concern you There is really nothing to worry about Take advantage I’m so bad at this One thing at a time 9-11 Overwhelming Pay off Informed decision Taking over Dawdling Picture Back to the way it was Get this straight Incidentally = by the way Sudden change of plans From scratch Put it this way Fill me in on what you’ve been up to Get me up to speed Catch me up Take care of Take a quick scan Moonlight as a waitress From the top I’m caught up on everything Ross is not gonna pick her up for another hour She won’t go easy There’s always gonna be a reason not to do this What if On purpose She’d be doing Now that Racheal’s gone 9-12 Hopefully 最好 Get rid of it For once Go after In a week or two As a matter of fact Right behind you Do you mind giving us a minute Make up for being such a jerk to you 9-13 Put sth on hold Before I forget I’m there Call in sick Swoop in Get in the middle of something bad timing You have got to do Firm no Coming up next What I’m about to tell you Clearly 9-14 Comes to mind What’s happening between xx and cc What are you up to? Gets stood up被放鸽子 9-15 like last time Don’t make me more nervous than I already am for whose benefit 为了某人 behind you 9-16 Worst-case scenario Working twice as hard Partly because Mostly because What brought that on One problem at a time Get onboard The more I thought about it, the more I realize Just one last time Look on the bright side 9-17 Check this out In the last two minutes Make it clear Why wouldn’t she? 水果 Peach Red Plumbs Nectarine litchi (荔枝） Kiwi Fruit （猕猴桃） 化妆品词汇 护肤品词汇 Skin care products face mask 面膜 acne 痘痘 dark spots 斑点 hydrating 保湿 cream 膏状 gel 啫喱 Normal skin 正常皮肤 dry sensitive oily skin Combination skin T区油两脸颊干 Acne prone skin care products 痘痘肌用产品 break out爆痘 anti-blemish 祛痘产品 anti-aging抗老化 Dullness 皮肤暗淡 blackheads 黑头 wrinkles 皱纹 loss of firmness/elasticity 缺乏弹性 Pore (shrinking/minimizing)收缩毛孔 redness敏感泛红 uneven skintone肤色不均 face wash/cleanser 洁面产品 toner 调理水/爽肤水 exfoliater 去角质产品 serum精华 eye cream 眼霜 moisturizer/lotion 保湿霜 nose strips 祛黑头贴 blotting paper 吸油纸 汽车词汇 instrument cluster/panel仪表盘 Hood 引擎盖 Trunk 后备箱 Left/right blinker左右转向灯 odometer/speedometer 里程表/速度表 rear view mirror车内后视镜 side mirror左右后视镜 stick shift手动挡 clutch离合 gas pedal center console/armrest 中间放手的地方 parking brake手刹 horn喇叭 honk at sb向某人按喇叭 glove compartment/box副驾储物盒 dashboard 车窗下平台 air vent出风口 Seatbelt buckle扣 cup holder gear selector headlights 近光灯=车灯 high beam远光灯 fog light 雾灯 英文各种符合单词 冒号: Colon 分号: Semicolon 问号？Question Mark 感叹号! Exclamation Mark 小括号() Round Brackets/parentheses 大括号{} Curly Brackets 方括号[] Angle/Square Brackets 引号“” Quotation Mark 斜杆/ Forward Slash 横杠- Hyphen 下划线_ Underscore "},"知识库/英语/英语读音技巧.html":{"url":"知识库/英语/英语读音技巧.html","title":"英语读音技巧","keywords":"","body":"读音技巧 浊化、连读、吞音 "},"知识库/Others/篮球/突破.html":{"url":"知识库/Others/篮球/突破.html","title":"突破","keywords":"","body":" 1、单手体前变向 2、右单手持进，左脚左迈晃 突破招数： 0、节奏/停顿 1、单手体前变向 2、右单手持进，左脚左迈晃 3、欧洲步 4、快速胯下体前变向 5、哈登步 6、ShemGod 7、右大迈拉左小拉回 8、Switch hand crossover 9、Double Killer Crossover (Durant) "},"知识库/Others/篮球/篮下脚步.html":{"url":"知识库/Others/篮球/篮下脚步.html","title":"篮下脚步","keywords":"","body":"篮下脚步 "},"知识库/Others/篮球/破人盯人.html":{"url":"知识库/Others/篮球/破人盯人.html","title":"破人盯人","keywords":"","body":"破人盯人 破人盯人的理念： 采用3、2落位，45度两个人分别与三分线外两个人做来回挡拆。 "}}