# 对象在内存中的存储

1. 

2. 类加载

   - 在创建对象时，需要访问类
   - 声明一个类的指针变量也会访问类
   - 在程序运行期间，当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个过程叫 `类加载`
   - 类只加载一次，在第一次被访问时
   - 一旦类被加载到代码段以后，直到程序结束后才会被释放

3. ### 对象在内存中究竟如何存储？

   - 假设下面这个写在函数中

     ```objc
     Person *p1 = [Person new];
     ```

     > - Person *p1; 
     >
     >   会在栈内存中申请1块控件，在栈内存中声明1个Person类型的指针变量 p1
     >
     >   p1是个指针变量，那么只能存储地址
     >
     > - [Person new];
     >
     >   > 真正在内存中创建对象的是此代码
     >
     >   new 做的事情
     >
     >   > - 在堆内存中申请1块合适大小的空间
     >   > - 在这个空间中根据类的模板创建对象
     >   >   - 类模板中定义了什么属性，就把这些属性一次声明在对象中
     >   >   - 对象中还有另外1个属性，叫做 isa， 是一个指针变量，指向对象所属的类在代码段中存储的地址
     >   > - 初始化对象的属性
     >   >   - 如果属性类型是基本数据类型，赋值为 0
     >   >   - 如果属性类型是C指针类型，赋值为 NULL
     >   >   - 如果属性类型为 OC 的类指针类型，赋值为 nil
     >   > - 返回对象的地址

   - 注意

     - 对象中只有属性，没有方法，自己类的属性外加一个isa 指针指向代码段中的类

     - 如何访问对象的属性

       指针名 -> 属性名;

       根据指针 找到指针指向的对象 再找到对象中的属性来访问

     - 如何调用方法

       [指针名 方法名];

       [p1 run];

       - 编译阶段 `[p1 run];`  被编译器转换为

         > objc_msgSend(p1, run)

       - 运行时阶段: 消息接受者 p1 寻找对应的 selector

         > - 通过 p1 的 `isa` 指针，找到 p1 的 `class (类)`【在代码段中，也是个对象】
         > - 在 `Class (类)` 的 `cache(方法缓存)` 的散列表中寻找对应的 IMP(方法实现)
         > - 如果在 方法缓存 中没有找到 方法实现，就在 类的 method List (方法列表) 中找对应的 `selector`，如果找到，填充到 `cache (方法缓存中)` 中，并返回 `selector`;
         > - 如果在 类 中没有找到这个 `selector`，就继续在它的 `superclass(父类)`中找;
         > - 一旦找到对应的 selector，直接执行 receiver 对应的 selector 方法实现 `IMP (方法实现)`
         > - 若找不到对应的 selector，Runtime 系统进入消息转发机制

       - 运行时消息转发阶段

         - 动态解析【用其他方法代替此方法】

           > 通过重写 `+resolveInstanceMethod:` 或者 `+resolveClassMethod` 方法，利用 `class_addMethod` 方法添加其他函数实现;

         - 消息接受者重定向【把消息发送给其他对象，比如p2】

           > 如果上一步添加其他函数实现，可在当前对象中利用 `forwardingTargetForSelector:` 方法将消息的接受者转发给其他对象；

         - 消息重定向【】

           > 如果上一步没有返回值为 nil，则利用 `methodSignatureForSelector:` 方法获取函数的参数和返回值类型
           >
           > - 如果 `methodSignatureForSelector:` 返回了一个 `NSMethodSignature` 对象 (函数签名)，Runtime系统就会创建一个 `NSInvocation` 对象，并通过 `forwordInvocation:` 消息通知当前对象，给予此次消息发送最后一次寻找 IMP 的机会。
           > - 如果 `methodSignatureForSelector:` 返回 nil，则 Runtime 系统会发出 `doesNotRecognizeSelector:` 消息，程序也就崩溃了

[Person new]创建一个普通对象，就是按照类结构体模型在堆中创建一个结构体变量

在 Person 类第一次被访问时，创建一个 Person 类，就是按照元类结构体创建一个元类结构体变量

创建一个元类，就是按照 NSObject 结构体? 创建一个结构体变量



- 为什么不把方法存储在对象中？

  > 因为每个对象的方法的代码实现都是一模一样的，没有必要为每个对象都保存一个方法，这样的话就太浪费空间了

- 对象的属性的默认值

  > 如果我们创建了一个对象，没有为对象的属性赋值，属性是有按规则赋的默认值的

- 