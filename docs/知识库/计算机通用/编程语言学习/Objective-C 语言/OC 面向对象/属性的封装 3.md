# 属性的封装

- 面向对象的三大特征是什么？

  - 封装

    > - 函数就是封装的体现
    >
    > - 类是更高级的封装，将很多数据和行为(属性和很多方法)封装在一个对象里
    >   - 屏蔽内部的实现，外界不需要知道内部是如何实现的，只需要知道这个对象有什么用
    >   - 方便操作
    >   - 后期维护十分便利

  - 继承

  - 多态

- ### 属性为什么要封装？

  - 为对象的属性赋值时，语法上只要数据的类型符合属性类型即可
  - 但是，情理上，不合适。
  - 比如，Person 对象有 int 类型的属性 _age 表示一个人的年龄
  - 为这个对象的 _age 属性赋值时，其实只要是 int 类型的数据，语法上完全可以的
  - 但是一个人的年龄，正常情况下在 0 - 200 之间

  解决的问题: 

  在为对象的属性赋值的时候，希望将这个数据做1个逻辑验证

  如果逻辑判断合理，则赋值，否则不赋值

- ### 怎么实现为属性赋值时进行逻辑判断？

  - 在类中实现

  - 将属性的 @public 去掉

    > 因为一旦写上 @public，外界就能直接访问对象的这个属性
    >
    > 外界一旦可以直接访问这个属性，那么外界就可以任意为此属性赋值，无法拦截

  - 【setter】为类提供一个方法，此方法专门为这个属性赋值，这个方法我们叫做 setter

    - 这个方法一定是一个对象方法，因为这个要为属性赋值

    - 这个方法没有返回值，仅仅为属性赋值而已

    - 这个方法名字必须以 set 开头，跟上去掉下划线首字母大写的属性名

    - 这个方法一定有参数，参数类型与属性类型一致。参数的名称和属性的名称一致(去掉下划线) ，比如为 _age 赋值，setAge 方法

    - 在方法的实现中，判断传入的数据是否符合逻辑，如果符合逻辑则赋值，否则做默认处理

    - 外界想要为对象的属性赋值，那么就调用这个对象的 setter 方法，将要赋值的数据传入给这个方法

      方法会对这个数据进行验证，如果符合验证，就会把数据赋值给属性，否则做默认处理

  - 【getter】又因为，没有 @public，所以属性值无法读取了，所以再提供一个方法，专门返回属性值，这个方法叫做 getter 方法

    - 这个方法一定是一个对象方法，因为这个方法做的事情是拿到属性的值返回
    - 这个方法肯定是有返回值，返回值的类型和属性的类型一致
    - 这个方法的名称就是属性的名称去掉下划线，没有参数
    - 这个方法的实现是直接向属性的值返回
    - 这个时候，如果外界希望得到属性的值，只需要调用这个 getter 方法即可

- 封装规范

  - 什么时候封装？

    只要这个属性需要被外界访问时，哪怕在访问时没有任何逻辑验证，都需要封装 getter 和 setter

    如果属性只在类的内部访问，那么久不需要为其封装 getter setter

  - 只读封装:

    为属性封装时，只提供 getter ，不提供 setter

  - 只写封装

    为属性封装的时候，只提供 setter，不提供 getter

  