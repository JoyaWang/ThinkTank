# 内存泄漏

- ### 什么叫内存泄漏？

  > 指对象没有被回收，该回收的时候没有被回收，一直驻留在内存中知道程序结束

- 单个对象发生内存泄漏的原因

  - 有对象的创建，没有匹配的 release
  - retain 与 release 不匹配
  - 在不恰当的时候，指针赋值为 nil
  - 在方法中不当使用 retain

- 如何做到单个对象被正确释放

  - 有对象的创建就要有对象的 release
  - 有多少个 retain 就要有多少个 release
  - 不要轻易为 1 个指针赋值为 nil，除非指针是 1 个野指针
  - 在方法中不要轻易的为参数 retain

- 

- 多个对象的内存泄漏

  - 当 1 个对象的属性是另外 1 个对象的时候，如果对这个属性的 set 封装还是像我们基础班那样直接赋值，就会出现野指针的问题

- set 方法的内存管理

  在 MRC 的模式下，如果属性的类型是 OC 对象类型的，这个属性的 setter 方法应该如何写？

  ```objc
  ///  _dog 属性的 setter 方法
  /// @param dog  用来赋值的 dog 对象
  - (void)setDog:(Dog *)dog {
      // 当赋值的对象和就对象是同一对象时，什么也不做
      if (_dog != dog) // 当新旧对象不是同一对象时, 进行赋值
      {
          // setter 方法的作用: 将传递进来的 dog 对象，赋值给当前对象的 _dog 属性
          // 1. 就对象不再使用，向旧对象发送一条 release 消息
          [_dog release];
          // 2. 使用新对象，向新对象发送一条 retain 消息
          _dog = [dog retain];
      }
  }
  ```

- ### 循环 retain

  当两个对象相互关联时

  人对象中有 1 个车

  车对象中有 1 个人

  如果这两个 @property 都使用 retain，就会出现泄漏

  解决方案: 1 端 retain，1 端 assign，使用 assign 的那端不再需要在 dealloc 中 release 了

